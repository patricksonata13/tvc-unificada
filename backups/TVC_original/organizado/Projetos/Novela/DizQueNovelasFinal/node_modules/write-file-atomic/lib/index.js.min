"use strict";module.exports=writeFile,module.exports.sync=writeFileSync,module.exports._getTmpname=getTmpname,module.exports._cleanupOnExit=cleanupOnExit;const fs=require("fs"),MurmurHash3=require("imurmurhash"),onExit=require("signal-exit"),path=require("path"),{promisify:promisify}=require("util"),activeFiles={},threadId=function(){try{return require("worker_threads").threadId}catch(i){return 0}}();let invocations=0;function getTmpname(i){return i+"."+MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result()}function cleanupOnExit(i){return()=>{try{fs.unlinkSync("function"==typeof i?i():i)}catch{}}}function serializeActiveFile(i){return new Promise(e=>{activeFiles[i]||(activeFiles[i]=[]),activeFiles[i].push(e),1===activeFiles[i].length&&e()})}function isChownErrOk(i){if("ENOSYS"===i.code)return!0;return!(process.getuid&&0===process.getuid()||"EINVAL"!==i.code&&"EPERM"!==i.code)}async function writeFileAsync(i,e,t={}){let n,r;"string"==typeof t&&(t={encoding:t});const c=onExit(cleanupOnExit(()=>r)),s=path.resolve(i);try{await serializeActiveFile(s);const c=await promisify(fs.realpath)(i).catch(()=>i);if(r=getTmpname(c),!t.mode||!t.chown){const i=await promisify(fs.stat)(c).catch(()=>{});i&&(null==t.mode&&(t.mode=i.mode),null==t.chown&&process.getuid&&(t.chown={uid:i.uid,gid:i.gid}))}n=await promisify(fs.open)(r,"w",t.mode),t.tmpfileCreated&&await t.tmpfileCreated(r),ArrayBuffer.isView(e)?await promisify(fs.write)(n,e,0,e.length,0):null!=e&&await promisify(fs.write)(n,String(e),0,String(t.encoding||"utf8")),!1!==t.fsync&&await promisify(fs.fsync)(n),await promisify(fs.close)(n),n=null,t.chown&&await promisify(fs.chown)(r,t.chown.uid,t.chown.gid).catch(i=>{if(!isChownErrOk(i))throw i}),t.mode&&await promisify(fs.chmod)(r,t.mode).catch(i=>{if(!isChownErrOk(i))throw i}),await promisify(fs.rename)(r,c)}finally{n&&await promisify(fs.close)(n).catch(()=>{}),c(),await promisify(fs.unlink)(r).catch(()=>{}),activeFiles[s].shift(),activeFiles[s].length>0?activeFiles[s][0]():delete activeFiles[s]}}async function writeFile(i,e,t,n){t instanceof Function&&(n=t,t={});const r=writeFileAsync(i,e,t);if(n)try{return n(await r)}catch(i){return n(i)}return r}function writeFileSync(i,e,t){"string"==typeof t?t={encoding:t}:t||(t={});try{i=fs.realpathSync(i)}catch(i){}const n=getTmpname(i);if(!t.mode||!t.chown)try{const e=fs.statSync(i);(t=Object.assign({},t)).mode||(t.mode=e.mode),!t.chown&&process.getuid&&(t.chown={uid:e.uid,gid:e.gid})}catch(i){}let r;const c=cleanupOnExit(n),s=onExit(c);let o=!0;try{if(r=fs.openSync(n,"w",t.mode||438),t.tmpfileCreated&&t.tmpfileCreated(n),ArrayBuffer.isView(e)?fs.writeSync(r,e,0,e.length,0):null!=e&&fs.writeSync(r,String(e),0,String(t.encoding||"utf8")),!1!==t.fsync&&fs.fsyncSync(r),fs.closeSync(r),r=null,t.chown)try{fs.chownSync(n,t.chown.uid,t.chown.gid)}catch(i){if(!isChownErrOk(i))throw i}if(t.mode)try{fs.chmodSync(n,t.mode)}catch(i){if(!isChownErrOk(i))throw i}fs.renameSync(n,i),o=!1}finally{if(r)try{fs.closeSync(r)}catch(i){}s(),o&&c()}}