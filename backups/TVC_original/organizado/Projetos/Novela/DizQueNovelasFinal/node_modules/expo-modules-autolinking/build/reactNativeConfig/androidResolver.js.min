"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolveDependencyConfigImplAndroidAsync=resolveDependencyConfigImplAndroidAsync,exports.parsePackageNameAsync=parsePackageNameAsync,exports.parseNativePackageClassNameAsync=parseNativePackageClassNameAsync,exports.matchNativePackageClassName=matchNativePackageClassName,exports.parseLibraryNameAsync=parseLibraryNameAsync,exports.parseComponentDescriptorsAsync=parseComponentDescriptorsAsync,exports.findGradleAndManifestAsync=findGradleAndManifestAsync;const promises_1=__importDefault(require("fs/promises")),path_1=__importDefault(require("path")),utils_1=require("../utils");async function resolveDependencyConfigImplAndroidAsync(e,a,t){if(null===a)return null;const s=a?.sourceDir||"android",n=path_1.default.join(e,s),{gradle:i,manifest:r}=await findGradleAndManifestAsync({androidDir:n,isLibrary:!0}),o=null!=a?.cxxModuleCMakeListsModuleName&&null!=a?.cxxModuleCMakeListsPath&&null!=a?.cxxModuleHeaderName&&!r&&!i;if(!r&&!i&&!o)return null;if(void 0===a&&t?.supportsPlatform("android")&&i&&!t?.rawConfig.android?.gradlePath)return null;let c=null,l=null;if(!o){const t=a?.packageName||await parsePackageNameAsync(r,i);if(!t)return null;const s=await parseNativePackageClassNameAsync(e,n);if(!s)return null;l=a?.packageImportPath||`import ${t}.${s};`,c=a?.packageInstance||`new ${s}()`}const u=JSON.parse(await promises_1.default.readFile(path_1.default.join(e,"package.json"),"utf8")),d=a?.buildTypes||[],p=a?.dependencyConfiguration,m=a?.libraryName||await parseLibraryNameAsync(n,u),f=a?.componentDescriptors||await parseComponentDescriptorsAsync(e,u);let g=a?.cmakeListsPath?path_1.default.join(n,a?.cmakeListsPath):path_1.default.join(n,"build/generated/source/codegen/jni/CMakeLists.txt");const y=a?.cxxModuleCMakeListsModuleName||null,h=a?.cxxModuleHeaderName||null;let x=a?.cxxModuleCMakeListsPath?path_1.default.join(n,a?.cxxModuleCMakeListsPath):null;"win32"===process.platform&&(g=g.replace(/\\/g,"/"),x&&(x=x.replace(/\\/g,"/")));const C={sourceDir:n,packageImportPath:l,packageInstance:c,dependencyConfiguration:p,buildTypes:d,libraryName:m,componentDescriptors:f,cmakeListsPath:g,cxxModuleCMakeListsModuleName:y,cxxModuleCMakeListsPath:x,cxxModuleHeaderName:h,isPureCxxDependency:o};return C.libraryName||delete C.libraryName,C.dependencyConfiguration||delete C.dependencyConfiguration,C}async function parsePackageNameAsync(e,a){if(a){const e=(await promises_1.default.readFile(a,"utf8")).match(/namespace\s*[=]*\s*["'](.+?)["']/);if(e)return e[1]}if(e){const a=(await promises_1.default.readFile(e,"utf8")).match(/package="(.+?)"/);if(a)return a[1]}return null}async function parseNativePackageClassNameAsync(e,a){for await(const e of(0,utils_1.scanFilesRecursively)(a,void 0,!0))if(e.name.endsWith("Package.java")||e.name.endsWith("Package.kt"))try{const a=await promises_1.default.readFile(e.path),t=matchNativePackageClassName(e.path,a);if(t)return t}catch{continue}if(await(0,utils_1.fileExistsAsync)(path_1.default.join(e,"expo-module.config.json")))return null;for await(const e of(0,utils_1.scanFilesRecursively)(a,void 0,!0))if(e.name.endsWith(".java")||e.name.endsWith(".kt")){const a=await promises_1.default.readFile(e.path),t=matchNativePackageClassName(e.path,a);if(t)return t}return null}let lazyReactPackageRegex=null,lazyTurboReactPackageRegex=null;function matchNativePackageClassName(e,a){const t=a.toString();lazyReactPackageRegex||(lazyReactPackageRegex=/class\s+(\w+[^(\s]*)[\s\w():]*(\s+implements\s+|:)[\s\w():,]*[^{]*ReactPackage/);const s=t.match(lazyReactPackageRegex);if(s)return s[1];lazyTurboReactPackageRegex||(lazyTurboReactPackageRegex=/class\s+(\w+[^(\s]*)[\s\w():]*(\s+extends\s+|:)[\s\w():,]*[^{]*(Base|Turbo)ReactPackage/);const n=t.match(lazyTurboReactPackageRegex);return n?n[1]:null}async function parseLibraryNameAsync(e,a){if(a.codegenConfig?.name)return a.codegenConfig.name;const t=/libraryName = ["'](.+)["']/,s=path_1.default.join(e,"build.gradle");if(await(0,utils_1.fileExistsAsync)(s)){const e=(await promises_1.default.readFile(s,"utf8")).match(t);if(e)return e[1]}const n=path_1.default.join(e,"build.gradle.kts");if(await(0,utils_1.fileExistsAsync)(n)){const e=(await promises_1.default.readFile(n,"utf8")).match(t);if(e)return e[1]}return null}async function parseComponentDescriptorsAsync(e,a){const t=a?.codegenConfig?.jsSrcsDir?path_1.default.join(e,a.codegenConfig.jsSrcsDir):e,s=/\.[tj]sx?$/,n=new Set;for await(const e of(0,utils_1.scanFilesRecursively)(t))if(s.test(e.name)){const a=await promises_1.default.readFile(e.path),t=matchComponentDescriptors(e.path,a);t&&n.add(t)}return[...n].sort((e,a)=>e.localeCompare(a))}let lazyCodegenComponentRegex=null;function matchComponentDescriptors(e,a){const t=a.toString();lazyCodegenComponentRegex||(lazyCodegenComponentRegex=/codegenNativeComponent(<.*>)?\s*\(\s*["'`](\w+)["'`](,?[\s\S]+interfaceOnly:\s*(\w+))?/m);const s=t.match(lazyCodegenComponentRegex);return"true"!==s?.[4]&&s?.[2]?`${s[2]}ComponentDescriptor`:null}const findAndroidManifestsAsync=async e=>{const a=(0,utils_1.scanFilesRecursively)(e,(a,t)=>{switch(t){case"build":case"debug":case"Pods":return!1;case"Examples":case"examples":return a!==e;case"android":return!/[\\/]sdks[\\/]hermes$/.test(a);case"androidTest":case"test":return!/[\\/]src$/.test(a);default:return!0}}),t=[];for await(const e of a)"AndroidManifest.xml"===e.name&&t.push(e.path);return t.sort((e,a)=>e.localeCompare(a))},getFileCandidatesAsync=async(e,a)=>(await Promise.all(a.map(a=>(0,utils_1.fileExistsAsync)(path_1.default.join(e,a))))).filter(e=>null!=e).sort((e,a)=>e.localeCompare(a));async function findGradleAndManifestAsync({androidDir:e,isLibrary:a}){const[t,s]=await Promise.all([findAndroidManifestsAsync(e),getFileCandidatesAsync(a?e:path_1.default.join(e,"app"),["build.gradle","build.gradle.kts"])]),n=t.find(e=>e.includes("src/main/"))??t.sort((e,a)=>e.localeCompare(a))[0];return{gradle:s.sort((e,a)=>e.localeCompare(a))[0]||null,manifest:n||null}}