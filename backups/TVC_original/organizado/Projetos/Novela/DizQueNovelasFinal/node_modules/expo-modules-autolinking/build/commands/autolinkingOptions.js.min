"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.filterMapSearchPaths=void 0,exports.registerAutolinkingArguments=registerAutolinkingArguments,exports.createAutolinkingOptionsLoader=createAutolinkingOptionsLoader;const fs_1=__importDefault(require("fs")),path_1=__importDefault(require("path")),isJSONObject=e=>null!=e&&"object"==typeof e,resolvePathMaybe=(e,t)=>{if("string"!=typeof e)return null;let a=path_1.default.resolve(t,e);return fs_1.default.existsSync(a)?a:(a=path_1.default.resolve(e))&&fs_1.default.existsSync(e)?e:null},filterMapSearchPaths=(e,t)=>Array.isArray(e)?e.map(e=>resolvePathMaybe(e,t)).filter(e=>null!=e):void 0;exports.filterMapSearchPaths=filterMapSearchPaths;const parsePackageJsonOptions=(e,t,a)=>{const r=isJSONObject(e.expo)?e.expo:null,o=r&&isJSONObject(r.autolinking)?r.autolinking:null;let s=null;a&&(s=o&&isJSONObject(o[a])?o[a]:null,s||"apple"!==a||(s=o&&isJSONObject(o.ios)?o.ios:null));const l={...o,...s},n={};if(null!=l.legacy_shallowReactNativeLinking&&(n.legacy_shallowReactNativeLinking=!!l.legacy_shallowReactNativeLinking),"string"==typeof l.searchPaths||Array.isArray(l.searchPaths)){const e="string"==typeof l.searchPaths?[l.searchPaths]:l.searchPaths;n.searchPaths=(0,exports.filterMapSearchPaths)(e,t)}return"string"==typeof l.nativeModulesDir&&(n.nativeModulesDir=resolvePathMaybe(l.nativeModulesDir,t)),Array.isArray(l.exclude)&&(n.exclude=l.exclude.filter(e=>"string"==typeof e)),Array.isArray(l.buildFromSource)&&(n.buildFromSource=l.buildFromSource.filter(e=>"string"==typeof e)),isJSONObject(l.flags)&&(n.flags={...l.flags}),n};function registerAutolinkingArguments(e){return e.option("-e, --exclude <exclude...>","Package names to exclude when looking up for modules.",(e,t)=>(t??[]).concat(e)).option("-p, --platform [platform]",'The platform that the resulting modules must support. Available options: "apple", "android"',"apple").option("--project-root <projectRoot>","The path to the root of the project. Defaults to current working directory",process.cwd())}const parseExtraArgumentsOptions=e=>{const t=process.cwd(),a=e.platform||void 0,r=resolvePathMaybe(e.projectRoot,t)||t,o=(0,exports.filterMapSearchPaths)(e.searchPaths,r),s=e.exclude?.filter(e=>"string"==typeof e);return{platform:a,commandRoot:r,extraSearchPaths:o,extraExclude:s}},findPackageJsonPathAsync=async e=>{const t=e||process.cwd();for(let e=t;path_1.default.dirname(e)!==e;e=path_1.default.dirname(e)){const t=path_1.default.resolve(e,"package.json");if(fs_1.default.existsSync(t))return t}throw new Error(`Couldn't find "package.json" up from path "${t}"`)},loadPackageJSONAsync=async e=>{const t=await fs_1.default.promises.readFile(e,"utf8");return JSON.parse(t)};function createAutolinkingOptionsLoader(e){const t=parseExtraArgumentsOptions(e??{}),{commandRoot:a}=t;let r;const o=()=>r||(r=findPackageJsonPathAsync(a));let s;const l=async()=>path_1.default.dirname(await o());return{getCommandRoot:()=>a,getAppRoot:l,async getPlatformOptions(e=t.platform){const a=await(async()=>s||(s=loadPackageJSONAsync(await o())))(),r=await l(),n=parsePackageJsonOptions(a,r,e);return t.extraSearchPaths&&(n.searchPaths=[...t.extraSearchPaths,...n.searchPaths??[]]),t.extraExclude&&(n.exclude=[...n.exclude??[],...t.extraExclude]),{...normalizeAutolinkingOptions(n,r),platform:e}}}}const normalizeAutolinkingOptions=(e,t)=>({legacy_shallowReactNativeLinking:e.legacy_shallowReactNativeLinking??!1,searchPaths:e.searchPaths??[],nativeModulesDir:e.nativeModulesDir?resolvePathMaybe(e.nativeModulesDir,t)??null:resolvePathMaybe("./modules",t)??null,exclude:e.exclude??[],buildFromSource:e.buildFromSource,flags:e.flags});