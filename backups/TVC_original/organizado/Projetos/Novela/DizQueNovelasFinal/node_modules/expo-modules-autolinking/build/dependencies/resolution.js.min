"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.scanDependenciesRecursively=scanDependenciesRecursively;const node_module_1=__importDefault(require("node:module")),utils_1=require("./utils"),MAX_DEPTH=8,createNodeModulePathsCreator=()=>{const e=new Map;return async function(n){const t=[],s=node_module_1.default._nodeModulePaths(n);for(let n=0;n<s.length;n++){const l=s[n];let a=e.get(l);void 0===a&&(a=await(0,utils_1.maybeRealpath)(l),0!==n&&e.set(l,a)),null!=a&&t.push(a)}return t}};async function resolveDependencies(e,n,t,s){const l=Object.create(null);if(null!=e.dependencies&&"object"==typeof e.dependencies&&Object.assign(l,e.dependencies),0===t&&null!=e.devDependencies&&"object"==typeof e.devDependencies&&Object.assign(l,e.devDependencies),null!=e.peerDependencies&&"object"==typeof e.peerDependencies){const n=null!=e.peerDependenciesMeta&&"object"==typeof e.peerDependenciesMeta?e.peerDependenciesMeta:void 0;for(const t in e.peerDependencies)isOptionalPeerDependencyMeta(n,t)||(l[t]="")}return(await Promise.all(Object.keys(l).filter(e=>s(e)).map(e=>(async e=>{for(let s=0;s<n.length;s++){const l=(0,utils_1.fastJoin)(n[s],e),a=await(0,utils_1.maybeRealpath)(l);if(null!=a)return{source:0,name:e,version:"",path:a,originPath:l,duplicates:null,depth:t}}return null})(e)))).filter(e=>null!=e)}async function scanDependenciesRecursively(e,{shouldIncludeDependency:n=utils_1.defaultShouldIncludeDependency,limitDepth:t}={}){const s=await(0,utils_1.maybeRealpath)(e);if(!s)return{};const l=new Set,a=createNodeModulePathsCreator(),i=null!=t?t:MAX_DEPTH,o=async(e,t=0)=>{const s=Object.create(null),[r,c]=await Promise.all([a(e.path),(0,utils_1.loadPackageJson)((0,utils_1.fastJoin)(e.path,"package.json"))]);if(!c)return s;e.version=c.version||"";const u=await resolveDependencies(c,r,t,n);for(let e=0;e<u.length;e++)s[u[e].name]=u[e];if(t+1<i){const e=await Promise.all(u.filter(e=>!l.has(e.path)&&(l.add(e.path),!0)).map(e=>o(e,t+1)));return(0,utils_1.mergeResolutionResults)(e,s)}return s};return await o({source:0,name:"",version:"",path:s,originPath:e,duplicates:null,depth:-1})}const isOptionalPeerDependencyMeta=(e,n)=>e&&null!=e[n]&&"object"==typeof e[n]&&"optional"in e[n]&&!!e[n].optional;