"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transformProgram=transformProgram;var _SimpleTransform=require("../transform/SimpleTransform"),_astNodeMutationHelpers=require("../transform/astNodeMutationHelpers"),_createSyntaxError=require("../utils/createSyntaxError"),_Builders=require("../utils/Builders"),_GenID=require("../utils/GenID");let GenID=null;function genIdent(){if(null==GenID)throw Error("GenID must be initialized at the start of the transform.");return(0,_Builders.ident)(GenID.genID())}function objKeyToString(e){switch(e.type){case"Identifier":return e.name;case"Literal":{const{value:t}=e;return"number"==typeof t?String(t):"string"==typeof t?t:e.raw}}}function convertMemberPattern(e){const{base:t,property:n,loc:r,range:i}=e,s="MatchIdentifierPattern"===t.type?t.id:convertMemberPattern(t);return"Identifier"===n.type?{type:"MemberExpression",object:s,property:n,computed:!1,optional:!1,...(0,_Builders.etc)({loc:r,range:i})}:{type:"MemberExpression",object:s,property:n,computed:!0,optional:!1,...(0,_Builders.etc)({loc:r,range:i})}}function checkDuplicateBindingName(e,t,n){if(e.has(n))throw(0,_createSyntaxError.createSyntaxError)(t,`Duplicate variable name '${n}' in match case pattern.`);e.add(n)}function checkBindingKind(e,t){if("var"===t)throw(0,_createSyntaxError.createSyntaxError)(e,"'var' bindings are not allowed. Use 'const' or 'let'.")}function needsPropExistsCond(e){switch(e.type){case"MatchWildcardPattern":case"MatchBindingPattern":case"MatchIdentifierPattern":case"MatchMemberPattern":return!0;case"MatchLiteralPattern":case"MatchUnaryPattern":case"MatchObjectPattern":case"MatchArrayPattern":return!1;case"MatchAsPattern":{const{pattern:t}=e;return needsPropExistsCond(t)}case"MatchOrPattern":{const{patterns:t}=e;return t.some(needsPropExistsCond)}}}function analyzePattern(e,t,n){switch(e.type){case"MatchWildcardPattern":return{conditions:[],bindings:[]};case"MatchLiteralPattern":{const{literal:n}=e;return{conditions:[{type:"eq",key:t,arg:n}],bindings:[]}}case"MatchUnaryPattern":{const{operator:n,argument:r,loc:i,range:s}=e;if(0===r.value)throw(0,_createSyntaxError.createSyntaxError)(e,"'+0' and '-0' are not yet supported in match unary patterns.");const a={type:"UnaryExpression",operator:n,argument:r,prefix:!0,...(0,_Builders.etc)({loc:i,range:s})};return{conditions:[{type:"eq",key:t,arg:a}],bindings:[]}}case"MatchIdentifierPattern":{const{id:n}=e;return{conditions:["NaN"===n.name?{type:"is-nan",key:t}:{type:"eq",key:t,arg:n}],bindings:[]}}case"MatchMemberPattern":{const n=convertMemberPattern(e);return{conditions:[{type:"eq",key:t,arg:n}],bindings:[]}}case"MatchBindingPattern":{const{id:r,kind:i}=e;checkDuplicateBindingName(n,e,r.name),checkBindingKind(e,i);return{conditions:[],bindings:[{type:"id",key:t,kind:i,id:r}]}}case"MatchAsPattern":{const{pattern:r,target:i}=e;if("MatchBindingPattern"===r.type)throw(0,_createSyntaxError.createSyntaxError)(e,"Match 'as' patterns are not allowed directly on binding patterns.");const{conditions:s,bindings:a}=analyzePattern(r,t,n),[o,c]="MatchBindingPattern"===i.type?[i.id,i.kind]:[i,"const"];checkDuplicateBindingName(n,e,o.name),checkBindingKind(e,c);const l={type:"id",key:t,kind:c,id:o};return{conditions:s,bindings:a.concat(l)}}case"MatchArrayPattern":{const{elements:r,rest:i}=e,s=null==i?"eq":"gte",a=[{type:"array",key:t,length:r.length,lengthOp:s}],o=[];if(r.forEach((e,r)=>{const i=t.concat((0,_Builders.numberLiteral)(r)),{conditions:s,bindings:c}=analyzePattern(e,i,n);a.push(...s),o.push(...c)}),null!=i&&null!=i.argument){const{id:s,kind:a}=i.argument;checkDuplicateBindingName(n,i.argument,s.name),checkBindingKind(e,a),o.push({type:"array-rest",key:t,exclude:r.length,kind:a,id:s})}return{conditions:a,bindings:o}}case"MatchObjectPattern":{const{properties:r,rest:i}=e,s=[{type:"object",key:t}],a=[],o=[],c=new Set;if(r.forEach(e=>{const{key:r,pattern:i}=e;o.push(r);const l=objKeyToString(r);if(c.has(l))throw(0,_createSyntaxError.createSyntaxError)(i,`Duplicate property name '${l}' in match object pattern.`);c.add(l);const d=t.concat(r);needsPropExistsCond(i)&&s.push({type:"prop-exists",key:t,propName:l});const{conditions:u,bindings:p}=analyzePattern(i,d,n);s.push(...u),a.push(...p)}),null!=i&&null!=i.argument){const{id:r,kind:s}=i.argument;checkDuplicateBindingName(n,i.argument,r.name),checkBindingKind(e,s),a.push({type:"object-rest",key:t,exclude:o,kind:s,id:r})}return{conditions:s,bindings:a}}case"MatchOrPattern":{const{patterns:r}=e;let i=!1;const s=r.map(r=>{const{conditions:s,bindings:a}=analyzePattern(r,t,n);if(a.length>0)throw(0,_createSyntaxError.createSyntaxError)(e,"Bindings in match 'or' patterns are not yet supported.");return 0===s.length&&(i=!0),s});return i?{conditions:[],bindings:[]}:{conditions:[{type:"or",orConditions:s}],bindings:[]}}}}function expressionOfKey(e,t){return t.reduce((e,t)=>"Identifier"===t.type?{type:"MemberExpression",object:e,property:(0,_astNodeMutationHelpers.shallowCloneNode)(t),computed:!1,optional:!1,...(0,_Builders.etc)()}:{type:"MemberExpression",object:e,property:(0,_astNodeMutationHelpers.shallowCloneNode)(t),computed:!0,optional:!1,...(0,_Builders.etc)()},(0,_astNodeMutationHelpers.deepCloneNode)(e))}function testsOfCondition(e,t){switch(t.type){case"eq":{const{key:n,arg:r}=t;return[{type:"BinaryExpression",left:expressionOfKey(e,n),right:r,operator:"===",...(0,_Builders.etc)()}]}case"is-nan":{const{key:n}=t,r={type:"MemberExpression",object:(0,_Builders.ident)("Number"),property:(0,_Builders.ident)("isNaN"),computed:!1,optional:!1,...(0,_Builders.etc)()};return[(0,_Builders.callExpression)(r,[expressionOfKey(e,n)])]}case"array":{const{key:n,length:r,lengthOp:i}=t,s="eq"===i?"===":">=";return[(0,_Builders.callExpression)({type:"MemberExpression",object:(0,_Builders.ident)("Array"),property:(0,_Builders.ident)("isArray"),computed:!1,optional:!1,...(0,_Builders.etc)()},[expressionOfKey(e,n)]),{type:"BinaryExpression",left:{type:"MemberExpression",object:expressionOfKey(e,n),property:(0,_Builders.ident)("length"),computed:!1,optional:!1,...(0,_Builders.etc)()},right:(0,_Builders.numberLiteral)(r),operator:s,...(0,_Builders.etc)()}]}case"object":{const{key:n}=t,r=(0,_Builders.typeofExpression)(expressionOfKey(e,n),"object"),i=(0,_Builders.typeofExpression)(expressionOfKey(e,n),"function"),s={type:"BinaryExpression",left:expressionOfKey(e,n),right:(0,_Builders.nullLiteral)(),operator:"!==",...(0,_Builders.etc)()};return[(0,_Builders.disjunction)([(0,_Builders.conjunction)([r,s]),i])]}case"prop-exists":{const{key:n,propName:r}=t;return[{type:"BinaryExpression",left:(0,_Builders.stringLiteral)(r),right:expressionOfKey(e,n),operator:"in",...(0,_Builders.etc)()}]}case"or":{const{orConditions:n}=t,r=n.map(t=>(0,_Builders.conjunction)(testsOfConditions(e,t)));return[(0,_Builders.disjunction)(r)]}}}function testsOfConditions(e,t){return t.flatMap(t=>testsOfCondition(e,t))}function statementsOfBindings(e,t){return t.map(t=>{switch(t.type){case"id":{const{key:n,kind:r,id:i}=t;return(0,_Builders.variableDeclaration)(r,i,expressionOfKey(e,n))}case"array-rest":{const{key:n,kind:r,id:i,exclude:s}=t,a=(0,_Builders.callExpression)({type:"MemberExpression",object:expressionOfKey(e,n),property:(0,_Builders.ident)("slice"),computed:!1,optional:!1,...(0,_Builders.etc)()},[(0,_Builders.numberLiteral)(s)]);return(0,_Builders.variableDeclaration)(r,i,a)}case"object-rest":{const{key:n,kind:r,id:i,exclude:s}=t,a={type:"ObjectPattern",properties:s.map(e=>"Identifier"===e.type?{type:"Property",key:(0,_astNodeMutationHelpers.shallowCloneNode)(e),value:genIdent(),kind:"init",computed:!1,method:!1,shorthand:!1,...(0,_Builders.etc)(),parent:_Builders.EMPTY_PARENT}:{type:"Property",key:(0,_astNodeMutationHelpers.shallowCloneNode)(e),value:genIdent(),kind:"init",computed:!0,method:!1,shorthand:!1,...(0,_Builders.etc)(),parent:_Builders.EMPTY_PARENT}).concat({type:"RestElement",argument:i,...(0,_Builders.etc)()}),typeAnnotation:null,...(0,_Builders.etc)()};return(0,_Builders.variableDeclaration)(r,a,expressionOfKey(e,n))}}})}const fallthroughErrorMsgText="Match: No case succesfully matched. Make exhaustive or add a wildcard case using '_'.";function fallthroughErrorMsg(e){return{type:"BinaryExpression",operator:"+",left:(0,_Builders.stringLiteral)(`${fallthroughErrorMsgText} Argument: `),right:e,...(0,_Builders.etc)()}}function fallthroughError(e){return(0,_Builders.throwStatement)(fallthroughErrorMsg(e))}function calculateSimpleArgument(e){switch(e.type){case"Identifier":case"Super":return!0;case"MemberExpression":{const{object:t,property:n,computed:r}=e;return(!r||"Literal"===n.type)&&calculateSimpleArgument(t)}default:return!1}}function analyzeCases(e){let t=!1,n=!1;const r=[];for(let i=0;i<e.length;i++){const{pattern:s,guard:a,body:o}=e[i],{conditions:c,bindings:l}=analyzePattern(s,[],new Set);if(t=t||l.length>0,r.push({conditions:c,bindings:l,guard:a,body:o}),0===c.length&&null==a){n=!0;break}}return{hasBindings:t,hasWildcard:n,analyses:r}}function mapMatchExpression(e){const{argument:t,cases:n}=e,{hasBindings:r,hasWildcard:i,analyses:s}=analyzeCases(n),a=!r&&calculateSimpleArgument(t),o=a?null:genIdent(),c=null==o?t:o;if(a){const e=i?s.pop():null,t=null!=e?e.body:(0,_Builders.iife)([fallthroughError((0,_astNodeMutationHelpers.shallowCloneNode)(c))]);return s.reverse().reduce((e,t)=>{const{conditions:n,guard:r,body:i}=t,s=testsOfConditions(c,n);return null!=r&&s.push(r),{type:"ConditionalExpression",test:(0,_Builders.conjunction)(s),consequent:i,alternate:e,...(0,_Builders.etc)()}},t)}const l=s.map(({conditions:e,bindings:t,guard:n,body:r})=>{const i={type:"ReturnStatement",argument:r,...(0,_Builders.etc)()},s=null==n?i:{type:"IfStatement",test:n,consequent:i,...(0,_Builders.etc)()},a=statementsOfBindings(c,t),o=a.concat(s);if(e.length>0){const t=testsOfConditions(c,e);return{type:"IfStatement",test:(0,_Builders.conjunction)(t),consequent:{type:"BlockStatement",body:o,...(0,_Builders.etc)()},...(0,_Builders.etc)()}}return a.length>0?{type:"BlockStatement",body:o,...(0,_Builders.etc)()}:s});i||l.push(fallthroughError((0,_astNodeMutationHelpers.shallowCloneNode)(c)));const[d,u]=null==o?[[],[]]:[[o],[t]];return(0,_Builders.iife)(l,d,u)}function mapMatchStatement(e){const{argument:t,cases:n}=e,{hasBindings:r,hasWildcard:i,analyses:s}=analyzeCases(n),a=genIdent(),o=!r&&calculateSimpleArgument(t)?null:genIdent(),c=null==o?t:o,l=[];return null!=o&&l.push((0,_Builders.variableDeclaration)("const",o,t)),s.forEach(({conditions:e,bindings:t,guard:n,body:r})=>{const i={type:"BreakStatement",label:(0,_astNodeMutationHelpers.shallowCloneNode)(a),...(0,_Builders.etc)()},s=r.body.concat(i),o=null==n?s:[{type:"IfStatement",test:n,consequent:{type:"BlockStatement",body:s,...(0,_Builders.etc)()},...(0,_Builders.etc)()}],d=statementsOfBindings(c,t).concat(o);if(e.length>0){const t=testsOfConditions(c,e);l.push({type:"IfStatement",test:(0,_Builders.conjunction)(t),consequent:{type:"BlockStatement",body:d,...(0,_Builders.etc)()},...(0,_Builders.etc)()})}else l.push({type:"BlockStatement",body:d,...(0,_Builders.etc)()})}),i||l.push(fallthroughError((0,_astNodeMutationHelpers.shallowCloneNode)(c))),{type:"LabeledStatement",label:a,body:{type:"BlockStatement",body:l,...(0,_Builders.etc)()},...(0,_Builders.etc)()}}function transformProgram(e,t){return GenID=(0,_GenID.createGenID)("m"),_SimpleTransform.SimpleTransform.transformProgram(e,{transform(e){switch(e.type){case"MatchExpression":return mapMatchExpression(e);case"MatchStatement":return mapMatchStatement(e);case"Identifier":if(null==GenID)throw Error("GenID must be initialized at the start of the transform.");return GenID.addUsage(e.name),e;default:return e}}})}