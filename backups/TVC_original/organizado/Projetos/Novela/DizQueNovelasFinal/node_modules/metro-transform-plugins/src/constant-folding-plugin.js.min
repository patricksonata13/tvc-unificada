"use strict";function constantFoldingPlugin(e){const n=e.types,{isLiteral:t,isVariableDeclarator:r,isUnaryExpression:i}=n,o=e.traverse,a=function(e){const n={safe:!0},r=(e,n)=>{n.safe=!1};if(i(e.node)&&"void"===e.node.operator)return t(e.node.argument)?{confident:!0,value:void 0}:{confident:!1,value:null};e.traverse({AssignmentExpression:r,CallExpression:r,OptionalCallExpression:r},n);try{if(!n.safe)return{confident:!1,value:null};const t=e.evaluate();return{confident:t.confident,value:t.value}}catch{return{confident:!1,value:null}}},s={exit(e,n){const t=null!=e.node.id&&e.scope.parent.getBinding(e.node.id.name);t&&!t.referenced&&(n.stripped=!0,e.remove())}},l={exit(e,n){const t=e.parentPath,i=t?.node;if(r(i)&&null!=i.id.name){const e=t?.scope.getBinding(i.id.name);e&&!e.referenced&&(n.stripped=!0,t?.remove())}}},c={exit(e,n){const t=e.node,r=a(e.get("test"));r.confident&&(n.stripped=!0,r.value||t.alternate?e.replaceWith(r.value?t.consequent:t.alternate):r.value||e.remove())}},p={exit(e){const t=a(e);t.confident&&(e.replaceWith(n.valueToNode(t.value)),e.skip())}},d={exit(e){const n=e.node,t=a(e.get("left"));if(t.confident){const r=t.value;switch(n.operator){case"||":e.replaceWith(r?n.left:n.right);break;case"&&":e.replaceWith(r?n.right:n.left);break;case"??":e.replaceWith(null==r?n.right:n.left)}}}},u={enter(e,n){n.stripped=!1},exit(e,n){e.traverse({ArrowFunctionExpression:l,ConditionalExpression:c,FunctionDeclaration:s,FunctionExpression:l,IfStatement:c},n),n.stripped&&(o.cache.clearScope(),e.scope.crawl(),u.enter(e,n),e.traverse(f,{stripped:!1}),u.exit(e,n))}},f={BinaryExpression:p,LogicalExpression:d,Program:{...u},UnaryExpression:p};return{visitor:f}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=constantFoldingPlugin;