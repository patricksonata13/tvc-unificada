"use strict";function _defineProperty(t,e,r){return(e=_toPropertyKey(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function _toPropertyKey(t){var e=_toPrimitive(t,"string");return"symbol"==typeof e?e:e+""}function _toPrimitive(t,e){if("object"!=typeof t||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var n=r.call(t,e||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}const{unwrapNullable:unwrapNullable,wrapNullable:wrapNullable}=require("../../../parsers/parsers-commons"),{capitalize:capitalize}=require("../../Utils");class StructCollector{constructor(){_defineProperty(this,"_structs",new Map)}process(t,e,r,n){const[a,i]=unwrapNullable(n);switch(a.type){case"ObjectTypeAnnotation":return this._insertStruct(t,e,r,a),wrapNullable(i,{type:"TypeAliasTypeAnnotation",name:t});case"ArrayTypeAnnotation":return"AnyTypeAnnotation"===a.elementType.type?wrapNullable(i,{type:"ArrayTypeAnnotation",elementType:{type:"AnyTypeAnnotation"}}):wrapNullable(i,{type:"ArrayTypeAnnotation",elementType:this.process(t+"Element",e,r,a.elementType)});case"TypeAliasTypeAnnotation":return this._insertAlias(a.name,e,r),wrapNullable(i,a);case"EnumDeclaration":return wrapNullable(i,a);case"MixedTypeAnnotation":throw new Error("Mixed types are unsupported in structs");case"UnionTypeAnnotation":switch(a.memberType){case"StringTypeAnnotation":return wrapNullable(i,{type:"StringTypeAnnotation"});case"NumberTypeAnnotation":return wrapNullable(i,{type:"NumberTypeAnnotation"});case"ObjectTypeAnnotation":return wrapNullable(i,{type:"GenericObjectTypeAnnotation"});default:throw a.memberType,new Error("Union types are unsupported in structs"+JSON.stringify(a))}default:return wrapNullable(i,a)}}_insertAlias(t,e,r){const n=this._structs.get(t);if(null==n)this._insertStruct(t,e,r,r(t));else if(n.context!==e)throw new Error(`Tried to use alias '${t}' in a getConstants() return type and inside a regular struct.`)}_insertStruct(t,e,r,n){const a=n.properties.map(n=>{const a=t+capitalize(n.name);return{...n,typeAnnotation:this.process(a,e,r,n.typeAnnotation)}});switch(e){case"REGULAR":this._structs.set(t,{name:t,context:"REGULAR",properties:a});break;case"CONSTANTS":this._structs.set(t,{name:t,context:"CONSTANTS",properties:a});break;default:throw new Error(`Detected an invalid struct context: ${e}`)}}getAllStructs(){return[...this._structs.values()]}getStruct(t){return this._structs.get(t)}}module.exports={StructCollector:StructCollector};