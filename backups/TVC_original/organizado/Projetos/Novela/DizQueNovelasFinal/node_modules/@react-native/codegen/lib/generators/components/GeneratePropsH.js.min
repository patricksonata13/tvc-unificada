"use strict";const{getEnumName:getEnumName,toSafeCppString:toSafeCppString}=require("../Utils"),{getLocalImports:getLocalImports,getNativeTypeFromAnnotation:getNativeTypeFromAnnotation}=require("./ComponentsGeneratorUtils.js"),{generateStructName:generateStructName,getDefaultInitializerString:getDefaultInitializerString,getEnumMaskName:getEnumMaskName,toIntEnumValueName:toIntEnumValueName}=require("./CppHelpers.js"),FileTemplate=({imports:n,componentClasses:e})=>`\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * @generated by codegen project: GeneratePropsH.js\n */\n#pragma once\n\n${n}\n\nnamespace facebook::react {\n\n${e}\n\n} // namespace facebook::react\n`,ClassTemplate=({enums:n,structs:e,className:t,props:o,extendClasses:a})=>`\n${n}\n${e}\nclass ${t} final${a} {\n public:\n  ${t}() = default;\n  ${t}(const PropsParserContext& context, const ${t} &sourceProps, const RawProps &rawProps);\n\n#pragma mark - Props\n\n  ${o}\n\n  #ifdef RN_SERIALIZABLE_STATE\n  ComponentName getDiffPropsImplementationTarget() const override;\n\n  folly::dynamic getDiffProps(const Props* prevProps) const override;\n  #endif\n};\n`.trim(),EnumTemplate=({enumName:n,values:e,fromCases:t,toCases:o})=>`\nenum class ${n} { ${e} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${n} &result) {\n  auto string = (std::string)value;\n  ${t}\n  abort();\n}\n\nstatic inline std::string toString(const ${n} &value) {\n  switch (value) {\n    ${o}\n  }\n}\n\n#ifdef RN_SERIALIZABLE_STATE\nstatic inline folly::dynamic toDynamic(const ${n} &value) {\n  return toString(value);\n}\n#endif\n`.trim(),IntEnumTemplate=({enumName:n,values:e,fromCases:t,toCases:o,toDynamicCases:a})=>`\nenum class ${n} { ${e} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${n} &result) {\n  assert(value.hasType<int>());\n  auto integerValue = (int)value;\n  switch (integerValue) {${t}\n  }\n  abort();\n}\n\nstatic inline std::string toString(const ${n} &value) {\n  switch (value) {\n    ${o}\n  }\n}\n\n#ifdef RN_SERIALIZABLE_STATE\nstatic inline folly::dynamic toDynamic(const ${n} &value) {\n  switch (value) {\n    ${a}\n  }\n}\n#endif\n`.trim(),StructTemplate=({structName:n,fields:e,fromCases:t,toDynamicCases:o})=>`struct ${n} {\n  ${e}\n\n#ifdef RN_SERIALIZABLE_STATE\n  bool operator==(const ${n}&) const = default;\n\n  folly::dynamic toDynamic() const {\n    folly::dynamic result = folly::dynamic::object();\n    ${o}\n    return result;\n  }\n#endif\n};\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${n} &result) {\n  auto map = (std::unordered_map<std::string, RawValue>)value;\n\n  ${t}\n}\n\nstatic inline std::string toString(const ${n} &value) {\n  return "[Object ${n}]";\n}\n\n#ifdef RN_SERIALIZABLE_STATE\nstatic inline folly::dynamic toDynamic(const ${n} &value) {\n  return value.toDynamic();\n}\n#endif\n`.trim(),ArrayConversionFunctionTemplate=({structName:n})=>`static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<${n}> &result) {\n  auto items = (std::vector<RawValue>)value;\n  for (const auto &item : items) {\n    ${n} newItem;\n    fromRawValue(context, item, newItem);\n    result.emplace_back(newItem);\n  }\n}\n`,DoubleArrayConversionFunctionTemplate=({structName:n})=>`static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<${n}>> &result) {\n  auto items = (std::vector<std::vector<RawValue>>)value;\n  for (const std::vector<RawValue> &item : items) {\n    auto nestedArray = std::vector<${n}>{};\n    for (const RawValue &nestedItem : item) {\n      ${n} newItem;\n      fromRawValue(context, nestedItem, newItem);\n      nestedArray.emplace_back(newItem);\n    }\n    result.emplace_back(nestedArray);\n  }\n}\n`,ArrayEnumTemplate=({enumName:n,enumMask:e,values:t,fromCases:o,toCases:a})=>`\nusing ${e} = uint32_t;\n\nstruct ${e}Wrapped {\n  ${e} value;\n};\n\nenum class ${n}: ${e} {\n  ${t}\n};\n\nconstexpr bool operator&(\n  ${e} const lhs,\n  enum ${n} const rhs) {\n  return lhs & static_cast<${e}>(rhs);\n}\n\nconstexpr ${e} operator|(\n  ${e} const lhs,\n  enum ${n} const rhs) {\n  return lhs | static_cast<${e}>(rhs);\n}\n\nconstexpr void operator|=(\n  ${e} &lhs,\n  enum ${n} const rhs) {\n  lhs = lhs | static_cast<${e}>(rhs);\n}\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${e}Wrapped &wrapped) {\n  auto items = std::vector<std::string>{value};\n  for (const auto &item : items) {\n    ${o}\n    abort();\n  }\n}\n\nstatic inline std::string toString(const ${e}Wrapped &wrapped) {\n    auto result = std::string{};\n    auto separator = std::string{", "};\n\n    ${a}\n    if (!result.empty()) {\n      result.erase(result.length() - separator.length());\n    }\n    return result;\n}\n`.trim();function getClassExtendString(n){if(0===n.extendsProps.length)throw new Error("Invalid: component.extendsProps is empty");return" : "+n.extendsProps.map(n=>{if("ReactNativeBuiltInType"===n.type){if("ReactNativeCoreViewProps"===n.knownTypeName)return"public ViewProps";throw n.knownTypeName,new Error("Invalid knownTypeName")}throw n.type,new Error("Invalid extended type")}).join(" ")}function convertValueToEnumOption(n){return toSafeCppString(n)}function generateArrayEnumString(n,e,t){const o=getEnumName(n,e),a=t.map((n,e)=>`${toSafeCppString(n)} = 1 << ${e}`).join(",\n  "),r=t.map(n=>`if (item == "${n}") {\n      wrapped.value |= ${o}::${toSafeCppString(n)};\n      continue;\n    }`).join("\n    "),s=t.map(n=>`if (wrapped.value & ${o}::${toSafeCppString(n)}) {\n      result += "${n}" + separator;\n    }`).join("\n    ");return ArrayEnumTemplate({enumName:o,enumMask:getEnumMaskName(o),values:a,fromCases:r,toCases:s})}function generateStringEnum(n,e){const t=e.typeAnnotation;if("StringEnumTypeAnnotation"===t.type){const o=t.options,a=getEnumName(n,e.name),r=o.map(n=>`if (string == "${n}") { result = ${a}::${convertValueToEnumOption(n)}; return; }`).join("\n  "),s=o.map(n=>`case ${a}::${convertValueToEnumOption(n)}: return "${n}";`).join("\n    ");return EnumTemplate({enumName:a,values:o.map(toSafeCppString).join(", "),fromCases:r,toCases:s})}return""}function generateIntEnum(n,e){const t=e.typeAnnotation;if("Int32EnumTypeAnnotation"===t.type){const o=t.options,a=getEnumName(n,e.name),r=o.map(n=>`\n    case ${n}:\n      result = ${a}::${toIntEnumValueName(e.name,n)};\n      return;`).join(""),s=o.map(n=>`case ${a}::${toIntEnumValueName(e.name,n)}: return "${n}";`).join("\n    "),i=o.map(n=>`case ${a}::${toIntEnumValueName(e.name,n)}: return ${n};`).join("\n    "),c=o.map(n=>`${toIntEnumValueName(e.name,n)} = ${n}`).join(", ");return IntEnumTemplate({enumName:a,values:c,fromCases:r,toCases:s,toDynamicCases:i})}return""}function generateEnumString(n,e){return e.props.map(e=>"ArrayTypeAnnotation"===e.typeAnnotation.type&&"StringEnumTypeAnnotation"===e.typeAnnotation.elementType.type?generateArrayEnumString(n,e.name,e.typeAnnotation.elementType.options):"StringEnumTypeAnnotation"===e.typeAnnotation.type?generateStringEnum(n,e):"Int32EnumTypeAnnotation"===e.typeAnnotation.type?generateIntEnum(n,e):"ObjectTypeAnnotation"===e.typeAnnotation.type?e.typeAnnotation.properties.map(e=>"StringEnumTypeAnnotation"===e.typeAnnotation.type?generateStringEnum(n,e):"Int32EnumTypeAnnotation"===e.typeAnnotation.type?generateIntEnum(n,e):null).filter(Boolean).join("\n"):void 0).filter(Boolean).join("\n")}function generatePropsString(n,e,t){return e.map(e=>{const o=getNativeTypeFromAnnotation(n,e,t),a=getDefaultInitializerString(n,e);return`${o} ${e.name}${a};`}).join("\n  ")}function getExtendsImports(n){const e=new Set;return e.add("#include <react/renderer/core/PropsParserContext.h>"),n.forEach(n=>{if("ReactNativeBuiltInType"===n.type){if("ReactNativeCoreViewProps"===n.knownTypeName)return void e.add("#include <react/renderer/components/view/ViewProps.h>");throw n.knownTypeName,new Error("Invalid knownTypeName")}throw n.type,new Error("Invalid extended type")}),e}function generateStructsForComponent(n,e){const t=generateStructs(n,e.props,[]),o=Array.from(t.values());return o.length<1?"":o.join("\n\n")}function generateStructs(n,e,t){const o=new Map;return e.forEach(e=>{const a=e.typeAnnotation;if("ObjectTypeAnnotation"===a.type){const r=a.properties;generateStructs(n,r,t.concat([e.name])).forEach(function(n,e){o.set(e,n)}),generateStruct(o,n,t.concat([e.name]),a.properties)}if("ArrayTypeAnnotation"===e.typeAnnotation.type&&"ObjectTypeAnnotation"===e.typeAnnotation.elementType.type){const a=e.typeAnnotation.elementType.properties;generateStructs(n,a,t.concat([e.name])).forEach(function(n,e){o.set(e,n)}),generateStruct(o,n,t.concat([e.name]),a),o.set(`${[n,...t.concat([e.name])].join("")}ArrayStruct`,ArrayConversionFunctionTemplate({structName:generateStructName(n,t.concat([e.name]))}))}if("ArrayTypeAnnotation"===e.typeAnnotation.type&&"ArrayTypeAnnotation"===e.typeAnnotation.elementType.type&&"ObjectTypeAnnotation"===e.typeAnnotation.elementType.elementType.type){const a=e.typeAnnotation.elementType.elementType.properties;generateStructs(n,a,t.concat([e.name])).forEach(function(n,e){o.set(e,n)}),generateStruct(o,n,t.concat([e.name]),a),o.set(`${[n,...t.concat([e.name])].join("")}ArrayArrayStruct`,DoubleArrayConversionFunctionTemplate({structName:generateStructName(n,t.concat([e.name]))}))}}),o}function generateStruct(n,e,t,o){const a=t,r=generateStructName(e,a),s=generatePropsString(e,o,a);o.forEach(o=>{const a=o.name;switch(o.typeAnnotation.type){case"BooleanTypeAnnotation":case"StringTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":case"ReservedPropTypeAnnotation":case"ArrayTypeAnnotation":case"StringEnumTypeAnnotation":case"Int32EnumTypeAnnotation":case"MixedTypeAnnotation":return;case"ObjectTypeAnnotation":const r=o.typeAnnotation.properties;if(null==r)throw new Error(`Properties are expected for ObjectTypeAnnotation (see ${a} in ${e})`);return void generateStruct(n,e,t.concat([a]),r);default:throw o.typeAnnotation.type,new Error(`Received invalid component property type ${o.typeAnnotation.type}`)}});const i=o.map(n=>{const e="tmp_"+n.name;return`auto ${e} = map.find("${n.name}");\n  if (${e} != map.end()) {\n    fromRawValue(context, ${e}->second, result.${n.name});\n  }`}).join("\n  "),c=o.map(n=>{const e=n.name;switch(n.typeAnnotation.type){case"BooleanTypeAnnotation":case"StringTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":case"MixedTypeAnnotation":return`result["${e}"] = ${e};`;default:return`result["${e}"] = ::facebook::react::toDynamic(${e});`}}).join("\n    ");n.set(r,StructTemplate({structName:r,fields:s,fromCases:i,toDynamicCases:c}))}module.exports={generate(n,e,t,o=!1,a){const r=new Set,s=Object.keys(e.modules).map(n=>{const t=e.modules[n];if("Component"!==t.type)return;const{components:o}=t;return null==o?null:Object.keys(o).map(n=>{const e=o[n],t=`${n}Props`,a=generateStructsForComponent(n,e),s=generateEnumString(n,e),i=generatePropsString(n,e.props,[]),c=getClassExtendString(e),p=getExtendsImports(e.extendsProps),u=getLocalImports(e.props);p.forEach(r.add,r),u.forEach(r.add,r);return ClassTemplate({enums:s,structs:a,className:t,extendClasses:c,props:i})}).join("\n\n")}).filter(Boolean).join("\n\n"),i=FileTemplate({componentClasses:s,imports:Array.from(r).sort().join("\n")});return new Map([["Props.h",i]])}};