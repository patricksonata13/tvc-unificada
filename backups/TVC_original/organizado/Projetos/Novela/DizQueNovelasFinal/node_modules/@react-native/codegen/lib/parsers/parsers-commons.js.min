"use strict";const{throwIfConfigNotfound:throwIfConfigNotfound,throwIfEventEmitterEventTypeIsUnsupported:throwIfEventEmitterEventTypeIsUnsupported,throwIfEventEmitterTypeIsUnsupported:throwIfEventEmitterTypeIsUnsupported,throwIfIncorrectModuleRegistryCallArgument:throwIfIncorrectModuleRegistryCallArgument,throwIfIncorrectModuleRegistryCallTypeParameterParserError:throwIfIncorrectModuleRegistryCallTypeParameterParserError,throwIfModuleInterfaceIsMisnamed:throwIfModuleInterfaceIsMisnamed,throwIfModuleInterfaceNotFound:throwIfModuleInterfaceNotFound,throwIfModuleTypeIsUnsupported:throwIfModuleTypeIsUnsupported,throwIfMoreThanOneCodegenNativecommands:throwIfMoreThanOneCodegenNativecommands,throwIfMoreThanOneConfig:throwIfMoreThanOneConfig,throwIfMoreThanOneModuleInterfaceParserError:throwIfMoreThanOneModuleInterfaceParserError,throwIfMoreThanOneModuleRegistryCalls:throwIfMoreThanOneModuleRegistryCalls,throwIfPropertyValueTypeIsUnsupported:throwIfPropertyValueTypeIsUnsupported,throwIfTypeAliasIsNotInterface:throwIfTypeAliasIsNotInterface,throwIfUnsupportedFunctionParamTypeAnnotationParserError:throwIfUnsupportedFunctionParamTypeAnnotationParserError,throwIfUnsupportedFunctionReturnTypeAnnotationParserError:throwIfUnsupportedFunctionReturnTypeAnnotationParserError,throwIfUntypedModule:throwIfUntypedModule,throwIfUnusedModuleInterfaceParserError:throwIfUnusedModuleInterfaceParserError,throwIfWrongNumberOfCallExpressionArgs:throwIfWrongNumberOfCallExpressionArgs}=require("./error-utils"),{MissingTypeParameterGenericParserError:MissingTypeParameterGenericParserError,MoreThanOneTypeParameterGenericParserError:MoreThanOneTypeParameterGenericParserError,UnnamedFunctionParamParserError:UnnamedFunctionParamParserError,UnsupportedObjectDirectRecursivePropertyParserError:UnsupportedObjectDirectRecursivePropertyParserError}=require("./errors"),{createParserErrorCapturer:createParserErrorCapturer,extractNativeModuleName:extractNativeModuleName,getConfigType:getConfigType,getSortedObject:getSortedObject,isModuleRegistryCall:isModuleRegistryCall,verifyPlatforms:verifyPlatforms,visit:visit}=require("./utils"),invariant=require("invariant");function wrapModuleSchema(e,t){return{modules:{[t]:e}}}function unwrapNullable(e){return"NullableTypeAnnotation"===e.type?[e.typeAnnotation,!0]:[e,!1]}function wrapNullable(e,t){return e?{type:"NullableTypeAnnotation",typeAnnotation:t}:t}function assertGenericTypeAnnotationHasExactlyOneTypeParameter(e,t,n){if(null==t.typeParameters)throw new MissingTypeParameterGenericParserError(e,t,n);const r=n.typeParameterInstantiation;if(invariant(t.typeParameters.type===r,`assertGenericTypeAnnotationHasExactlyOneTypeParameter: Type parameters must be an AST node of type '${r}'`),1!==t.typeParameters.params.length)throw new MoreThanOneTypeParameterGenericParserError(e,t,n)}function isObjectProperty(e,t){switch(t){case"Flow":return"ObjectTypeProperty"===e.type;case"TypeScript":return"TSPropertySignature"===e.type;default:return!1}}function getObjectTypeAnnotations(e,t,n,r,o){const a={};return Object.entries(t).forEach(([p,i])=>{if(!("TypeAlias"===i.type||"TSTypeAliasDeclaration"===i.type))return;const s=o.nextNodeForTypeAlias(i);if("ObjectTypeAnnotation"!==s.type&&"TSTypeLiteral"!==s.type)return;const l=o.getAnnotatedElementProperties(i).map(p=>parseObjectProperty(s,p,e,t,a,{},n,!0,(null==p?void 0:p.optional)||!1,r,o));a[p]={type:"ObjectTypeAnnotation",properties:l}}),a}function parseObjectProperty(e,t,n,r,o,a,p,i,s,l,u){const m=u.language(),c=u.getKeyName(t,n),{optional:y=!1}=t,d="TypeScript"===m?t.typeAnnotation.typeAnnotation:t.value;if(e){var f,h;const t=u.getResolveTypeAnnotationFN()(d,r,u);if(!0===t.typeResolutionStatus.successful&&"alias"===t.typeResolutionStatus.type&&("TypeScript"===m?e.typeName&&e.typeName.name===(null===(f=d.typeName)||void 0===f?void 0:f.name):e.id&&e.id.name===(null===(h=d.id)||void 0===h?void 0:h.name))){if(!y)throw new UnsupportedObjectDirectRecursivePropertyParserError(c,d,n);return{name:c,optional:y,typeAnnotation:{type:"TypeAliasTypeAnnotation",name:t.typeResolutionStatus.name}}}}const[g,T]=unwrapNullable(l(n,d,r,o,a,p,i,u));return("FunctionTypeAnnotation"===g.type&&!i||"PromiseTypeAnnotation"===g.type||"VoidTypeAnnotation"===g.type)&&throwIfPropertyValueTypeIsUnsupported(n,d,t.key,g.type),{name:c,optional:y,typeAnnotation:wrapNullable(T,g)}}function translateFunctionTypeAnnotation(e,t,n,r,o,a,p,i,s){const l=[];for(const u of s.getFunctionTypeAnnotationParameters(t)){const t=a(()=>{if(null==s.getFunctionNameFromParameter(u))throw new UnnamedFunctionParamParserError(u,e);const t=s.getParameterName(u),[l,m]=unwrapNullable(i(e,s.getParameterTypeAnnotation(u),n,r,o,a,p,s));return"VoidTypeAnnotation"===l.type||"PromiseTypeAnnotation"===l.type?throwIfUnsupportedFunctionParamTypeAnnotationParserError(e,u.typeAnnotation,t,l.type):{name:t,optional:Boolean(u.optional),typeAnnotation:wrapNullable(m,l)}});null!=t&&l.push(t)}const[u,m]=unwrapNullable(i(e,s.getFunctionTypeAnnotationReturnType(t),n,r,o,a,p,s));return throwIfUnsupportedFunctionReturnTypeAnnotationParserError(e,t,"FunctionTypeAnnotation",p,u.type),{type:"FunctionTypeAnnotation",returnTypeAnnotation:wrapNullable(m,u),params:l}}function buildPropertySchema(e,t,n,r,o,a,p,i,s){let l=!1,{key:u,value:m}=t;const c=u.name;"TypeScript"===s.language()&&(m="TSMethodSignature"===t.type?t:t.typeAnnotation);const y=s.getResolveTypeAnnotationFN();return({nullable:l,typeAnnotation:m}=y(m,n,s)),throwIfModuleTypeIsUnsupported(e,t.value,u.name,m.type,s),{name:c,optional:Boolean(t.optional),typeAnnotation:wrapNullable(l,translateFunctionTypeAnnotation(e,m,n,r,o,a,p,i,s))}}function buildEventEmitterSchema(e,t,n,r,o,a,p,i,s){const{key:l}=t,u="TypeScript"===s.language()?t.typeAnnotation.typeAnnotation:t.value,m=l.name,c=s.getResolveTypeAnnotationFN(),[y,d]=unwrapNullable(u),f=1===u.typeParameters.params.length&&"TypeScript"===s.language()?"TSTypeLiteral"===u.typeParameters.params[0].type&&0===u.typeParameters.params[0].members.length:"ObjectTypeAnnotation"===u.typeParameters.params[0].type&&0===u.typeParameters.params[0].properties.length;throwIfEventEmitterTypeIsUnsupported(e,l.name,y.type,s,d,f);const h=c(y.typeParameters.params[0],n,s);throwIfEventEmitterEventTypeIsUnsupported(e,l.name,h.typeAnnotation,s,h.nullable);return{name:m,optional:!1,typeAnnotation:{type:"EventEmitterTypeAnnotation",typeAnnotation:i(e,y.typeParameters.params[0],n,r,o,a,p,s)}}}function buildSchemaFromConfigType(e,t,n,r,o,a,p,i){switch(e){case"component":return r(o(n,p));case"module":{if(null==t)throw new Error("Filepath expected while parasing a module");const e=extractNativeModuleName(t),[r,o]=createParserErrorCapturer(),s=o(()=>a(e,n,o,p,i));if(r.length>0)throw r[0];return invariant(null!=s,"When there are no parsing errors, the schema should not be null"),wrapModuleSchema(s,e)}default:return{modules:{}}}}function buildSchema(e,t,n,r,o,a,p,i){if(!e.includes("codegenNativeComponent")&&!e.includes("TurboModule"))return{modules:{}};const s=p.getAst(e,t);return buildSchemaFromConfigType(getConfigType(s,a),t,s,n,r,o,p,i)}function createComponentConfig(e,t){return{...e,commandTypeName:null==t[0]?null:t[0].commandTypeName,commandOptionsExpression:null==t[0]?null:t[0].commandOptionsExpression}}const parseModuleName=(e,t,n,r)=>{const o=[];visit(n,{CallExpression(e){isModuleRegistryCall(e)&&o.push(e)}}),throwIfUnusedModuleInterfaceParserError(e,t,o),throwIfMoreThanOneModuleRegistryCalls(e,o,o.length);const[a]=o,p=r.callExpressionTypeParameters(a),i=a.callee.property.name;throwIfWrongNumberOfCallExpressionArgs(e,a,i,a.arguments.length),throwIfIncorrectModuleRegistryCallArgument(e,a.arguments[0],i);const s=a.arguments[0].value;return throwIfUntypedModule(p,e,a,i,s),throwIfIncorrectModuleRegistryCallTypeParameterParserError(e,p,i,s,r),s},buildModuleSchema=(e,t,n,r,o)=>{const a=r.language(),p=r.getTypes(t),i=Object.values(p).filter(e=>r.isModuleInterface(e));throwIfModuleInterfaceNotFound(i.length,e,t,a),throwIfMoreThanOneModuleInterfaceParserError(e,i,a);const[s]=i;throwIfModuleInterfaceIsMisnamed(e,s.id,a);const l=parseModuleName(e,s,t,r),{cxxOnly:u,excludedPlatforms:m}=verifyPlatforms(e,l),c=u?getObjectTypeAnnotations(e,p,n,o,r):{},y=("Flow"===a?s.body.properties:s.body.body).filter(e=>"ObjectTypeProperty"===e.type||"TSPropertySignature"===e.type||"TSMethodSignature"===e.type).map(t=>{var i,s;const l={},m="TypeScript"===a?"TSPropertySignature"===(null==t?void 0:t.type)&&"EventEmitter"===r.getTypeAnnotationName(null==t||null===(i=t.typeAnnotation)||void 0===i?void 0:i.typeAnnotation):"GenericTypeAnnotation"===(null==t||null===(s=t.value)||void 0===s?void 0:s.type)&&"EventEmitter"===r.getTypeAnnotationName(null==t?void 0:t.value);return n(()=>({aliasMap:c,enumMap:l,propertyShape:m?{type:"eventEmitter",value:buildEventEmitterSchema(e,t,p,c,l,n,u,o,r)}:{type:"method",value:buildPropertySchema(e,t,p,c,l,n,u,o,r)}}))}).filter(Boolean).reduce((e,{enumMap:t,propertyShape:n})=>({type:"NativeModule",aliasMap:{...e.aliasMap,...c},enumMap:{...e.enumMap,...t},spec:{eventEmitters:[...e.spec.eventEmitters].concat("eventEmitter"===n.type?[n.value]:[]),methods:[...e.spec.methods].concat("method"===n.type?[n.value]:[])},moduleName:e.moduleName,excludedPlatforms:e.excludedPlatforms}),{type:"NativeModule",aliasMap:{},enumMap:{},spec:{eventEmitters:[],methods:[]},moduleName:l,excludedPlatforms:0!==m.length?[...m]:void 0});return{type:"NativeModule",aliasMap:getSortedObject(y.aliasMap),enumMap:getSortedObject(y.enumMap),spec:{eventEmitters:y.spec.eventEmitters.sort(),methods:y.spec.methods.sort()},moduleName:l,excludedPlatforms:y.excludedPlatforms}};function findNativeComponentType(e,t,n){let r=e.declaration;"TSAsExpression"!==r.type&&"AsExpression"!==r.type&&"TypeCastExpression"!==r.type||(r=r.expression);try{if("codegenNativeComponent"===r.callee.name){const e=n.getTypeArgumentParamsFromDeclaration(r),o=r.arguments,a=n.getNativeComponentType(e,o);o.length>1&&(a.optionsExpression=o[1]),t.push(a)}}catch(e){}}function getCommandOptions(e){if(null==e)return null;let t;try{t=e.properties.reduce((e,t)=>(e[t.key.name]=(t&&t.value&&t.value.elements||[]).map(e=>e&&e.value),e),{})}catch(e){throw new Error("Failed to parse command options, please check that they are defined correctly")}return t}function getOptions(e){if(!e)return null;let t;try{t=e.properties.reduce((e,t)=>("ArrayExpression"===t.value.type?e[t.key.name]=t.value.elements.map(e=>e.value):e[t.key.name]=t.value.value,e),{})}catch(e){throw new Error("Failed to parse codegen options, please check that they are defined correctly")}if(t.paperComponentName&&t.paperComponentNameDeprecated)throw new Error("Failed to parse codegen options, cannot use both paperComponentName and paperComponentNameDeprecated");return t}function getCommandTypeNameAndOptionsExpression(e,t){let n,r;try{n=e.declaration.declarations[0].init,r=n.callee.name}catch(e){return}if("codegenNativeCommands"!==r)return;if(1!==n.arguments.length)throw new Error("codegenNativeCommands must be passed options including the supported commands");const o=t.getTypeArgumentParamsFromDeclaration(n)[0];if(!t.isGenericTypeAnnotation(o.type))throw new Error("codegenNativeCommands doesn't support inline definitions. Specify a file local type alias");return{commandTypeName:t.getTypeAnnotationName(o),commandOptionsExpression:n.arguments[0]}}function propertyNames(e){return e.map(e=>e&&e.key&&e.key.name).filter(Boolean)}function extendsForProp(e,t,n){n.argumentForProp(e)||console.log("null",e);const r=n.nameForArgument(e);if(null!=t[r])return null;if("ViewProps"===r)return{type:"ReactNativeBuiltInType",knownTypeName:"ReactNativeCoreViewProps"};throw new Error(`Unable to handle prop spread: ${r}`)}function buildPropSchema(e,t,n){const r=n.getGetSchemaInfoFN()(e,t,n);if(null==r)return null;const{name:o,optional:a,typeAnnotation:p,defaultValue:i,withNullDefault:s}=r;return{name:o,optional:a,typeAnnotation:n.getGetTypeAnnotationFN()(o,p,i,s,t,n,buildPropSchema)}}function getEventArgument(e,t,n){return{type:"ObjectTypeAnnotation",properties:e.map(e=>buildPropertiesForEvent(e,t,n))}}function findComponentConfig(e,t){const n=[];e.body.filter(e=>"ExportDefaultDeclaration"===e.type).forEach(e=>{findNativeComponentType(e,n,t)}),throwIfConfigNotfound(n),throwIfMoreThanOneConfig(n);const r=n[0],o=e.body.filter(e=>"ExportNamedDeclaration"===e.type).map(e=>getCommandTypeNameAndOptionsExpression(e,t)).filter(Boolean);return throwIfMoreThanOneCodegenNativecommands(o),createComponentConfig(r,o)}function getCommandProperties(e,t){const{commandTypeName:n,commandOptionsExpression:r}=findComponentConfig(e,t);if(null==n)return[];const o=t.getTypes(e)[n];throwIfTypeAliasIsNotInterface(o,t);const a=t.bodyProperties(o);if(!a)throw new Error(`Failed to find type definition for "${n}", please check that you have a valid codegen file`);const p=propertyNames(a),i=getCommandOptions(r);if(null==i||null==i.supportedCommands)throw new Error("codegenNativeCommands must be given an options object with supportedCommands array");if(i.supportedCommands.length!==p.length||!i.supportedCommands.every(e=>p.includes(e)))throw new Error(`codegenNativeCommands expected the same supportedCommands specified in the ${n} interface: ${p.join(", ")}`);return a}function getTypeResolutionStatus(e,t,n){return{successful:!0,type:e,name:n.getTypeAnnotationName(t)}}function handleGenericTypeAnnotation(e,t,n){let r,o;switch(t.type){case n.typeAlias:case"OpaqueType":r=getTypeResolutionStatus("alias",e,n),o=n.nextNodeForTypeAlias(t);break;case n.enumDeclaration:r=getTypeResolutionStatus("enum",e,n),o=n.nextNodeForEnum(t);break;case"TSInterfaceDeclaration":r=getTypeResolutionStatus("alias",e,n),o=t;break;default:throw new TypeError(n.genericTypeAnnotationErrorMessage(t))}return{typeAnnotation:o,typeResolutionStatus:r}}function buildPropertiesForEvent(e,t,n){return n(e.key.name,t.isOptionalProperty(e),t.getTypeAnnotationFromProperty(e),t)}function verifyPropNotAlreadyDefined(e,t){const n=t.key.name;if(e.some(e=>e.key.name===n))throw new Error(`A prop was already defined with the name ${n}`)}function handleEventHandler(e,t,n,r,o){const a="BubblingEventHandler"===e?"bubble":"direct",p=n.getPaperTopLevelNameDeprecated(t);switch(t.typeParameters.params[0].type){case n.nullLiteralTypeAnnotation:case n.undefinedLiteralTypeAnnotation:return{argumentProps:[],bubblingType:a,paperTopLevelNameDeprecated:p};default:return o(n,t.typeParameters.params[0],r,a,p)}}function emitBuildEventSchema(e,t,n,r,o){return null!=e?{name:t,optional:n,bubblingType:r,paperTopLevelNameDeprecated:e,typeAnnotation:{type:"EventTypeAnnotation",argument:o}}:{name:t,optional:n,bubblingType:r,typeAnnotation:{type:"EventTypeAnnotation",argument:o}}}module.exports={wrapModuleSchema:wrapModuleSchema,unwrapNullable:unwrapNullable,wrapNullable:wrapNullable,assertGenericTypeAnnotationHasExactlyOneTypeParameter:assertGenericTypeAnnotationHasExactlyOneTypeParameter,isObjectProperty:isObjectProperty,parseObjectProperty:parseObjectProperty,translateFunctionTypeAnnotation:translateFunctionTypeAnnotation,buildPropertySchema:buildPropertySchema,buildSchemaFromConfigType:buildSchemaFromConfigType,buildSchema:buildSchema,createComponentConfig:createComponentConfig,parseModuleName:parseModuleName,buildModuleSchema:buildModuleSchema,findNativeComponentType:findNativeComponentType,propertyNames:propertyNames,getCommandOptions:getCommandOptions,getOptions:getOptions,getCommandTypeNameAndOptionsExpression:getCommandTypeNameAndOptionsExpression,extendsForProp:extendsForProp,buildPropSchema:buildPropSchema,getEventArgument:getEventArgument,findComponentConfig:findComponentConfig,getCommandProperties:getCommandProperties,handleGenericTypeAnnotation:handleGenericTypeAnnotation,getTypeResolutionStatus:getTypeResolutionStatus,buildPropertiesForEvent:buildPropertiesForEvent,verifyPropNotAlreadyDefined:verifyPropNotAlreadyDefined,handleEventHandler:handleEventHandler,emitBuildEventSchema:emitBuildEventSchema};