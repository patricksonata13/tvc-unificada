"use strict";const{unwrapNullable:unwrapNullable}=require("../../../../parsers/parsers-commons"),{wrapOptional:wrapCxxOptional}=require("../../../TypeUtils/Cxx"),{wrapOptional:wrapObjCOptional}=require("../../../TypeUtils/Objective-C"),{capitalize:capitalize}=require("../../../Utils"),{getNamespacedStructName:getNamespacedStructName,getSafePropertyName:getSafePropertyName}=require("../Utils"),StructTemplate=({hasteModuleName:e,structName:t,builderInputProps:n})=>`namespace JS {\n  namespace ${e} {\n    struct ${t} {\n\n      struct Builder {\n        struct Input {\n          ${n}\n        };\n\n        /** Initialize with a set of values */\n        Builder(const Input i);\n        /** Initialize with an existing ${t} */\n        Builder(${t} i);\n        /** Builds the object. Generally used only by the infrastructure. */\n        NSDictionary *buildUnsafeRawValue() const { return _factory(); };\n      private:\n        NSDictionary *(^_factory)(void);\n      };\n\n      static ${t} fromUnsafeRawValue(NSDictionary *const v) { return {v}; }\n      NSDictionary *unsafeRawValue() const { return _v; }\n    private:\n      ${t}(NSDictionary *const v) : _v(v) {}\n      NSDictionary *_v;\n    };\n  }\n}`,MethodTemplate=({hasteModuleName:e,structName:t,properties:n})=>`inline JS::${e}::${t}::Builder::Builder(const Input i) : _factory(^{\n  NSMutableDictionary *d = [NSMutableDictionary new];\n${n}\n  return d;\n}) {}\ninline JS::${e}::${t}::Builder::Builder(${t} i) : _factory(^{\n  return i.unsafeRawValue();\n}) {}`;function toObjCType(e,t,n=!1){const[a,r]=unwrapNullable(t),o=!r&&!n;switch(a.type){case"ReservedTypeAnnotation":if("RootTag"===a.name)return wrapCxxOptional("double",o);throw a.name,new Error(`Unknown prop type, found: ${a.name}"`);case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return"NSString *";case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":case"FloatTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":return wrapCxxOptional("double",o);case"BooleanTypeAnnotation":return wrapCxxOptional("bool",o);case"EnumDeclaration":switch(a.memberType){case"NumberTypeAnnotation":return wrapCxxOptional("double",o);case"StringTypeAnnotation":return"NSString *";default:throw new Error(`Couldn't convert enum into ObjC type: ${a.type}"`)}case"GenericObjectTypeAnnotation":return wrapObjCOptional("id<NSObject>",o);case"ArrayTypeAnnotation":return"AnyTypeAnnotation"===a.elementType.type?wrapObjCOptional("id<NSObject>",o):wrapCxxOptional(`std::vector<${toObjCType(e,a.elementType)}>`,o);case"TypeAliasTypeAnnotation":const t=capitalize(a.name),n=getNamespacedStructName(e,t);return wrapCxxOptional(`${n}::Builder`,o);default:throw a.type,new Error(`Couldn't convert into ObjC type: ${a.type}"`)}}function toObjCValue(e,t,n,a,r=!1){const[o,i]=unwrapNullable(t),u=!i&&!r;function p(e){return u?`@(${n})`:`${n}.has_value() ? @((${e})${n}.value()) : nil`}switch(o.type){case"ReservedTypeAnnotation":if("RootTag"===o.name)return p("double");throw o.name,new Error(`Couldn't convert into ObjC type: ${o.type}"`);case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return n;case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":case"FloatTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":return p("double");case"BooleanTypeAnnotation":return p("BOOL");case"EnumDeclaration":switch(o.memberType){case"NumberTypeAnnotation":return p("double");case"StringTypeAnnotation":return n;default:throw new Error(`Couldn't convert enum into ObjC value: ${o.type}"`)}case"GenericObjectTypeAnnotation":return n;case"ArrayTypeAnnotation":const{elementType:t}=o;if("AnyTypeAnnotation"===t.type)return n;const r=`el${"_".repeat(a+1)}`;return(e=>`RCTConvert${u?"":"Optional"}VecToArray(${n}, ${e})`)(`^id(${toObjCType(e,t)} ${r}) { return ${toObjCValue(e,t,r,a+1)}; }`);case"TypeAliasTypeAnnotation":return u?`${n}.buildUnsafeRawValue()`:`${n}.has_value() ? ${n}.value().buildUnsafeRawValue() : nil`;default:throw o.type,new Error(`Couldn't convert into ObjC value: ${o.type}"`)}}function serializeConstantsStruct(e,t){return{declaration:StructTemplate({hasteModuleName:e,structName:t.name,builderInputProps:t.properties.map(t=>{const{typeAnnotation:n,optional:a}=t,r=getSafePropertyName(t),o=toObjCType(e,n,a);if(!a)return`RCTRequired<${o}> ${r};`;const i=" ".repeat(o.endsWith("*")?0:1);return`${o}${i}${r};`}).join("\n          ")}),methods:MethodTemplate({hasteModuleName:e,structName:t.name,properties:t.properties.map(t=>{const{typeAnnotation:n,optional:a,name:r}=t,o=getSafePropertyName(t);let i=`auto ${o} = i.${o}`;a||(i+=".get()");return`  ${i};\n  ${`d[@"${r}"] = `+toObjCValue(e,n,o,0,a)};`}).join("\n")})}}module.exports={serializeConstantsStruct:serializeConstantsStruct};