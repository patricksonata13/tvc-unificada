"use strict";const{indent:indent,toSafeCppString:toSafeCppString}=require("../Utils"),{generateEventStructName:generateEventStructName,getCppArrayTypeForAnnotation:getCppArrayTypeForAnnotation,getCppTypeForAnnotation:getCppTypeForAnnotation,getImports:getImports}=require("./CppHelpers"),nullthrows=require("nullthrows"),FileTemplate=({componentEmitters:e,extraIncludes:t})=>`\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * @generated by codegen project: GenerateEventEmitterH.js\n */\n#pragma once\n\n#include <react/renderer/components/view/ViewEventEmitter.h>\n${[...t].join("\n")}\n\nnamespace facebook::react {\n${e}\n} // namespace facebook::react\n`,ComponentTemplate=({className:e,structs:t,events:n})=>`\nclass ${e}EventEmitter : public ViewEventEmitter {\n public:\n  using ViewEventEmitter::ViewEventEmitter;\n\n  ${t}\n  ${n}\n};\n`.trim(),StructTemplate=({structName:e,fields:t})=>`\n  struct ${e} {\n    ${t}\n  };\n`.trim(),EnumTemplate=({enumName:e,values:t,toCases:n})=>`enum class ${e} {\n  ${t}\n};\n\nstatic char const *toString(const ${e} value) {\n  switch (value) {\n    ${n}\n  }\n}\n`.trim();function getNativeTypeFromAnnotation(e,t,n){const{type:a}=t.typeAnnotation;switch(a){case"BooleanTypeAnnotation":case"StringTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":case"MixedTypeAnnotation":return getCppTypeForAnnotation(a);case"StringLiteralUnionTypeAnnotation":case"ObjectTypeAnnotation":return generateEventStructName([...n,t.name]);case"ArrayTypeAnnotation":const e=t.typeAnnotation;if("ArrayTypeAnnotation"!==e.type)throw new Error("Inconsistent Codegen state: type was ArrayTypeAnnotation at the beginning of the body and now it isn't");return getCppArrayTypeForAnnotation(e.elementType,[...n,t.name]);default:throw new Error(`Received invalid event property type ${a}`)}}function generateEnum(e,t,n){const a=generateEventStructName(n),o=t.map((e,t)=>`${toSafeCppString(e)}`).join(",\n  "),r=t.map(e=>`case ${a}::${toSafeCppString(e)}: return "${e}";`).join("\n    ");e.set(a,EnumTemplate({enumName:a,values:o,toCases:r}))}function handleGenerateStructForArray(e,t,n,a,o){"ObjectTypeAnnotation"===a.type?generateStruct(e,n,o.concat([t]),nullthrows(a.properties)):"StringLiteralUnionTypeAnnotation"===a.type?generateEnum(e,a.types.map(e=>e.value),o.concat([t])):"ArrayTypeAnnotation"===a.type&&handleGenerateStructForArray(e,t,n,a.elementType,o)}function generateStruct(e,t,n,a){const o=n,r=generateEventStructName(o),i=a.map(e=>`${getNativeTypeFromAnnotation(t,e,o)} ${e.name};`).join("\n  ");a.forEach(a=>{const{name:o,typeAnnotation:r}=a;switch(r.type){case"BooleanTypeAnnotation":case"StringTypeAnnotation":case"Int32TypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":case"MixedTypeAnnotation":return;case"ArrayTypeAnnotation":return void handleGenerateStructForArray(e,o,t,r.elementType,n);case"ObjectTypeAnnotation":return void generateStruct(e,t,n.concat([o]),nullthrows(r.properties));case"StringLiteralUnionTypeAnnotation":return void generateEnum(e,r.types.map(e=>e.value),n.concat([o]));default:throw r.type,new Error(`Received invalid event property type ${r.type}`)}}),e.set(r,StructTemplate({structName:r,fields:i}))}function generateStructs(e,t){const n=new Map;return t.events.forEach(t=>{t.typeAnnotation.argument&&generateStruct(n,e,[t.name],t.typeAnnotation.argument.properties)}),Array.from(n.values()).join("\n\n")}function generateEvent(e,t){if(t.typeAnnotation.argument){const e=generateEventStructName([t.name]);return`void ${t.name}(${e} value) const;`}return`void ${t.name}() const;`}function generateEvents(e,t){return t.events.map(t=>generateEvent(e,t)).join("\n\n  ")}module.exports={generate(e,t,n,a=!1,o){const r=Object.keys(t.modules).map(e=>{const n=t.modules[e];if("Component"!==n.type)return null;const{components:a}=n;return null==a?null:a}).filter(Boolean).reduce((e,t)=>Object.assign(e,t),{}),i=new Set,p=Object.keys(r).map(e=>{const t=r[e];t.events.forEach(e=>{if(e.typeAnnotation.argument){getImports(e.typeAnnotation.argument.properties).forEach(i.add,i)}});return ComponentTemplate({className:e,structs:indent(generateStructs(e,t),2),events:generateEvents(e,t)})}).join("\n"),c=FileTemplate({componentEmitters:p,extraIncludes:i});return new Map([["EventEmitters.h",c]])}};