"use strict";const{unwrapNullable:unwrapNullable}=require("../../parsers/parsers-commons"),{wrapOptional:wrapOptional}=require("../TypeUtils/Cxx"),{getEnumName:getEnumName,toPascalCase:toPascalCase,toSafeCppString:toSafeCppString}=require("../Utils"),{indent:indent}=require("../Utils"),{createAliasResolver:createAliasResolver,getModules:getModules,isArrayRecursiveMember:isArrayRecursiveMember,isDirectRecursiveMember:isDirectRecursiveMember}=require("./Utils"),ModuleClassDeclarationTemplate=({hasteModuleName:e,moduleProperties:n,structs:t,enums:r})=>`${r}\n  ${t}class JSI_EXPORT ${e}CxxSpecJSI : public TurboModule {\nprotected:\n  ${e}CxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);\n\npublic:\n  ${indent(n.join("\n"),2)}\n\n};`,ModuleSpecClassDeclarationTemplate=({hasteModuleName:e,moduleName:n,moduleEventEmitters:t,moduleProperties:r})=>`template <typename T>\nclass JSI_EXPORT ${e}CxxSpec : public TurboModule {\npublic:\n  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {\n    return delegate_.create(rt, propName);\n  }\n\n  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {\n    return delegate_.getPropertyNames(runtime);\n  }\n\n  static constexpr std::string_view kModuleName = "${n}";\n\nprotected:\n  ${e}CxxSpec(std::shared_ptr<CallInvoker> jsInvoker)\n    : TurboModule(std::string{${e}CxxSpec::kModuleName}, jsInvoker),\n      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}\n${t.map(e=>e.emitFunction).join("\n")}\n\nprivate:\n  class Delegate : public ${e}CxxSpecJSI {\n  public:\n    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :\n      ${e}CxxSpecJSI(std::move(jsInvoker)), instance_(instance) {\n${t.map(e=>e.registerEventEmitter).join("\n")}\n    }\n\n    ${indent(r.join("\n"),4)}\n\n  private:\n    friend class ${e}CxxSpec;\n    T *instance_;\n  };\n\n  Delegate delegate_;\n};`,FileTemplate=({modules:e})=>`/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * @generated by codegen project: GenerateModuleH.js\n */\n\n#pragma once\n\n#include <ReactCommon/TurboModule.h>\n#include <react/bridging/Bridging.h>\n\nnamespace facebook::react {\n\n${e.join("\n\n")}\n\n} // namespace facebook::react\n`;function translatePrimitiveJSTypeToCpp(e,n,t,r,a,o,i){const[s,p]=unwrapNullable(t),u=isDirectRecursiveMember(n,t),l=!r&&!p||u;let m=s;switch("TypeAliasTypeAnnotation"===m.type&&(m=o(m.name)),m.type){case"ReservedTypeAnnotation":if("RootTag"===m.name)return wrapOptional("double",l);throw m.name,new Error(a(m.name));case"VoidTypeAnnotation":return"void";case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return wrapOptional("jsi::String",l);case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":return wrapOptional("double",l);case"Int32TypeAnnotation":return wrapOptional("int",l);case"BooleanTypeAnnotation":return wrapOptional("bool",l);case"EnumDeclaration":switch(m.memberType){case"NumberTypeAnnotation":return wrapOptional("jsi::Value",l);case"StringTypeAnnotation":return wrapOptional("jsi::String",l);default:throw new Error(a(m.type))}case"GenericObjectTypeAnnotation":return wrapOptional("jsi::Object",l);case"UnionTypeAnnotation":switch(s.memberType){case"NumberTypeAnnotation":return wrapOptional("double",l);case"ObjectTypeAnnotation":return wrapOptional("jsi::Object",l);case"StringTypeAnnotation":return wrapOptional("jsi::String",l);default:throw new Error(a(m.type))}case"ObjectTypeAnnotation":return wrapOptional("jsi::Object",l);case"ArrayTypeAnnotation":return wrapOptional("jsi::Array",l);case"FunctionTypeAnnotation":return wrapOptional("jsi::Function",l);case"PromiseTypeAnnotation":case"MixedTypeAnnotation":return wrapOptional("jsi::Value",l);default:throw m.type,new Error(a(m.type))}}function createStructsString(e,n,t,r){return Object.keys(n).map(a=>{const o=n[a];if(0===o.properties.length)return"";const i=`${e}${a}`,s=o.properties.filter(e=>!isDirectRecursiveMember(a,e.typeAnnotation)&&!isArrayRecursiveMember(a,e.typeAnnotation)),p=s.map((e,n)=>`typename P${n}`).join(", "),u=s.map((e,n)=>`P${n}`).join(", ");let l=-1;const m=o.properties.map(e=>{if(isDirectRecursiveMember(a,e.typeAnnotation))return`std::unique_ptr<${i}<${u}>> ${e.name}`;if(isArrayRecursiveMember(a,e.typeAnnotation)){const[n]=unwrapNullable(e.typeAnnotation);return(n?`std::optional<std::vector<${i}<${u}>>>`:`std::vector<${i}<${u}>>`)+` ${e.name}`}return l++,`P${l} ${e.name}`}),c=o.properties.map(n=>`  static ${((n,a)=>translatePrimitiveJSTypeToCpp(e,n,a.typeAnnotation,!1,e=>`Unsupported type for param "${a.name}". Found: ${e}`,t,r))(a,n)} ${n.name}ToJs(jsi::Runtime &rt, decltype(types.${n.name}) value) {\n    return bridging::toJs(rt, value);\n  }`).join("\n\n");return`\n#pragma mark - ${i}\n\ntemplate <${p}>\nstruct ${i} {\n${m.map(e=>"  "+e).join(";\n")};\n  bool operator==(const ${i} &other) const {\n    return ${o.properties.map(e=>`${e.name} == other.${e.name}`).join(" && ")};\n  }\n};\n\ntemplate <typename T>\nstruct ${i}Bridging {\n  static T types;\n\n  static T fromJs(\n      jsi::Runtime &rt,\n      const jsi::Object &value,\n      const std::shared_ptr<CallInvoker> &jsInvoker) {\n    T result{\n${o.properties.map(e=>isDirectRecursiveMember(a,e.typeAnnotation)?`      value.hasProperty(rt, "${e.name}") ? std::make_unique<T>(bridging::fromJs<T>(rt, value.getProperty(rt, "${e.name}"), jsInvoker)) : nullptr`:`      bridging::fromJs<decltype(types.${e.name})>(rt, value.getProperty(rt, "${e.name}"), jsInvoker)`).join(",\n")}};\n    return result;\n  }\n\n#ifdef DEBUG\n${c}\n#endif\n\n  static jsi::Object toJs(\n      jsi::Runtime &rt,\n      const T &value,\n      const std::shared_ptr<CallInvoker> &jsInvoker) {\n    auto result = facebook::jsi::Object(rt);\n${o.properties.map(e=>isDirectRecursiveMember(a,e.typeAnnotation)?`    if (value.${e.name}) {\n        result.setProperty(rt, "${e.name}", bridging::toJs(rt, *value.${e.name}, jsInvoker));\n      }`:e.optional?`    if (value.${e.name}) {\n      result.setProperty(rt, "${e.name}", bridging::toJs(rt, value.${e.name}.value(), jsInvoker));\n    }`:`    result.setProperty(rt, "${e.name}", bridging::toJs(rt, value.${e.name}, jsInvoker));`).join("\n")}\n    return result;\n  }\n};\n\n`}).join("\n")}const EnumTemplate=({enumName:e,values:n,fromCases:t,toCases:r,nativeEnumMemberType:a})=>{const[o,i,s]="std::string"===a?["const jsi::String &rawValue","std::string value = rawValue.utf8(rt);","jsi::String"]:["const jsi::Value &rawValue","double value = (double)rawValue.asNumber();","jsi::Value"];return`\n#pragma mark - ${e}\n\nenum class ${e} { ${n} };\n\ntemplate <>\nstruct Bridging<${e}> {\n  static ${e} fromJs(jsi::Runtime &rt, ${o}) {\n    ${i}\n    ${t}\n  }\n\n  static ${s} toJs(jsi::Runtime &rt, ${e} value) {\n    ${r}\n  }\n};`};function getMemberValueAppearance(e){return"StringLiteralTypeAnnotation"===e.type?`"${e.value}"`:e.value}function generateEnum(e,n,t,r){const a=getEnumName(e,n),o="StringTypeAnnotation"===r?"std::string":"int32_t",i=t.map(e=>`if (value == ${getMemberValueAppearance(e.value)}) {\n      return ${a}::${toSafeCppString(e.name)};\n    }`).join(" else ")+` else {\n      throw jsi::JSError(rt, "No appropriate enum member found for value in ${a}");\n    }`,s=t.map(e=>`if (value == ${a}::${toSafeCppString(e.name)}) {\n      return bridging::toJs(rt, ${getMemberValueAppearance(e.value)});\n    }`).join(" else ")+` else {\n      throw jsi::JSError(rt, "No appropriate enum member found for enum value in ${a}");\n    }`;return EnumTemplate({enumName:a,values:t.map(e=>toSafeCppString(e.name)).join(", "),fromCases:i,toCases:s,nativeEnumMemberType:o})}function createEnums(e,n,t){return Object.entries(n).map(([n,t])=>generateEnum(e,n,t.members,t.memberType)).filter(Boolean).join("\n")}function translatePropertyToCpp(e,n,t,r,a=!1){const[o]=unwrapNullable(n.typeAnnotation),i=o.params.map(e=>`std::move(${e.name})`),s=o.params.map(a=>`${translatePrimitiveJSTypeToCpp(e,null,a.typeAnnotation,a.optional,e=>`Unsupported type for param "${a.name}" in ${n.name}. Found: ${e}`,t,r)} ${a.name}`),p=translatePrimitiveJSTypeToCpp(e,null,o.returnTypeAnnotation,!1,e=>`Unsupported return type for ${n.name}. Found: ${e}`,t,r);s.unshift("jsi::Runtime &rt");const u=`${p} ${n.name}(${s.join(", ")})`;return a?`virtual ${u} = 0;`:`${u} override {\n  static_assert(\n      bridging::getParameterCount(&T::${n.name}) == ${s.length},\n      "Expected ${n.name}(...) to have ${s.length} parameters");\n\n  return bridging::callFromJs<${p}>(\n      rt, &T::${n.name}, jsInvoker_, ${["instance_",...i].join(", ")});\n}`}function translateEventEmitterToCpp(e,n,t,r){const a="VoidTypeAnnotation"===n.typeAnnotation.typeAnnotation.type,o=`${toPascalCase(n.name)}Type`,i=translatePrimitiveJSTypeToCpp(e,null,n.typeAnnotation.typeAnnotation,!1,t=>`Unsupported type for eventEmitter "${n.name}" in ${e}. Found: ${t}`,t,r),s="jsi::Array"===i;return{isVoidTypeAnnotation:a,templateName:a?`/*${o}*/`:o,registerEventEmitter:`      eventEmitterMap_["${n.name}"] = std::make_shared<AsyncEventEmitter<${a?"":"jsi::Value"}>>();`,emitFunction:`\n  ${a?"":`template <typename ${o}> `}void emit${toPascalCase(n.name)}(${a?"":`${s?`std::vector<${o}>`:o} value`}) {${a?"":`\n    static_assert(bridging::supportsFromJs<${s?`std::vector<${o}>`:o}, ${i}>, "value cannnot be converted to ${i}");`}\n    static_cast<AsyncEventEmitter<${a?"":"jsi::Value"}>&>(*delegate_.eventEmitterMap_["${n.name}"]).emit(${a?"":"[jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {\n      return bridging::toJs(rt, eventValue, jsInvoker);\n    }"});\n  }`}}module.exports={generate(e,n,t,r=!1,a){const o=getModules(n),i=Object.keys(o).flatMap(e=>{const{aliasMap:n,enumMap:t,spec:r,moduleName:a}=o[e],i=createAliasResolver(n),s=createStructsString(e,n,i,t),p=createEnums(e,t,i);return[ModuleClassDeclarationTemplate({hasteModuleName:e,moduleProperties:r.methods.map(n=>translatePropertyToCpp(e,n,i,t,!0)),structs:s,enums:p}),ModuleSpecClassDeclarationTemplate({hasteModuleName:e,moduleName:a,moduleEventEmitters:r.eventEmitters.map(e=>translateEventEmitterToCpp(a,e,i,t)),moduleProperties:r.methods.map(n=>translatePropertyToCpp(e,n,i,t))})]}),s=`${e}JSI.h`,p=FileTemplate({modules:i});return new Map([[s,p]])}};