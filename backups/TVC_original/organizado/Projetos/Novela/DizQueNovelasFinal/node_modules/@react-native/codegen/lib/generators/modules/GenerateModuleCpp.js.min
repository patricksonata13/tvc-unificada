"use strict";const{unwrapNullable:unwrapNullable}=require("../../parsers/parsers-commons"),{createAliasResolver:createAliasResolver,getModules:getModules}=require("./Utils"),HostFunctionTemplate=({hasteModuleName:e,methodName:n,returnTypeAnnotation:t,args:a})=>{const o="NullableTypeAnnotation"===t.type,r="VoidTypeAnnotation"===t.type,s=`static_cast<${e}CxxSpecJSI *>(&turboModule)->${n}(\n${["    rt",...a].join(",\n    ")}\n  )`;return`static jsi::Value __hostFunction_${e}CxxSpecJSI_${n}(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {${r?`\n  ${s};`:o?`\n  auto result = ${s};`:""}\n  return ${r?"jsi::Value::undefined()":o?"result ? jsi::Value(std::move(*result)) : jsi::Value::null()":s};\n}`},ModuleTemplate=({hasteModuleName:e,hostFunctions:n,moduleName:t,methods:a})=>`${n.join("\n")}\n\n${e}CxxSpecJSI::${e}CxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)\n  : TurboModule("${t}", jsInvoker) {\n${a.map(({methodName:n,paramCount:t})=>`  methodMap_["${n}"] = MethodMetadata {${t}, __hostFunction_${e}CxxSpecJSI_${n}};`).join("\n")}\n}`,FileTemplate=({libraryName:e,modules:n})=>`/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * @generated by codegen project: GenerateModuleCpp.js\n */\n\n#include "${e}JSI.h"\n\nnamespace facebook::react {\n\n${n}\n\n\n} // namespace facebook::react\n`;function serializeArg(e,n,t,a,o){const{typeAnnotation:r,optional:s}=n,[i,u]=unwrapNullable(r);let p=i;function l(e){const n=`args[${t}]`,a=e(n);return s&&!u?`count <= ${t} || ${n}.isUndefined() ? std::nullopt : std::make_optional(${a})`:u||s?`count <= ${t} || ${n}.isNull() || ${n}.isUndefined() ? std::nullopt : std::make_optional(${a})`:`count <= ${t} ? throw jsi::JSError(rt, "Expected argument in position ${t} to be passed") : ${a}`}switch("TypeAliasTypeAnnotation"===p.type&&(p=a(p.name)),p.type){case"ReservedTypeAnnotation":if("RootTag"===p.name)return l(e=>`${e}.asNumber()`);throw p.name,new Error(`Unknown prop type for "${n.name}, found: ${p.name}"`);case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return l(e=>`${e}.asString(rt)`);case"BooleanTypeAnnotation":return l(e=>`${e}.asBool()`);case"EnumDeclaration":switch(p.memberType){case"NumberTypeAnnotation":return l(e=>`${e}.asNumber()`);case"StringTypeAnnotation":return l(e=>`${e}.asString(rt)`);default:throw new Error(`Unknown enum type for "${n.name}, found: ${p.type}"`)}case"NumberTypeAnnotation":case"FloatTypeAnnotation":case"DoubleTypeAnnotation":case"Int32TypeAnnotation":case"NumberLiteralTypeAnnotation":return l(e=>`${e}.asNumber()`);case"ArrayTypeAnnotation":return l(e=>`${e}.asObject(rt).asArray(rt)`);case"FunctionTypeAnnotation":return l(e=>`${e}.asObject(rt).asFunction(rt)`);case"GenericObjectTypeAnnotation":return l(e=>`${e}.asObject(rt)`);case"UnionTypeAnnotation":switch(i.memberType){case"NumberTypeAnnotation":return l(e=>`${e}.asNumber()`);case"ObjectTypeAnnotation":return l(e=>`${e}.asObject(rt)`);case"StringTypeAnnotation":return l(e=>`${e}.asString(rt)`);default:throw new Error(`Unsupported union member type for param  "${n.name}, found: ${p.memberType}"`)}case"ObjectTypeAnnotation":return l(e=>`${e}.asObject(rt)`);case"MixedTypeAnnotation":return l(e=>`jsi::Value(rt, ${e})`);default:throw p.type,new Error(`Unknown prop type for "${n.name}, found: ${p.type}"`)}}function serializePropertyIntoHostFunction(e,n,t,a,o){const[r]=unwrapNullable(t.typeAnnotation);return HostFunctionTemplate({hasteModuleName:n,methodName:t.name,returnTypeAnnotation:r.returnTypeAnnotation,args:r.params.map((n,t)=>serializeArg(e,n,t,a,o))})}module.exports={generate(e,n,t,a=!1,o){const r=getModules(n),s=Object.keys(r).map(e=>{const n=r[e],{aliasMap:t,enumMap:a,spec:{methods:o},moduleName:s}=n,i=createAliasResolver(t),u=o.map(n=>serializePropertyIntoHostFunction(s,e,n,i,a));return ModuleTemplate({hasteModuleName:e,hostFunctions:u,moduleName:s,methods:o.map(({name:e,typeAnnotation:n})=>{const[{params:t}]=unwrapNullable(n);return{methodName:e,paramCount:t.length}})})}).join("\n"),i=`${e}JSI-generated.cpp`,u=FileTemplate({modules:s,libraryName:e});return new Map([[i,u]])}};