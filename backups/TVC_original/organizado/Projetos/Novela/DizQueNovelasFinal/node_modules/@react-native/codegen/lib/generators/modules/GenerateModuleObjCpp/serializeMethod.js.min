"use strict";const{unwrapNullable:unwrapNullable,wrapNullable:wrapNullable}=require("../../../parsers/parsers-commons"),{wrapOptional:wrapOptional}=require("../../TypeUtils/Objective-C"),{capitalize:capitalize}=require("../../Utils"),{getNamespacedStructName:getNamespacedStructName}=require("./Utils"),invariant=require("invariant"),ProtocolMethodTemplate=({returnObjCType:e,methodName:t,params:n})=>`- (${e})${t}${n};`;function serializeMethod(e,t,n,r){const{name:a,typeAnnotation:o}=t,[p]=unwrapNullable(o),{params:i}=p;if("getConstants"===a)return serializeConstantsProtocolMethods(e,t,n,r);const u=[],s=[];i.forEach((t,o)=>{const p=getParamStructName(a,t),{objCType:i,isStruct:c}=getParamObjCType(e,a,t,p,n,r);u.push({paramName:t.name,objCType:i}),c&&s.push({paramIndex:o,structName:p})});const[c]=unwrapNullable(p.returnTypeAnnotation);"PromiseTypeAnnotation"===c.type&&u.push({paramName:"resolve",objCType:"RCTPromiseResolveBlock"},{paramName:"reject",objCType:"RCTPromiseRejectBlock"});const y=getReturnObjCType(a,p.returnTypeAnnotation),l=`- (${y})${a}`.length,m=u.reduce((e,{objCType:t,paramName:n},r)=>{const a=`(${t})${n}`,o=" ".repeat(Math.max(0,l-n.length));return 0===r?`:${a}`:`${e}\n${o}${n}:${a}`},""),T=ProtocolMethodTemplate({methodName:a,returnObjCType:y,params:m}),A=u.map(({paramName:e})=>e).reduce((e,t,n)=>0===n?`${e}:`:`${e}${t}:`,a),b=getReturnJSType(a,c);return[{methodName:a,protocolMethod:T,selector:`@selector(${A})`,structParamRecords:s,returnJSType:b,argCount:i.length}]}function getParamStructName(e,t){const[n]=unwrapNullable(t.typeAnnotation);return"TypeAliasTypeAnnotation"===n.type?n.name:`Spec${capitalize(e)}${capitalize(t.name)}`}function getParamObjCType(e,t,n,r,a,o){const{name:p,typeAnnotation:i}=n,[u,s]=unwrapNullable(i),c=!n.optional&&!s,y=e=>({isStruct:!1,objCType:e});switch(u.type){case"FunctionTypeAnnotation":return y("RCTResponseSenderBlock");case"ArrayTypeAnnotation":return y(wrapOptional("NSArray *",!s))}const[l]=unwrapNullable(a.process(r,"REGULAR",o,wrapNullable(s,u)));switch(invariant("ArrayTypeAnnotation"!==l.type,"ArrayTypeAnnotations should have been processed earlier"),l.type){case"TypeAliasTypeAnnotation":return{isStruct:!0,objCType:getNamespacedStructName(e,l.name)+" &"};case"ReservedTypeAnnotation":if("RootTag"===l.name)return y(c?"double":"NSNumber *");throw l.name,new Error(`Unsupported type for param "${p}" in ${t}. Found: ${l.type}`);case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return y(wrapOptional("NSString *",!s));case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":return y(c?"double":"NSNumber *");case"FloatTypeAnnotation":return y(c?"float":"NSNumber *");case"DoubleTypeAnnotation":return y(c?"double":"NSNumber *");case"Int32TypeAnnotation":return y(c?"NSInteger":"NSNumber *");case"BooleanTypeAnnotation":return y(c?"BOOL":"NSNumber *");case"EnumDeclaration":switch(u.memberType){case"NumberTypeAnnotation":return y(c?"double":"NSNumber *");case"StringTypeAnnotation":return y(wrapOptional("NSString *",!s));default:throw new Error(`Unsupported enum type for param "${p}" in ${t}. Found: ${u.type}`)}case"GenericObjectTypeAnnotation":return y(wrapOptional("NSDictionary *",!s));default:throw l.type,new Error(`Unsupported type for param "${p}" in ${t}. Found: ${u.type}`)}}function getReturnObjCType(e,t){const[n,r]=unwrapNullable(t),a=!r;switch(n.type){case"VoidTypeAnnotation":case"PromiseTypeAnnotation":return"void";case"ObjectTypeAnnotation":case"TypeAliasTypeAnnotation":return wrapOptional("NSDictionary *",a);case"ArrayTypeAnnotation":return"AnyTypeAnnotation"===n.elementType.type?wrapOptional("NSArray<id<NSObject>> *",a):wrapOptional(`NSArray<${getReturnObjCType(e,n.elementType)}> *`,a);case"ReservedTypeAnnotation":if("RootTag"===n.name)return wrapOptional("NSNumber *",a);throw n.name,new Error(`Unsupported return type for ${e}. Found: ${n.name}`);case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return wrapOptional("NSString *",a);case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":case"FloatTypeAnnotation":case"DoubleTypeAnnotation":case"Int32TypeAnnotation":case"BooleanTypeAnnotation":return wrapOptional("NSNumber *",a);case"EnumDeclaration":switch(n.memberType){case"NumberTypeAnnotation":return wrapOptional("NSNumber *",a);case"StringTypeAnnotation":return wrapOptional("NSString *",a);default:throw new Error(`Unsupported enum return type for ${e}. Found: ${n.type}`)}case"UnionTypeAnnotation":switch(n.memberType){case"NumberTypeAnnotation":return wrapOptional("NSNumber *",a);case"ObjectTypeAnnotation":return wrapOptional("NSDictionary *",a);case"StringTypeAnnotation":return wrapOptional("NSString *",a);default:throw new Error(`Unsupported union return type for ${e}, found: ${n.memberType}"`)}case"GenericObjectTypeAnnotation":return wrapOptional("NSDictionary *",a);default:throw n.type,new Error(`Unsupported return type for ${e}. Found: ${n.type}`)}}function getReturnJSType(e,t){const[n]=unwrapNullable(t);switch(n.type){case"VoidTypeAnnotation":return"VoidKind";case"PromiseTypeAnnotation":return"PromiseKind";case"ObjectTypeAnnotation":case"TypeAliasTypeAnnotation":return"ObjectKind";case"ArrayTypeAnnotation":return"ArrayKind";case"ReservedTypeAnnotation":return"NumberKind";case"StringTypeAnnotation":case"StringLiteralTypeAnnotation":case"StringLiteralUnionTypeAnnotation":return"StringKind";case"NumberTypeAnnotation":case"NumberLiteralTypeAnnotation":case"FloatTypeAnnotation":case"DoubleTypeAnnotation":case"Int32TypeAnnotation":return"NumberKind";case"BooleanTypeAnnotation":return"BooleanKind";case"GenericObjectTypeAnnotation":return"ObjectKind";case"EnumDeclaration":switch(n.memberType){case"NumberTypeAnnotation":return"NumberKind";case"StringTypeAnnotation":return"StringKind";default:throw new Error(`Unsupported return type for ${e}. Found: ${n.type}`)}case"UnionTypeAnnotation":switch(n.memberType){case"NumberTypeAnnotation":return"NumberKind";case"ObjectTypeAnnotation":return"ObjectKind";case"StringTypeAnnotation":return"StringKind";default:throw new Error(`Unsupported return type for ${e}. Found: ${n.type}`)}default:throw n.type,new Error(`Unsupported return type for ${e}. Found: ${n.type}`)}}function serializeConstantsProtocolMethods(e,t,n,r){const[a]=unwrapNullable(t.typeAnnotation);if(0!==a.params.length)throw new Error(`${e}.getConstants() may only accept 0 arguments.`);let{returnTypeAnnotation:o}=a;if("TypeAliasTypeAnnotation"===o.type&&(o=r(o.name)),"ObjectTypeAnnotation"!==o.type)throw new Error(`${e}.getConstants() may only return an object literal: {...} or a type alias of such. Got '${a.returnTypeAnnotation.type}'.`);if("ObjectTypeAnnotation"===o.type&&0===o.properties.length)return[];const p=n.process("Constants","CONSTANTS",r,o);invariant("TypeAliasTypeAnnotation"===p.type,"Unable to generate C++ struct from module's getConstants() method return type.");const i=`facebook::react::ModuleConstants<JS::${e}::Constants::Builder>`;return["constantsToExport","getConstants"].map(e=>({methodName:e,protocolMethod:ProtocolMethodTemplate({methodName:e,returnObjCType:i,params:""}),returnJSType:"ObjectKind",selector:`@selector(${e})`,structParamRecords:[],argCount:0}))}module.exports={serializeMethod:serializeMethod};