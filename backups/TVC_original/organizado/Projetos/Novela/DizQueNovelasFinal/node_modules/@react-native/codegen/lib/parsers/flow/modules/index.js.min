"use strict";const{UnsupportedEnumDeclarationParserError:UnsupportedEnumDeclarationParserError,UnsupportedGenericParserError:UnsupportedGenericParserError,UnsupportedObjectPropertyWithIndexerTypeAnnotationParserError:UnsupportedObjectPropertyWithIndexerTypeAnnotationParserError,UnsupportedTypeAnnotationParserError:UnsupportedTypeAnnotationParserError}=require("../../errors"),{assertGenericTypeAnnotationHasExactlyOneTypeParameter:assertGenericTypeAnnotationHasExactlyOneTypeParameter,parseObjectProperty:parseObjectProperty,unwrapNullable:unwrapNullable,wrapNullable:wrapNullable}=require("../../parsers-commons"),{emitArrayType:emitArrayType,emitCommonTypes:emitCommonTypes,emitDictionary:emitDictionary,emitFunction:emitFunction,emitNumberLiteral:emitNumberLiteral,emitPromise:emitPromise,emitRootTag:emitRootTag,emitUnion:emitUnion,translateArrayTypeAnnotation:translateArrayTypeAnnotation,typeAliasResolution:typeAliasResolution,typeEnumResolution:typeEnumResolution}=require("../../parsers-primitives");function translateTypeAnnotation(e,t,r,n,o,a,i,s){const p=s.getResolveTypeAnnotationFN(),{nullable:y,typeAnnotation:u,typeResolutionStatus:l}=p(t,r,s);switch(u.type){case"ArrayTypeAnnotation":return translateArrayTypeAnnotation(e,r,n,o,i,"Array",u.elementType,y,translateTypeAnnotation,s);case"GenericTypeAnnotation":switch(s.getTypeAnnotationName(u)){case"RootTag":return emitRootTag(y);case"Promise":return emitPromise(e,u,s,y,r,n,o,a,i,translateTypeAnnotation);case"Array":case"$ReadOnlyArray":return emitArrayType(e,u,s,r,n,o,i,y,translateTypeAnnotation);case"$ReadOnly":{assertGenericTypeAnnotationHasExactlyOneTypeParameter(e,u,s);const[t,p]=unwrapNullable(translateTypeAnnotation(e,u.typeParameters.params[0],r,n,o,a,i,s));return wrapNullable(y||p,t)}default:{const t=emitCommonTypes(e,r,u,n,o,a,i,y,s);if(!t)throw new UnsupportedGenericParserError(e,u,s);return t}}case"ObjectTypeAnnotation":{if(u.indexers){const t=u.indexers.filter(e=>"ObjectTypeIndexer"===e.type);if(t.length>0&&u.properties.length>0)throw new UnsupportedObjectPropertyWithIndexerTypeAnnotationParserError(e,u);if(t.length>0){const p=t[0].value,u=translateTypeAnnotation(e,p,r,n,o,a,i,s);return emitDictionary(y,u)}}const p={type:"ObjectTypeAnnotation",properties:[...u.properties,...u.indexers].map(p=>a(()=>parseObjectProperty(t,p,e,r,n,o,a,i,y,translateTypeAnnotation,s))).filter(Boolean)};return typeAliasResolution(l,p,n,y)}case"FunctionTypeAnnotation":return emitFunction(y,e,u,r,n,o,a,i,translateTypeAnnotation,s);case"UnionTypeAnnotation":return emitUnion(y,e,u,s);case"NumberLiteralTypeAnnotation":return emitNumberLiteral(y,u.value);case"StringLiteralTypeAnnotation":return wrapNullable(y,{type:"StringLiteralTypeAnnotation",value:u.value});case"EnumStringBody":case"EnumNumberBody":if("EnumNumberBody"===u.type&&u.members.some(e=>{var t;return"EnumNumberMember"===e.type&&!Number.isInteger(null===(t=e.init)||void 0===t?void 0:t.value)}))throw new UnsupportedEnumDeclarationParserError(e,u,s.language());return typeEnumResolution(u,l,y,e,o,s);default:{const t=emitCommonTypes(e,r,u,n,o,a,i,y,s);if(!t)throw new UnsupportedTypeAnnotationParserError(e,u,s.language());return t}}}module.exports={flowTranslateTypeAnnotation:translateTypeAnnotation};