"use strict";const{getEnumName:getEnumName,toSafeCppString:toSafeCppString}=require("../Utils");function toIntEnumValueName(e,t){return`${toSafeCppString(e)}${t}`}function getCppTypeForAnnotation(e){switch(e){case"BooleanTypeAnnotation":return"bool";case"StringTypeAnnotation":return"std::string";case"Int32TypeAnnotation":return"int";case"DoubleTypeAnnotation":return"double";case"FloatTypeAnnotation":return"Float";case"MixedTypeAnnotation":return"folly::dynamic";default:throw new Error(`Received invalid typeAnnotation ${e}`)}}function getCppArrayTypeForAnnotation(e,t){switch(e.type){case"BooleanTypeAnnotation":case"StringTypeAnnotation":case"DoubleTypeAnnotation":case"FloatTypeAnnotation":case"Int32TypeAnnotation":case"MixedTypeAnnotation":return`std::vector<${getCppTypeForAnnotation(e.type)}>`;case"StringLiteralUnionTypeAnnotation":case"ObjectTypeAnnotation":if(!t)throw new Error(`Trying to generate the event emitter for an Array of ${e.type} without informations to generate the generic type`);return`std::vector<${generateEventStructName(t)}>`;case"ArrayTypeAnnotation":return`std::vector<${getCppArrayTypeForAnnotation(e.elementType,t)}>`;default:throw new Error(`Can't determine array type with typeElement: ${JSON.stringify(e,null,2)}`)}}function getImports(e){const t=new Set;function n(e){switch(e){case"ColorPrimitive":case"PointPrimitive":case"EdgeInsetsPrimitive":case"ImageRequestPrimitive":return;case"ImageSourcePrimitive":return void t.add("#include <react/renderer/components/image/conversions.h>");case"DimensionPrimitive":return void t.add("#include <react/renderer/components/view/conversions.h>");default:throw new Error(`Invalid name, got ${e}`)}}return e.forEach(e=>{const r=e.typeAnnotation;if("ReservedPropTypeAnnotation"===r.type&&n(r.name),"ArrayTypeAnnotation"===r.type&&"ReservedPropTypeAnnotation"===r.elementType.type&&n(r.elementType.name),"MixedTypeAnnotation"===r.type&&t.add("#include <folly/dynamic.h>"),"ObjectTypeAnnotation"===r.type){getImports(r.properties).forEach(t.add,t)}}),t}function generateEventStructName(e=[]){return e.map(toSafeCppString).join("")}function generateStructName(e,t=[]){return`${e}${t.map(toSafeCppString).join("")}Struct`}function getEnumMaskName(e){return`${e}Mask`}function getDefaultInitializerString(e,t){return`{${convertDefaultTypeToString(e,t)}}`}function convertDefaultTypeToString(e,t,n=!1){const r=t.typeAnnotation;switch(r.type){case"BooleanTypeAnnotation":return null==r.default?"":String(r.default);case"StringTypeAnnotation":return null==r.default?"":`"${r.default}"`;case"Int32TypeAnnotation":return String(r.default);case"DoubleTypeAnnotation":const o=r.default;return parseInt(o,10)===o?r.default.toFixed(1):String(r.default);case"FloatTypeAnnotation":const a=r.default;return null==a?"":parseInt(a,10)===a?a.toFixed(1):String(r.default);case"ReservedPropTypeAnnotation":switch(r.name){case"ColorPrimitive":case"ImageSourcePrimitive":case"ImageRequestPrimitive":case"PointPrimitive":case"EdgeInsetsPrimitive":case"DimensionPrimitive":return"";default:throw r.name,new Error(`Unsupported type annotation: ${r.name}`)}case"ArrayTypeAnnotation":{const o=r.elementType;if("StringEnumTypeAnnotation"===o.type){if(null==o.default)throw new Error("A default is required for array StringEnumTypeAnnotation");const r=getEnumName(e,t.name),a=getEnumMaskName(r),i=`${r}::${toSafeCppString(o.default)}`;return n?`${a}Wrapped{ .value = static_cast<${a}>(${i})}`:`static_cast<${a}>(${i})`}return""}case"ObjectTypeAnnotation":return"";case"StringEnumTypeAnnotation":return`${getEnumName(e,t.name)}::${toSafeCppString(r.default)}`;case"Int32EnumTypeAnnotation":return`${getEnumName(e,t.name)}::${toIntEnumValueName(t.name,r.default)}`;case"MixedTypeAnnotation":return"";default:throw new Error(`Unsupported type annotation: ${r.type}`)}}function getSourceProp(e,t){const n=t.typeAnnotation;if("ArrayTypeAnnotation"===n.type){if("StringEnumTypeAnnotation"===n.elementType.type){return`${getEnumMaskName(getEnumName(e,t.name))}Wrapped{ .value = sourceProps.${t.name} }`}}return`sourceProps.${t.name}`}function isWrappedPropType(e){const t=e.typeAnnotation;if("ArrayTypeAnnotation"===t.type){if("StringEnumTypeAnnotation"===t.elementType.type)return!0}return!1}const IncludeTemplate=({headerPrefix:e,file:t})=>""===e?`#include "${t}"`:`#include <${e}${t}>`;module.exports={getDefaultInitializerString:getDefaultInitializerString,convertDefaultTypeToString:convertDefaultTypeToString,getCppArrayTypeForAnnotation:getCppArrayTypeForAnnotation,getCppTypeForAnnotation:getCppTypeForAnnotation,getEnumMaskName:getEnumMaskName,getImports:getImports,toIntEnumValueName:toIntEnumValueName,generateStructName:generateStructName,generateEventStructName:generateEventStructName,IncludeTemplate:IncludeTemplate,getSourceProp:getSourceProp,isWrappedPropType:isWrappedPropType};