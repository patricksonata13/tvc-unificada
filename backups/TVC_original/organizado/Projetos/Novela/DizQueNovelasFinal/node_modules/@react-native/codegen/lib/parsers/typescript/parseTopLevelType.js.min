"use strict";function getValueFromTypes(e,n){switch(e.type){case"TSTypeReference":return n[e.typeName.name]?getValueFromTypes(n[e.typeName.name],n):e;case"TSTypeAliasDeclaration":return getValueFromTypes(e.typeAnnotation,n);default:return e}}function isNull(e){return"TSNullKeyword"===e.type||"TSUndefinedKeyword"===e.type}function isNullOrVoid(e){return isNull(e)||"TSVoidKeyword"===e.type}function couldBeNumericLiteral(e){return"Literal"===e||"NumericLiteral"===e}function couldBeSimpleLiteral(e){return couldBeNumericLiteral(e)||"StringLiteral"===e||"BooleanLiteral"===e}function evaluateLiteral(e){if("TSLiteralType"===e.type){const n=e.literal;if(couldBeSimpleLiteral(n.type)){if("string"==typeof n.value||"number"==typeof n.value||"boolean"==typeof n.value)return n.value}else if("UnaryExpression"===n.type&&"-"===n.operator&&couldBeNumericLiteral(n.argument.type)&&"number"==typeof n.argument.value)return-n.argument.value}else if(isNull(e))return null;throw new Error("The default value in WithDefault must be string, number, boolean or null .")}function handleUnionAndParen(e,n,t,a){switch(e.type){case"TSParenthesizedType":handleUnionAndParen(e.typeAnnotation,n,t,a);break;case"TSUnionType":for(const t of e.types)isNullOrVoid(t)&&(n.optional=!0);for(const r of e.types)isNullOrVoid(r)||handleUnionAndParen(r,n,t,a);break;case"TSTypeReference":if("Readonly"===e.typeName.name)handleUnionAndParen(e.typeParameters.params[0],n,t,a);else if("WithDefault"===t.getTypeAnnotationName(e)){if(n.optional)throw new Error("WithDefault<> is optional and does not need to be marked as optional. Please remove the union of undefined and/or null");if(2!==e.typeParameters.params.length)throw new Error("WithDefault requires two parameters: type and default value.");if(void 0!==n.defaultValue)throw new Error("Multiple WithDefault is not allowed nested or in a union type.");n.optional=!0,n.defaultValue=evaluateLiteral(e.typeParameters.params[1]),handleUnionAndParen(e.typeParameters.params[0],n,t,a)}else if(a){const r=getValueFromTypes(e,a);"TSTypeReference"===r.type&&r.typeName.name===e.typeName.name?n.unions.push(e):handleUnionAndParen(r,n,t,a)}else n.unions.push(e);break;default:n.unions.push(e)}}function parseTopLevelType(e,n,t){let a={unions:[],optional:!1};if(handleUnionAndParen(e,a,n,t),0===a.unions.length)throw new Error("Union type could not be just null or undefined.");return 1===a.unions.length?{type:a.unions[0],optional:a.optional,defaultValue:a.defaultValue}:{type:{type:"TSUnionType",types:a.unions},optional:a.optional,defaultValue:a.defaultValue}}function handleIntersectionAndParen(e,n,t,a){switch(e.type){case"TSParenthesizedType":handleIntersectionAndParen(e.typeAnnotation,n,t,a);break;case"TSIntersectionType":for(const r of e.types)handleIntersectionAndParen(r,n,t,a);break;case"TSTypeReference":if("Readonly"===e.typeName.name)handleIntersectionAndParen(e.typeParameters.params[0],n,t,a);else{if("WithDefault"===t.getTypeAnnotationName(e))throw new Error("WithDefault<> is now allowed in intersection types.");if(a){const r=getValueFromTypes(e,a);"TSTypeReference"===r.type&&r.typeName.name===e.typeName.name?n.push(e):handleIntersectionAndParen(r,n,t,a)}else n.push(e)}break;default:n.push(e)}}function flattenIntersectionType(e,n,t){const a=[];return handleIntersectionAndParen(e,a,n,t),a}module.exports={parseTopLevelType:parseTopLevelType,flattenIntersectionType:flattenIntersectionType};