"use strict";function _defineProperty(e,t,n){return(t=_toPropertyKey(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function _toPropertyKey(e){var t=_toPrimitive(e,"string");return"symbol"==typeof t?t:t+""}function _toPrimitive(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}const{UnsupportedObjectPropertyTypeAnnotationParserError:UnsupportedObjectPropertyTypeAnnotationParserError}=require("../errors"),{buildModuleSchema:buildModuleSchema,buildPropSchema:buildPropSchema,buildSchema:buildSchema,extendsForProp:extendsForProp,handleGenericTypeAnnotation:handleGenericTypeAnnotation}=require("../parsers-commons.js"),{Visitor:Visitor}=require("../parsers-primitives"),{wrapComponentSchema:wrapComponentSchema}=require("../schema.js"),{buildComponentSchema:buildComponentSchema}=require("./components"),{flattenProperties:flattenProperties,getSchemaInfo:getSchemaInfo,getTypeAnnotation:getTypeAnnotation}=require("./components/componentsUtils"),{typeScriptTranslateTypeAnnotation:typeScriptTranslateTypeAnnotation}=require("./modules"),{parseTopLevelType:parseTopLevelType}=require("./parseTopLevelType"),babelParser=require("@babel/parser"),fs=require("fs"),invariant=require("invariant");class TypeScriptParser{constructor(){_defineProperty(this,"typeParameterInstantiation","TSTypeParameterInstantiation"),_defineProperty(this,"typeAlias","TSTypeAliasDeclaration"),_defineProperty(this,"enumDeclaration","TSEnumDeclaration"),_defineProperty(this,"interfaceDeclaration","TSInterfaceDeclaration"),_defineProperty(this,"nullLiteralTypeAnnotation","TSNullKeyword"),_defineProperty(this,"undefinedLiteralTypeAnnotation","TSUndefinedKeyword")}isProperty(e){return"TSPropertySignature"===e.type}getKeyName(e,t){if(!this.isProperty(e))throw new UnsupportedObjectPropertyTypeAnnotationParserError(t,e,e.type,this.language());return e.key.name}language(){return"TypeScript"}getTypeAnnotationName(e){var t,n;return"TSQualifiedName"===(null==e||null===(t=e.typeName)||void 0===t?void 0:t.type)?e.typeName.right.name:null==e||null===(n=e.typeName)||void 0===n?void 0:n.name}checkIfInvalidModule(e){return"TSTypeParameterInstantiation"!==e.type||1!==e.params.length||"TSTypeReference"!==e.params[0].type||"Spec"!==e.params[0].typeName.name}remapUnionTypeAnnotationMemberNames(e){return[...new Set(e.map(e=>e.literal?e.literal.type.replace("NumericLiteral","NumberTypeAnnotation").replace("StringLiteral","StringTypeAnnotation"):"ObjectTypeAnnotation"))]}getStringLiteralUnionTypeAnnotationStringLiterals(e){return e.map(e=>e.literal.value)}parseFile(e){const t=fs.readFileSync(e,"utf8");return this.parseString(t,e)}parseString(e,t){return buildSchema(e,t,wrapComponentSchema,buildComponentSchema,buildModuleSchema,Visitor,this,typeScriptTranslateTypeAnnotation)}parseModuleFixture(e){const t=fs.readFileSync(e,"utf8");return this.parseString(t,"path/NativeSampleTurboModule.ts")}getAst(e,t){return babelParser.parse(e,{sourceType:"module",plugins:["typescript"]}).program}getFunctionTypeAnnotationParameters(e){return e.parameters}getFunctionNameFromParameter(e){return e.typeAnnotation}getParameterName(e){return e.name}getParameterTypeAnnotation(e){return e.typeAnnotation.typeAnnotation}getFunctionTypeAnnotationReturnType(e){return e.typeAnnotation.typeAnnotation}parseEnumMembersType(e){var t;const n=null===(t=e.members[0])||void 0===t?void 0:t.initializer,r=null==n?void 0:n.type;let a=null;if(!r)return"StringTypeAnnotation";switch(r){case"StringLiteral":a="StringTypeAnnotation";break;case"NumericLiteral":a="NumberTypeAnnotation";break;case"UnaryExpression":"-"===n.operator&&(a="NumberTypeAnnotation");break;default:a=null}if(!a)throw new Error("Enum values must be either blank, number, or string values.");return a}validateEnumMembersSupported(e,t){if(!e.members||0===e.members.length)throw new Error("Enums should have at least one member.");const n="StringTypeAnnotation"===t?"StringLiteral":"NumberTypeAnnotation"===t?"NumericLiteral":null;e.members.forEach(e=>{var t,r,a,o;const i="UnaryExpression"===(null===(t=e.initializer)||void 0===t?void 0:t.type)&&"-"===(null===(r=e.initializer)||void 0===r?void 0:r.operator)?null===(a=e.initializer)||void 0===a||null===(a=a.argument)||void 0===a?void 0:a.type:null===(o=e.initializer)||void 0===o?void 0:o.type;if((null!=i?i:"StringLiteral")!==n)throw new Error("Enum values can not be mixed. They all must be either blank, number, or string values.")})}parseEnumMembers(e){return e.members.map(e=>{var t,n,r,a,o,i;const p="-"===(null===(t=e.initializer)||void 0===t?void 0:t.operator)?{type:"NumberLiteralTypeAnnotation",value:-1*(null===(n=e.initializer)||void 0===n||null===(n=n.argument)||void 0===n?void 0:n.value)}:"number"==typeof(null===(r=e.initializer)||void 0===r?void 0:r.value)?{type:"NumberLiteralTypeAnnotation",value:null===(a=e.initializer)||void 0===a?void 0:a.value}:"string"==typeof(null===(o=e.initializer)||void 0===o?void 0:o.value)?{type:"StringLiteralTypeAnnotation",value:null===(i=e.initializer)||void 0===i?void 0:i.value}:{type:"StringLiteralTypeAnnotation",value:e.id.name};return{name:e.id.name,value:p}})}isModuleInterface(e){var t;return"TSInterfaceDeclaration"===e.type&&1===(null===(t=e.extends)||void 0===t?void 0:t.length)&&"TSExpressionWithTypeArguments"===e.extends[0].type&&"TurboModule"===e.extends[0].expression.name}isGenericTypeAnnotation(e){return"TSTypeReference"===e}extractAnnotatedElement(e,t){return t[e.typeParameters.params[0].typeName.name]}getTypes(e){return e.body.reduce((e,t)=>{switch(t.type){case"ExportNamedDeclaration":if(t.declaration)switch(t.declaration.type){case"TSTypeAliasDeclaration":case"TSInterfaceDeclaration":case"TSEnumDeclaration":e[t.declaration.id.name]=t.declaration}break;case"TSTypeAliasDeclaration":case"TSInterfaceDeclaration":case"TSEnumDeclaration":e[t.id.name]=t}return e},{})}callExpressionTypeParameters(e){return e.typeParameters||null}computePartialProperties(e,t,n,r,a,o,i){return e.map(e=>({name:e.key.name,optional:!0,typeAnnotation:typeScriptTranslateTypeAnnotation(t,e.typeAnnotation.typeAnnotation,n,r,a,o,i,this)}))}functionTypeAnnotation(e){return"TSFunctionType"===e||"TSMethodSignature"===e}getTypeArgumentParamsFromDeclaration(e){return e.typeParameters.params}getNativeComponentType(e,t){return{propsTypeName:e[0].typeName.name,componentName:t[0].value}}getAnnotatedElementProperties(e){return e.typeAnnotation.members}bodyProperties(e){return e.body.body}convertKeywordToTypeAnnotation(e){switch(e){case"TSArrayType":return"ArrayTypeAnnotation";case"TSBooleanKeyword":return"BooleanTypeAnnotation";case"TSNumberKeyword":return"NumberTypeAnnotation";case"TSVoidKeyword":return"VoidTypeAnnotation";case"TSStringKeyword":return"StringTypeAnnotation";case"TSTypeLiteral":return"ObjectTypeAnnotation";case"TSUnknownKeyword":return"MixedTypeAnnotation"}return e}argumentForProp(e){return e.expression}nameForArgument(e){return e.expression.name}isOptionalProperty(e){return e.optional||!1}getGetSchemaInfoFN(){return getSchemaInfo}getTypeAnnotationFromProperty(e){return e.typeAnnotation.typeAnnotation}getGetTypeAnnotationFN(){return getTypeAnnotation}getResolvedTypeAnnotation(e,t,n){invariant(null!=e,"resolveTypeAnnotation(): typeAnnotation cannot be null");let r="TSTypeAnnotation"===e.type?e.typeAnnotation:e,a=!1,o={successful:!1};for(;;){const e=parseTopLevelType(r,n);if(a=a||e.optional,r=e.type,"TSTypeReference"!==r.type)break;const i=t[this.getTypeAnnotationName(r)];if(null==i)break;const{typeAnnotation:p,typeResolutionStatus:l}=handleGenericTypeAnnotation(r,i,this);o=l,r=p}return{nullable:a,typeAnnotation:r,typeResolutionStatus:o}}getResolveTypeAnnotationFN(){return(e,t,n)=>this.getResolvedTypeAnnotation(e,t,n)}isEvent(e){if("TSTypeReference"!==e.type)return!1;return new Set(["BubblingEventHandler","DirectEventHandler"]).has(this.getTypeAnnotationName(e))}isProp(e,t){if("TSTypeReference"!==t.type)return!0;return!("style"===e&&"GenericTypeAnnotation"===t.type&&"ViewStyleProp"===this.getTypeAnnotationName(t))}getProps(e,t){const n=[],r=[],a=[];for(const r of e){if("TSExpressionWithTypeArguments"===r.type){const e=extendsForProp(r,t,this);if(e){n.push(e);continue}}a.push(r)}for(const e of flattenProperties(a,t,this)){const n=parseTopLevelType(e.typeAnnotation.typeAnnotation,this,t);"TSPropertySignature"===e.type&&!this.isEvent(n.type)&&this.isProp(e.key.name,e)&&r.push(e)}return{props:r.map(e=>buildPropSchema(e,t,this)).filter(Boolean),extendsProps:n}}getProperties(e,t){const n=t[e];if(!n)throw new Error(`Failed to find definition for "${e}", please check that you have a valid codegen typescript file`);const r="TSInterfaceDeclaration"===n.type?"interface":"type";try{var a;return"interface"===r?[...null!==(a=n.extends)&&void 0!==a?a:[],...n.body.body]:n.typeAnnotation.members||n.typeAnnotation.typeParameters.params[0].members||n.typeAnnotation.typeParameters.params}catch(t){throw new Error(`Failed to find ${r} definition for "${e}", please check that you have a valid codegen typescript file`)}}nextNodeForTypeAlias(e){return e.typeAnnotation}nextNodeForEnum(e){return e}genericTypeAnnotationErrorMessage(e){return`A non GenericTypeAnnotation must be a type declaration ('${this.typeAlias}'), an interface ('${this.interfaceDeclaration}'), or enum ('${this.enumDeclaration}'). Instead, got the unsupported ${e.type}.`}extractTypeFromTypeAnnotation(e){return"TSTypeReference"===e.type?e.typeName.name:e.type}getObjectProperties(e){return e.members}getLiteralValue(e){return e.literal.value}getPaperTopLevelNameDeprecated(e){return e.typeParameters.params.length>1?e.typeParameters.params[1].literal.value:null}}module.exports={TypeScriptParser:TypeScriptParser};