"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.WS_CLOSE_REASON=void 0;var _CdpDebugLogging=_interopRequireDefault(require("./CdpDebugLogging")),_DeviceEventReporter=_interopRequireDefault(require("./DeviceEventReporter")),fs=_interopRequireWildcard(require("fs")),_invariant=_interopRequireDefault(require("invariant")),path=_interopRequireWildcard(require("path")),_ws=_interopRequireDefault(require("ws"));function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(_getRequireWildcardCache=function(e){return e?n:t})(e)}function _interopRequireWildcard(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=_getRequireWildcardCache(t);if(n&&n.has(e))return n.get(e);var s={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in e)if("default"!==r&&{}.hasOwnProperty.call(e,r)){var o=i?Object.getOwnPropertyDescriptor(e,r):null;o&&(o.get||o.set)?Object.defineProperty(s,r,o):s[r]=e[r]}return s.default=e,n&&n.set(e,s),s}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const debug=require("debug")("Metro:InspectorProxy"),PAGES_POLLING_INTERVAL=1e3,WS_CLOSURE_CODE={NORMAL:1e3,INTERNAL_ERROR:1011},WS_CLOSE_REASON=exports.WS_CLOSE_REASON={PAGE_NOT_FOUND:"[PAGE_NOT_FOUND] Debugger page not found",CONNECTION_LOST:"[CONNECTION_LOST] Connection lost to corresponding device",RECREATING_DEVICE:"[RECREATING_DEVICE] Recreating device connection",NEW_DEBUGGER_OPENED:"[NEW_DEBUGGER_OPENED] New debugger opened for the same app instance"},FILE_PREFIX="file://";let fuseboxConsoleNoticeLogged=!1;const REACT_NATIVE_RELOADABLE_PAGE_ID="-1";class Device{#e;#t;#n;#s;#i=new Map;#r=null;#o=null;#a=!1;#g="";#c=new Map;#d;#l;#u;#p;#h=new Set;#v;#R;#b;constructor(e){this.#f(e)}#f({id:e,name:t,app:n,socket:s,projectRoot:i,eventReporter:r,createMessageMiddleware:o,serverRelativeBaseUrl:a,deviceRelativeBaseUrl:g,isProfilingBuild:c}){this.#b=new _CdpDebugLogging.default,this.#e=e,this.#t=t,this.#n=n,this.#s=s,this.#d=i,this.#R=a,this.#v=g,this.#l=r?new _DeviceEventReporter.default(r,{deviceId:e,deviceName:t,appId:n}):null,this.#p=o,c&&this.#l?.logProfilingTargetRegistered(),this.#s.on("message",e=>{try{const t=JSON.parse(e);"getPages"===t.event?e!==this.#g&&(debug("Device getPages ping has changed: %s",e),this.#g=e):this.#b.log("DeviceToProxy",e),this.#C(t)}catch(t){debug("%O\nHandling device message: %s",t,e);try{this.#l?.logProxyMessageHandlingError("device",t,e)}catch(e){debug("Error logging message handling error to reporter: %O",e)}}}),this.#u=setInterval(()=>this.#E({event:"getPages"}),1e3),this.#s.on("close",()=>{s===this.#s&&(this.#l?.logDisconnection("device"),this.#D(WS_CLOSURE_CODE.NORMAL,WS_CLOSE_REASON.CONNECTION_LOST),clearInterval(this.#u))})}#D(e,t){const n=this.#r;n&&(this.#y(this.#S(n.pageId)),n.socket.close(e,t),this.#r=null)}dangerouslyRecreateDevice(e){(0,_invariant.default)(e.id===this.#e,"dangerouslyRecreateDevice() can only be used for the same device ID");const t=this.#r;this.#n===e.app&&this.#t===e.name||(this.#s.close(WS_CLOSURE_CODE.NORMAL,WS_CLOSE_REASON.RECREATING_DEVICE),this.#D(WS_CLOSURE_CODE.NORMAL,WS_CLOSE_REASON.RECREATING_DEVICE)),this.#r=null,t&&(t.socket.removeAllListeners(),this.#s.close(WS_CLOSURE_CODE.NORMAL,WS_CLOSE_REASON.RECREATING_DEVICE),this.handleDebuggerConnection(t.socket,t.pageId,{debuggerRelativeBaseUrl:t.debuggerRelativeBaseUrl,userAgent:t.userAgent})),this.#f(e)}getName(){return this.#t}getApp(){return this.#n}getPagesList(){return this.#o?[...this.#i.values(),this.#m()]:[...this.#i.values()]}handleDebuggerConnection(e,t,{debuggerRelativeBaseUrl:n,userAgent:s}){const i="-1"===t?this.#m():this.#i.get(t);if(!i)return debug(`Got new debugger connection via ${n.href} for page ${t} of ${this.#t}, but no such page exists`),void e.close(WS_CLOSURE_CODE.INTERNAL_ERROR,WS_CLOSE_REASON.PAGE_NOT_FOUND);this.#l?.logDisconnection("debugger"),this.#D(WS_CLOSURE_CODE.NORMAL,WS_CLOSE_REASON.NEW_DEBUGGER_OPENED),this.#l?.logConnection("debugger",{pageId:t,frontendUserAgent:s});const r={socket:e,prependedFilePrefix:!1,pageId:t,userAgent:s,customHandler:null,debuggerRelativeBaseUrl:n};this.#r=r,debug(`Got new debugger connection via ${n.href} for page ${t} of ${this.#t}`),this.#r&&this.#p&&(this.#r.customHandler=this.#p({page:i,debugger:{userAgent:r.userAgent,sendMessage:t=>{try{const n=JSON.stringify(t);this.#b.log("ProxyToDebugger",n),e.send(n)}catch{}}},device:{appId:this.#n,id:this.#e,name:this.#t,sendMessage:e=>{try{const n=JSON.stringify({event:"wrappedEvent",payload:{pageId:this.#S(t),wrappedEvent:JSON.stringify(e)}});this.#b.log("DebuggerToProxy",n),this.#s.send(n)}catch{}}}}),this.#r.customHandler?debug("Created new custom message handler for debugger connection"):debug("Skipping new custom message handler for debugger connection, factory function returned null")),this.#P(this.#S(t)),e.on("message",n=>{this.#b.log("DebuggerToProxy",n);const o=JSON.parse(n);this.#l?.logRequest(o,"debugger",{pageId:this.#r?.pageId??null,frontendUserAgent:s,prefersFuseboxFrontend:this.#_(this.#r?.pageId)});let a=o;!0!==this.#r?.customHandler?.handleDebuggerMessage(o)&&(this.#N(i,"nativeSourceCodeFetching")||(a=this.#O(o,r,e)),a&&this.#E({event:"wrappedEvent",payload:{pageId:this.#S(t),wrappedEvent:JSON.stringify(a)}}))}),e.on("close",()=>{debug(`Debugger for page ${t} and ${this.#t} disconnected.`),this.#l?.logDisconnection("debugger"),this.#r?.socket===e&&this.#D()});const o=this.#b,a=e.send;e.send=function(t){return o.log("ProxyToDebugger",t),a.call(e,t)}}#P(e){this.#h.has(e)||(this.#h.add(e),this.#E({event:"connect",payload:{pageId:e}}))}#y(e){this.#h.has(e)&&(this.#h.delete(e),this.#E({event:"disconnect",payload:{pageId:e}}))}#N(e,t){return!0===e.capabilities[t]}#m(){return{id:"-1",title:"React Native Experimental (Improved Chrome Reloads)",vm:"don't use",app:this.#n,capabilities:{}}}#C(e){if("getPages"===e.event){if(this.#i=new Map(e.payload.map(({capabilities:e,...t})=>[t.id,{...t,capabilities:e??{}}])),e.payload.length!==this.#i.size){const t=new Set,n=new Set;for(const s of e.payload)n.has(s.id)?t.add(s.id):n.add(s.id);debug(`Received duplicate page IDs from device: ${[...t].join(", ")}`)}for(const e of this.#i.values())if(this.#N(e,"nativePageReloads"))this.#I();else if(e.title.includes("React")&&e.id!==this.#o?.id){this.#L(e);break}}else if("disconnect"===e.event){const t=e.payload.pageId,n=this.#i.get(t);if(null!=n&&this.#N(n,"nativePageReloads"))return;const s=this.#r?this.#r.socket:null;s&&s.readyState===_ws.default.OPEN&&null!=this.#r&&"-1"!==this.#r.pageId&&(debug(`Legacy page ${t} is reloading.`),s.send(JSON.stringify({method:"reload"})))}else if("wrappedEvent"===e.event){if(null==this.#r)return;const t=this.#r.socket;if(null==t||t.readyState!==_ws.default.OPEN)return;const n=JSON.parse(e.payload.wrappedEvent),s=this.#r?.pageId??null;"id"in n&&this.#l?.logResponse(n,"device",{pageId:s,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(s)});const i=this.#r;if(null!=i){if(!0===i.customHandler?.handleDeviceMessage(n))return;this.#T(n,i,s);const e=JSON.stringify(n);t.send(e)}else t.send(e.payload.wrappedEvent)}}#E(e){try{const t=JSON.stringify(e);"getPages"!==e.event&&this.#b.log("ProxyToDevice",t),this.#s.send(t)}catch(e){}}#L(e){if(debug(`React Native page updated to ${e.id}`),null==this.#r||"-1"!==this.#r.pageId)return void(this.#o=e);const t=this.#o?.id;this.#o=e,this.#a=!0,null!=t&&this.#y(t),this.#P(e.id);const n=[{method:"Runtime.enable",id:1e9},{method:"Debugger.enable",id:1e9}];for(const t of n){const n=this.#r?.pageId??null;this.#l?.logRequest(t,"proxy",{pageId:n,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(n)}),this.#E({event:"wrappedEvent",payload:{pageId:this.#S(e.id),wrappedEvent:JSON.stringify(t)}})}}#U(e,{debuggerRelativeBaseUrl:t}){const n=new URL(e.href);return e.origin===t.origin&&(n.hostname=this.#v.hostname,n.port=this.#v.port,n.protocol=this.#v.protocol),n}#x(e,{debuggerRelativeBaseUrl:t}){const n=new URL(e.href);return e.origin===this.#v.origin&&(n.hostname=t.hostname,n.port=t.port,n.protocol=n.protocol),n}#A(e){const t=new URL(e.href);return e.origin===this.#v.origin&&(t.hostname=this.#R.hostname,t.port=this.#R.port,t.protocol=this.#R.protocol),t}#T(e,t,n){const s=null!=n?this.#i.get(n):null;if(!(s&&this.#N(s,"nativeSourceCodeFetching")||"Debugger.scriptParsed"!==e.method||null==e.params)){const n=e.params;if("sourceMapURL"in n){const s=this.#F(n.sourceMapURL);s&&(e.params.sourceMapURL=this.#x(s,t).href)}if("url"in n){let s=n.url;const i=this.#F(n.url);i&&(e.params.url=this.#x(i,t).href,s=this.#A(i).href),e.params.url.match(/^[0-9a-z]+$/)&&(e.params.url="file://"+e.params.url,t.prependedFilePrefix=!0),"scriptId"in n&&null!=n.scriptId&&this.#c.set(n.scriptId,s)}}if("Runtime.executionContextCreated"===e.method&&this.#a){t.socket.send(JSON.stringify({method:"Runtime.executionContextsCleared"}));const e={method:"Debugger.resume",id:0};this.#l?.logRequest(e,"proxy",{pageId:this.#r?.pageId??null,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(this.#r?.pageId)}),this.#E({event:"wrappedEvent",payload:{pageId:this.#S(t.pageId),wrappedEvent:JSON.stringify(e)}}),this.#a=!1}}#O(e,t,n){switch(e.method){case"Debugger.setBreakpointByUrl":return this.#w(e,t);case"Debugger.getScriptSource":return this.#M(e,n),null;case"Network.loadNetworkResource":const s={id:e.id,result:{error:{code:-32601,message:"[inspector-proxy]: Page lacks nativeSourceCodeFetching capability."}}};n.send(JSON.stringify(s));const i=this.#r?.pageId??null;return this.#l?.logResponse(s,"proxy",{pageId:i,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(i)}),null;default:return e}}#w(e,t){const{debuggerRelativeBaseUrl:n,prependedFilePrefix:s}=t,i={...e,params:{...e.params}};if(null!=i.params.url){const e=i.params.url,n=this.#F(e);n?i.params.url=this.#U(n,t).href:e.startsWith("file://")&&s&&(i.params.url=e.slice(7))}return new Set(["10.0.2.2","10.0.3.2"]).has(this.#v.hostname)&&"localhost"===n.hostname&&null!=i.params.urlRegex&&(i.params.urlRegex=i.params.urlRegex.replaceAll("localhost",this.#v.hostname.replaceAll(".","\\."))),i}#M(e,t){const n=n=>{const s={id:e.id,result:{scriptSource:n}};t.send(JSON.stringify(s));const i=this.#r?.pageId??null;this.#l?.logResponse(s,"proxy",{pageId:i,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(i)})},s=n=>{const s={id:e.id,result:{error:{message:n}}};t.send(JSON.stringify(s)),this.#B(n);const i=this.#r?.pageId??null;this.#l?.logResponse(s,"proxy",{pageId:i,frontendUserAgent:this.#r?.userAgent??null,prefersFuseboxFrontend:this.#_(i)})},i=this.#c.get(e.params.scriptId);if(null!=i){const e=this.#F(i);if(e)this.#k(e).then(e=>n(e),e=>s(`Failed to fetch source url ${i}: ${e.message}`));else{let e;try{e=fs.readFileSync(path.resolve(this.#d,i),"utf8")}catch(e){s(`Failed to fetch source file ${i}: ${e.message}`)}null!=e&&n(e)}}}#S(e){return"-1"===e&&null!=this.#o?this.#o.id:e}#F(e){let t;try{t=new URL(e)}catch{}const n=t?.protocol;return"http:"!==n&&"https:"!==n&&(t=void 0),t}async#k(e){const t=await fetch(e);if(!t.ok)throw new Error("HTTP "+t.status+" "+t.statusText);const n=await t.text();if(n.length>35e7)throw new Error("file too large to fetch via HTTP");return n}#B(e){const t=this.#r?.socket;t&&t.readyState===_ws.default.OPEN&&t.send(JSON.stringify({method:"Runtime.consoleAPICalled",params:{args:[{type:"string",value:e}],executionContextId:0,type:"error"}}))}#_(e){const t=null==e?null:this.#i.get(e);return null==t?null:this.#N(t,"prefersFuseboxFrontend")}dangerouslyGetSocket(){return this.#s}#I(){fuseboxConsoleNoticeLogged||(this.#l?.logFuseboxConsoleNotice(),fuseboxConsoleNoticeLogged=!0)}}exports.default=Device;