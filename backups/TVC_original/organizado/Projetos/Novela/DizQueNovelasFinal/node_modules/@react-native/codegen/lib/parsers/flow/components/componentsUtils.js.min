"use strict";const{verifyPropNotAlreadyDefined:verifyPropNotAlreadyDefined}=require("../../parsers-commons"),{getValueFromTypes:getValueFromTypes}=require("../utils.js");function getTypeAnnotationForArray(e,t,n,r,o,a){const i=getValueFromTypes(t,r);if("NullableTypeAnnotation"===i.type)throw new Error('Nested optionals such as "$ReadOnlyArray<?boolean>" are not supported, please declare optionals at the top level of value definitions as in "?$ReadOnlyArray<boolean>"');if("GenericTypeAnnotation"===i.type&&"WithDefault"===o.getTypeAnnotationName(i))throw new Error('Nested defaults such as "$ReadOnlyArray<WithDefault<boolean, false>>" are not supported, please declare defaults at the top level of value definitions as in "WithDefault<$ReadOnlyArray<boolean>, false>"');if("GenericTypeAnnotation"===i.type){const e=getValueFromTypes(i,r);if("$ReadOnly"===e.id.name)return{type:"ObjectTypeAnnotation",properties:flattenProperties(e.typeParameters.params[0].properties,r,o).map(e=>a(e,r,o)).filter(Boolean)};if("$ReadOnlyArray"===e.id.name){return{type:"ArrayTypeAnnotation",elementType:{type:"ObjectTypeAnnotation",properties:flattenProperties(getValueFromTypes(e.typeParameters.params[0],r).typeParameters.params[0].properties,r,o).map(e=>a(e,r,o)).filter(Boolean)}}}}const p="GenericTypeAnnotation"===i.type?o.getTypeAnnotationName(i):i.type;switch(p){case"ImageSource":return{type:"ReservedPropTypeAnnotation",name:"ImageSourcePrimitive"};case"ImageRequest":return{type:"ReservedPropTypeAnnotation",name:"ImageRequestPrimitive"};case"ColorValue":case"ProcessedColorValue":return{type:"ReservedPropTypeAnnotation",name:"ColorPrimitive"};case"PointValue":return{type:"ReservedPropTypeAnnotation",name:"PointPrimitive"};case"EdgeInsetsValue":return{type:"ReservedPropTypeAnnotation",name:"EdgeInsetsPrimitive"};case"DimensionValue":return{type:"ReservedPropTypeAnnotation",name:"DimensionPrimitive"};case"Stringish":case"StringTypeAnnotation":return{type:"StringTypeAnnotation"};case"Int32":return{type:"Int32TypeAnnotation"};case"Double":return{type:"DoubleTypeAnnotation"};case"Float":return{type:"FloatTypeAnnotation"};case"BooleanTypeAnnotation":return{type:"BooleanTypeAnnotation"};case"UnsafeMixed":return{type:"MixedTypeAnnotation"};case"UnionTypeAnnotation":if(t.types.reduce((t,n)=>{if(t&&n.type!==t.type)throw new Error(`Mixed types are not supported (see "${e}")`);return n}),null===n)throw new Error(`A default enum value is required for "${e}"`);const r=t.types[0].type;if("StringLiteralTypeAnnotation"===r)return{type:"StringEnumTypeAnnotation",default:n,options:t.types.map(e=>e.value)};throw"NumberLiteralTypeAnnotation"===r?new Error(`Arrays of int enums are not supported (see: "${e}")`):new Error(`Unsupported union type for "${e}", received "${r}"`);default:throw new Error(`Unknown property type for "${e}": ${p}`)}}function flattenProperties(e,t,n){return e.map(e=>"ObjectTypeProperty"===e.type?e:"ObjectTypeSpreadProperty"===e.type?flattenProperties(n.getProperties(e.argument.id.name,t),t,n):void 0).reduce((e,t)=>Array.isArray(t)?(t.forEach(t=>{verifyPropNotAlreadyDefined(e,t)}),e.concat(t)):(verifyPropNotAlreadyDefined(e,t),e.push(t),e),[]).filter(Boolean)}function getTypeAnnotation(e,t,n,r,o,a,i){const p=getValueFromTypes(t,o);if("GenericTypeAnnotation"===p.type&&"$ReadOnlyArray"===a.getTypeAnnotationName(p))return{type:"ArrayTypeAnnotation",elementType:getTypeAnnotationForArray(e,p.typeParameters.params[0],n,o,a,i)};if("GenericTypeAnnotation"===p.type&&"$ReadOnly"===a.getTypeAnnotationName(p))return{type:"ObjectTypeAnnotation",properties:flattenProperties(p.typeParameters.params[0].properties,o,a).map(e=>i(e,o,a)).filter(Boolean)};const y="GenericTypeAnnotation"===p.type?a.getTypeAnnotationName(p):p.type;switch(y){case"ImageSource":return{type:"ReservedPropTypeAnnotation",name:"ImageSourcePrimitive"};case"ImageRequest":return{type:"ReservedPropTypeAnnotation",name:"ImageRequestPrimitive"};case"ColorValue":case"ProcessedColorValue":return{type:"ReservedPropTypeAnnotation",name:"ColorPrimitive"};case"ColorArrayValue":return{type:"ArrayTypeAnnotation",elementType:{type:"ReservedPropTypeAnnotation",name:"ColorPrimitive"}};case"PointValue":return{type:"ReservedPropTypeAnnotation",name:"PointPrimitive"};case"EdgeInsetsValue":return{type:"ReservedPropTypeAnnotation",name:"EdgeInsetsPrimitive"};case"DimensionValue":return{type:"ReservedPropTypeAnnotation",name:"DimensionPrimitive"};case"Int32":return{type:"Int32TypeAnnotation",default:n||0};case"Double":return{type:"DoubleTypeAnnotation",default:n||0};case"Float":return{type:"FloatTypeAnnotation",default:r?n:n||0};case"BooleanTypeAnnotation":return{type:"BooleanTypeAnnotation",default:(r||null!=n)&&n};case"StringTypeAnnotation":case"Stringish":if(void 0!==n)return{type:"StringTypeAnnotation",default:n};throw new Error(`A default string (or null) is required for "${e}"`);case"UnionTypeAnnotation":if(p.types.reduce((t,n)=>{if(t&&n.type!==t.type)throw new Error(`Mixed types are not supported (see "${e}").`);return n}),null===n)throw new Error(`A default enum value is required for "${e}"`);const t=p.types[0].type;if("StringLiteralTypeAnnotation"===t)return{type:"StringEnumTypeAnnotation",default:n,options:p.types.map(e=>e.value)};if("NumberLiteralTypeAnnotation"===t)return{type:"Int32EnumTypeAnnotation",default:n,options:p.types.map(e=>e.value)};throw new Error(`Unsupported union type for "${e}", received "${t}"`);case"ObjectTypeAnnotation":throw new Error(`Cannot use "${y}" type annotation for "${e}": object types must be declared using $ReadOnly<>`);case"NumberTypeAnnotation":throw new Error(`Cannot use "${y}" type annotation for "${e}": must use a specific numeric type like Int32, Double, or Float`);case"UnsafeMixed":return{type:"MixedTypeAnnotation"};default:throw new Error(`Unknown property type for "${e}": "${y}" in the State`)}}function getSchemaInfo(e,t,n){const r=e.key.name,o=getValueFromTypes(e.value,t);let a="NullableTypeAnnotation"===o.type?o.typeAnnotation:o,i=n.getTypeAnnotationName(a);const p="NullableTypeAnnotation"===o.type||e.optional||"GenericTypeAnnotation"===o.type&&"WithDefault"===i;if(!e.optional&&"GenericTypeAnnotation"===o.type&&"WithDefault"===i)throw new Error(`key ${r} must be optional if used with WithDefault<> annotation`);if("NullableTypeAnnotation"===o.type&&"GenericTypeAnnotation"===a.type&&"WithDefault"===i)throw new Error("WithDefault<> is optional and does not need to be marked as optional. Please remove the ? annotation in front of it.");let y=a.type;if("GenericTypeAnnotation"===y&&("DirectEventHandler"===i||"BubblingEventHandler"===i))return null;if("style"===r&&"GenericTypeAnnotation"===y&&"ViewStyleProp"===i)return null;let s=null,l=!1;if("GenericTypeAnnotation"===y&&"WithDefault"===i){if(1===a.typeParameters.params.length)throw new Error(`WithDefault requires two parameters, did you forget to provide a default value for "${r}"?`);s=a.typeParameters.params[1].value;const e=a.typeParameters.params[1].type;a=a.typeParameters.params[0],y="GenericTypeAnnotation"===a.type?i:a.type,"NullLiteralTypeAnnotation"===e&&(s=null,l=!0)}return{name:r,optional:p,typeAnnotation:a,defaultValue:s,withNullDefault:l}}module.exports={getSchemaInfo:getSchemaInfo,getTypeAnnotation:getTypeAnnotation,flattenProperties:flattenProperties};