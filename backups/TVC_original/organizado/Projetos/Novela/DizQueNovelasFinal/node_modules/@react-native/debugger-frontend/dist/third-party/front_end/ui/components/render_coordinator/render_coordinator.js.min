class e{promise;trigger;cancel;label;handler;constructor(e,n){const{promise:t,resolve:r,reject:o}=Promise.withResolvers();this.promise=t.then(()=>this.handler()),this.trigger=r,this.cancel=o,this.label=e,this.handler=n}}class t extends Event{static eventName="renderqueueempty";constructor(){super(t.eventName)}}class r extends Event{static eventName="newframe";constructor(){super(r.eventName)}}let n=null;const o=[];function i(e,t={}){e?n={onlyNamed:t.onlyNamed,storageLimit:t.storageLimit}:(n=null,o.length=0)}const a="Unnamed read",s="Unnamed write",l="Unnamed scroll",c=1500;globalThis.__getRenderCoordinatorPendingFrames=function(){return m()?1:0};let u=[],d=[],w=0;function m(){return u.length+d.length!==0}function f(e){return m()||e?.waitForWork?new Promise(e=>window.addEventListener(t.eventName,()=>e(),{once:!0})):(k("[Queue empty]"),Promise.resolve())}async function h(e,n){if("string"==typeof e){if(!n)throw new Error("Read called with label but no callback");return await v("read",e,n)}return await v("read",a,e)}async function g(e,n){if("string"==typeof e){if(!n)throw new Error("Write called with label but no callback");return await v("write",e,n)}return await v("write",s,e)}function p(){const e=[...o];return o.length=0,e}async function b(e,n){if("string"==typeof e){if(!n)throw new Error("Scroll called with label but no callback");return await v("read",e,n)}return await v("read",l,e)}function v(n,t,r){const o=![a,s,l].includes(t);t=`${"read"===n?"[Read]":"[Write]"}: ${t}`;let i=null;switch(n){case"read":i=u;break;case"write":i=d;break;default:throw new Error(`Unknown action: ${n}`)}let c=o?i.find(e=>e.label===t):void 0;return c?c.handler=r:(c=new e(t,r),i.push(c)),y(),c.promise}function y(){0===w&&(w=requestAnimationFrame(async()=>{if(!m())return window.dispatchEvent(new t),k("[Queue empty]"),void(w=0);window.dispatchEvent(new r),k("[New frame]");const e=u;u=[];const n=d;d=[];for(const n of e)k(n.label),n.trigger();try{await Promise.race([Promise.all(e.map(e=>e.promise)),new Promise((e,n)=>{window.setTimeout(()=>n(new Error("Readers took over 1500ms. Possible deadlock?")),c)})])}catch(n){E(e,n)}for(const e of n)k(e.label),e.trigger();try{await Promise.race([Promise.all(n.map(e=>e.promise)),new Promise((e,n)=>{window.setTimeout(()=>n(new Error("Writers took over 1500ms. Possible deadlock?")),c)})])}catch(e){E(n,e)}w=0,y()}))}function E(e,n){for(const t of e)t.cancel(n)}function P(){const e=new Error;E(u,e),E(d,e)}function k(e){if(null===n)return;if(n.onlyNamed&&(e.endsWith(a)||e.endsWith(s)||e.endsWith(l)))return;o.push({time:performance.now(),value:e});const t=n.storageLimit??100;for(;o.length>t;)o.shift()}export{r as RenderCoordinatorNewFrameEvent,t as RenderCoordinatorQueueEmptyEvent,P as cancelPending,f as done,m as hasPendingWork,h as read,b as scroll,i as setLoggingEnabled,p as takeLoggingRecords,g as write};