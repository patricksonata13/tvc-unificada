"use strict";const{ParserError:ParserError}=require("./errors"),path=require("path");function extractNativeModuleName(e){return path.basename(e).split(".")[0]}function createParserErrorCapturer(){const e=[];return[e,function(r){try{return r()}catch(r){if(!(r instanceof ParserError))throw r;return e.push(r),null}}]}function verifyPlatforms(e,r){let t=!1;const o=new Set;return[r,e].forEach(e=>{if(e.endsWith("Android"))o.add("iOS");else{if(!e.endsWith("IOS"))return e.endsWith("Windows")?(o.add("iOS"),void o.add("android")):e.endsWith("Cxx")?(t=!0,o.add("iOS"),void o.add("android")):void 0;o.add("android")}}),{cxxOnly:t,excludedPlatforms:Array.from(o)}}function visit(e,r){const t=[e];for(;0!==t.length;){let e=t.shift();"object"==typeof e&&null!=e&&("string"==typeof e.type&&"function"==typeof r[e.type]?r[e.type](e):Array.isArray(e)?t.push(...e):t.push(...Object.values(e)))}}function getConfigType(e,r){let t={isComponent:!1,isModule:!1};visit(e,r(t));const{isModule:o,isComponent:n}=t;if(o&&n)throw new Error('Found type extending "TurboModule" and exported "codegenNativeComponent" declaration in one file. Split them into separated files.');return o?"module":n?"component":"none"}function isModuleRegistryCall(e){if("CallExpression"!==e.type)return!1;const r=e;if("MemberExpression"!==r.callee.type)return!1;const t=r.callee;return"Identifier"===t.object.type&&"TurboModuleRegistry"===t.object.name&&("Identifier"===t.property.type&&("get"===t.property.name||"getEnforcing"===t.property.name)&&!t.computed)}function getSortedObject(e){return Object.keys(e).sort().reduce((r,t)=>(r[t]=e[t],r),{})}module.exports={getConfigType:getConfigType,extractNativeModuleName:extractNativeModuleName,createParserErrorCapturer:createParserErrorCapturer,verifyPlatforms:verifyPlatforms,visit:visit,isModuleRegistryCall:isModuleRegistryCall,getSortedObject:getSortedObject};