"use strict";function _os(){const e=require("os");return _os=function(){return e},e}function _worker_threads(){const e=require("worker_threads");return _worker_threads=function(){return e},e}function _mergeStream(){const e=_interopRequireDefault(require("merge-stream"));return _mergeStream=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _types=require("../types"),_WorkerAbstract=_interopRequireDefault(require("./WorkerAbstract"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class ExperimentalWorker extends _WorkerAbstract.default{_worker;_options;_request;_retries;_onProcessEnd;_onCustomMessage;_stdout;_stderr;_memoryUsagePromise;_resolveMemoryUsage;_childWorkerPath;_childIdleMemoryUsage;_childIdleMemoryUsageLimit;_memoryUsageCheck=!1;constructor(e){super(e),this._options=e,this._request=null,this._stdout=null,this._stderr=null,this._childWorkerPath=e.childWorkerPath||require.resolve("./threadChild"),this._childIdleMemoryUsage=null,this._childIdleMemoryUsageLimit=e.idleMemoryLimit||null,this.initialize()}initialize(){if(this.state!==_types.WorkerStates.OUT_OF_MEMORY&&this.state!==_types.WorkerStates.SHUTTING_DOWN&&this.state!==_types.WorkerStates.SHUT_DOWN){if(this._worker&&this._worker.terminate(),this.state=_types.WorkerStates.STARTING,this._worker=new(_worker_threads().Worker)(this._childWorkerPath,{eval:!1,resourceLimits:this._options.resourceLimits,stderr:!0,stdout:!0,workerData:this._options.workerData,...this._options.forkOptions}),this._worker.stdout&&(this._stdout||(this._stdout=(0,_mergeStream().default)(this._getFakeStream())),this._stdout.add(this._worker.stdout)),this._worker.stderr&&(this._stderr||(this._stderr=(0,_mergeStream().default)(this._getFakeStream())),this._stderr.add(this._worker.stderr)),(this._options.silent??1)||(this._worker.stdout.setEncoding("utf8"),this._worker.stdout.on("data",console.log),this._worker.stderr.setEncoding("utf8"),this._worker.stderr.on("data",console.error)),this._worker.on("message",this._onMessage.bind(this)),this._worker.on("exit",this._onExit.bind(this)),this._worker.on("error",this._onError.bind(this)),this._worker.postMessage([_types.CHILD_MESSAGE_INITIALIZE,!1,this._options.workerPath,this._options.setupArgs,String(this._options.workerId+1)]),this._retries++,this._retries>this._options.maxRetries){const e=new Error("Call retries were exceeded");this._onMessage([_types.PARENT_MESSAGE_CLIENT_ERROR,e.name,e.message,e.stack,{type:"WorkerError"}])}this.state=_types.WorkerStates.OK,this._resolveWorkerReady&&this._resolveWorkerReady()}}_onError(e){e.message.includes("heap out of memory")&&(this.state=_types.WorkerStates.OUT_OF_MEMORY,this._worker.terminate())}_onMessage(e){if(!Array.isArray(e))return;let t;switch(e[0]){case _types.PARENT_MESSAGE_OK:this._onProcessEnd(null,e[1]);break;case _types.PARENT_MESSAGE_CLIENT_ERROR:if(t=e[4],null!=t&&"object"==typeof t){const r=t,s=globalThis[e[1]];t=new("function"==typeof s?s:Error)(e[2]),t.type=e[1],t.stack=e[3];for(const e in r)t[e]=r[e]}this._onProcessEnd(t,null);break;case _types.PARENT_MESSAGE_SETUP_ERROR:t=new Error(`Error when calling setup: ${e[2]}`),t.type=e[1],t.stack=e[3],this._onProcessEnd(t,null);break;case _types.PARENT_MESSAGE_CUSTOM:this._onCustomMessage(e[1]);break;case _types.PARENT_MESSAGE_MEM_USAGE:this._childIdleMemoryUsage=e[1],this._resolveMemoryUsage&&(this._resolveMemoryUsage(e[1]),this._resolveMemoryUsage=void 0,this._memoryUsagePromise=void 0),this._performRestartIfRequired()}}_onExit(e){if(this._workerReadyPromise=void 0,this._resolveWorkerReady=void 0,0!==e&&this.state===_types.WorkerStates.OUT_OF_MEMORY)this._onProcessEnd(new Error("Jest worker ran out of memory and crashed"),null),this._shutdown();else if(0!==e&&this.state!==_types.WorkerStates.SHUTTING_DOWN&&this.state!==_types.WorkerStates.SHUT_DOWN||this.state===_types.WorkerStates.RESTARTING)this.initialize(),this._request&&this._worker.postMessage(this._request);else{!!this._request&&this._onProcessEnd(new Error("A Jest worker thread exited unexpectedly before finishing tests for an unknown reason. One of the ways this can happen is if process.exit() was called in testing code."),null),this._shutdown()}}waitForExit(){return this._exitPromise}forceExit(){this.state=_types.WorkerStates.SHUTTING_DOWN,this._worker.terminate()}send(e,t,r,s){t(this),this._onProcessEnd=(...e)=>{const t=!!this._request;this._request=null,this._childIdleMemoryUsageLimit&&t&&this.checkMemoryUsage();const s=r?.(...e);return r=null,s},this._onCustomMessage=(...e)=>s(...e),this._request=e,this._retries=0,this._worker.postMessage(e)}getWorkerId(){return this._options.workerId}getStdout(){return this._stdout}getStderr(){return this._stderr}_performRestartIfRequired(){if(this._memoryUsageCheck){this._memoryUsageCheck=!1;let e=this._childIdleMemoryUsageLimit;e&&e>0&&e<=1?e=Math.floor((0,_os().totalmem)()*e):e&&(e=Math.floor(e)),e&&this._childIdleMemoryUsage&&this._childIdleMemoryUsage>e&&(this.state=_types.WorkerStates.RESTARTING,this._worker.terminate())}}getMemoryUsage(){if(!this._memoryUsagePromise){let e;const t=new Promise((t,r)=>{this._resolveMemoryUsage=t,e=r});if(this._memoryUsagePromise=t,!this._worker.threadId)return e(new Error("Child process is not running.")),this._memoryUsagePromise=void 0,this._resolveMemoryUsage=void 0,t;try{this._worker.postMessage([_types.CHILD_MESSAGE_MEM_USAGE])}catch(t){this._memoryUsagePromise=void 0,this._resolveMemoryUsage=void 0,e(t)}return t}return this._memoryUsagePromise}checkMemoryUsage(){this._childIdleMemoryUsageLimit?(this._memoryUsageCheck=!0,this._worker.postMessage([_types.CHILD_MESSAGE_MEM_USAGE])):console.warn("Memory usage of workers can only be checked if a limit is set")}getWorkerSystemId(){return this._worker.threadId}isWorkerRunning(){return this._worker.threadId>=0}}exports.default=ExperimentalWorker;