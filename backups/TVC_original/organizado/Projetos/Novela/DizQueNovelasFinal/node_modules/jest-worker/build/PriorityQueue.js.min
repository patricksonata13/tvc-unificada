"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;class PriorityQueue{_queue=[];_sharedQueue=new MinHeap;constructor(e){this._computePriority=e}enqueue(e,t){if(null==t)this._enqueue(e,this._sharedQueue);else{const u=this._getWorkerQueue(t);this._enqueue(e,u)}}_enqueue(e,t){const u={priority:this._computePriority(e.request[2],...e.request[3]),task:e};t.add(u)}dequeue(e){const t=this._getWorkerQueue(e),u=t.peek(),r=this._sharedQueue.peek();return null==r||null!=u&&u.priority<=r.priority?t.poll()?.task??null:this._sharedQueue.poll().task}_getWorkerQueue(e){let t=this._queue[e];return null==t&&(t=this._queue[e]=new MinHeap),t}}exports.default=PriorityQueue;class MinHeap{_heap=[];peek(){return this._heap[0]??null}add(e){const t=this._heap;if(t.push(e),1===t.length)return;let u=t.length-1;for(;u>0;){const r=Math.floor((u+1)/2)-1,i=t[r];if(i.priority<=e.priority)break;t[u]=i,t[r]=e,u=r}}poll(){const e=this._heap,t=e[0],u=e.pop();if(null==t||0===e.length)return t??null;let r=0;e[0]=u??null;const i=e[0];for(;;){let t=null;const u=2*(r+1),l=u-1,s=e[u],n=e[l];if(null!=n&&n.priority<i.priority&&(t=l),null!=s&&s.priority<(null==t?i:n).priority&&(t=u),null==t)break;e[r]=e[t],e[t]=i,r=t}return t}}