"use strict";function _child_process(){const e=require("child_process");return _child_process=function(){return e},e}function _os(){const e=require("os");return _os=function(){return e},e}function _mergeStream(){const e=_interopRequireDefault(require("merge-stream"));return _mergeStream=function(){return e},e}function _supportsColor(){const e=require("supports-color");return _supportsColor=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.SIGKILL_DELAY=void 0;var _types=require("../types"),_WorkerAbstract=_interopRequireDefault(require("./WorkerAbstract"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}const SIGNAL_BASE_EXIT_CODE=128,SIGKILL_EXIT_CODE=137,SIGTERM_EXIT_CODE=143,SIGKILL_DELAY=500;exports.SIGKILL_DELAY=500;class ChildProcessWorker extends _WorkerAbstract.default{_child;_options;_request;_retries;_onProcessEnd;_onCustomMessage;_stdout;_stderr;_stderrBuffer=[];_memoryUsagePromise;_resolveMemoryUsage;_childIdleMemoryUsage;_childIdleMemoryUsageLimit;_memoryUsageCheck=!1;_childWorkerPath;constructor(e){super(e),this._options=e,this._request=null,this._stdout=null,this._stderr=null,this._childIdleMemoryUsage=null,this._childIdleMemoryUsageLimit=e.idleMemoryLimit||null,this._childWorkerPath=e.childWorkerPath||require.resolve("./processChild"),this.state=_types.WorkerStates.STARTING,this.initialize()}initialize(){if(this.state===_types.WorkerStates.OUT_OF_MEMORY||this.state===_types.WorkerStates.SHUTTING_DOWN||this.state===_types.WorkerStates.SHUT_DOWN)return;this._child&&this._child.connected&&this._child.kill("SIGKILL"),this.state=_types.WorkerStates.STARTING;const e=_supportsColor().stdout?{FORCE_COLOR:"1"}:{},t=this._options.silent??!0;t||console.warn("Unable to detect out of memory event if silent === false"),this._stderrBuffer=[];const s={cwd:process.cwd(),env:{...process.env,JEST_WORKER_ID:String(this._options.workerId+1),...e},execArgv:process.execArgv.filter(e=>!/^--(debug|inspect)/.test(e)),serialization:"advanced",silent:t,...this._options.forkOptions};if(this._child=(0,_child_process().fork)(this._childWorkerPath,[],s),this._child.stdout&&(this._stdout||(this._stdout=(0,_mergeStream().default)(this._getFakeStream())),this._stdout.add(this._child.stdout)),this._child.stderr&&(this._stderr||(this._stderr=(0,_mergeStream().default)(this._getFakeStream())),this._stderr.add(this._child.stderr),this._child.stderr.on("data",this.stderrDataHandler.bind(this))),this._child.on("message",this._onMessage.bind(this)),this._child.on("exit",this._onExit.bind(this)),this._child.on("disconnect",this._onDisconnect.bind(this)),this._child.send([_types.CHILD_MESSAGE_INITIALIZE,!1,this._options.workerPath,this._options.setupArgs]),this._retries++,this._retries>this._options.maxRetries){const e=new Error(`Jest worker encountered ${this._retries} child process exceptions, exceeding retry limit`);this._onMessage([_types.PARENT_MESSAGE_CLIENT_ERROR,e.name,e.message,e.stack,{type:"WorkerError"}]),this._request=null}this.state=_types.WorkerStates.OK,this._resolveWorkerReady&&this._resolveWorkerReady()}stderrDataHandler(e){e&&this._stderrBuffer.push(Buffer.from(e)),this._detectOutOfMemoryCrash(),this.state===_types.WorkerStates.OUT_OF_MEMORY&&(this._workerReadyPromise=void 0,this._resolveWorkerReady=void 0,this.killChild(),this._shutdown())}_detectOutOfMemoryCrash(){try{const e=Buffer.concat(this._stderrBuffer).toString("utf8");(e.includes("heap out of memory")||e.includes("allocation failure;")||e.includes("Last few GCs"))&&(this.state!==_types.WorkerStates.OK&&this.state!==_types.WorkerStates.STARTING||(this.state=_types.WorkerStates.OUT_OF_MEMORY))}catch(e){console.error("Error looking for out of memory crash",e)}}_onDisconnect(){this._workerReadyPromise=void 0,this._resolveWorkerReady=void 0,this._detectOutOfMemoryCrash(),this.state===_types.WorkerStates.OUT_OF_MEMORY&&(this.killChild(),this._shutdown())}_onMessage(e){if(!Array.isArray(e))return;let t;switch(e[0]){case _types.PARENT_MESSAGE_OK:this._onProcessEnd(null,e[1]);break;case _types.PARENT_MESSAGE_CLIENT_ERROR:if(t=e[4],null!=t&&"object"==typeof t){const s=t,r=globalThis[e[1]];t=new("function"==typeof r?r:Error)(e[2]),t.type=e[1],t.stack=e[3];for(const e in s)t[e]=s[e]}this._onProcessEnd(t,null);break;case _types.PARENT_MESSAGE_SETUP_ERROR:t=new Error(`Error when calling setup: ${e[2]}`),t.type=e[1],t.stack=e[3],this._onProcessEnd(t,null);break;case _types.PARENT_MESSAGE_CUSTOM:this._onCustomMessage(e[1]);break;case _types.PARENT_MESSAGE_MEM_USAGE:this._childIdleMemoryUsage=e[1],this._resolveMemoryUsage&&(this._resolveMemoryUsage(e[1]),this._resolveMemoryUsage=void 0,this._memoryUsagePromise=void 0),this._performRestartIfRequired()}}_performRestartIfRequired(){if(this._memoryUsageCheck){this._memoryUsageCheck=!1;let e=this._childIdleMemoryUsageLimit;e&&e>0&&e<=1?e=Math.floor((0,_os().totalmem)()*e):e&&(e=Math.floor(e)),e&&this._childIdleMemoryUsage&&this._childIdleMemoryUsage>e&&(this.state=_types.WorkerStates.RESTARTING,this.killChild())}}_onExit(e,t){if(this._workerReadyPromise=void 0,this._resolveWorkerReady=void 0,this._detectOutOfMemoryCrash(),0!==e&&this.state===_types.WorkerStates.OUT_OF_MEMORY)this._onProcessEnd(new Error("Jest worker ran out of memory and crashed"),null),this._shutdown();else if(0!==e&&null!==e&&143!==e&&137!==e&&this.state!==_types.WorkerStates.SHUTTING_DOWN||this.state===_types.WorkerStates.RESTARTING)this.state=_types.WorkerStates.RESTARTING,this.initialize(),this._request&&this._child.send(this._request);else{if(!!this._request){const s=new Error(null!=t?`A jest worker process (pid=${this._child.pid}) was terminated by another process: signal=${t}, exitCode=${e}. Operating system logs may contain more information on why this occurred.`:`A jest worker process (pid=${this._child.pid}) crashed for an unknown reason: exitCode=${e}`);this._onProcessEnd(s,null)}this._shutdown()}}send(e,t,s,r){this._stderrBuffer=[],t(this),this._onProcessEnd=(...e)=>{const t=!!this._request;return this._request=null,this._childIdleMemoryUsageLimit&&this._child.connected&&t&&this.checkMemoryUsage(),s(...e)},this._onCustomMessage=(...e)=>r(...e),this._request=e,this._retries=0,this._child.send(e,()=>{})}waitForExit(){return this._exitPromise}killChild(){const e=this._child;return e.kill("SIGTERM"),setTimeout(()=>e.kill("SIGKILL"),500)}forceExit(){this.state=_types.WorkerStates.SHUTTING_DOWN;const e=this.killChild();this._exitPromise.then(()=>clearTimeout(e))}getWorkerId(){return this._options.workerId}getWorkerSystemId(){return this._child.pid}getStdout(){return this._stdout}getStderr(){return this._stderr}getMemoryUsage(){if(!this._memoryUsagePromise){let e;const t=new Promise((t,s)=>{this._resolveMemoryUsage=t,e=s});return this._memoryUsagePromise=t,!this._child.connected&&e?(e(new Error("Child process is not running.")),this._memoryUsagePromise=void 0,this._resolveMemoryUsage=void 0,t):(this._child.send([_types.CHILD_MESSAGE_MEM_USAGE],t=>{t&&e&&(this._memoryUsagePromise=void 0,this._resolveMemoryUsage=void 0,e(t))}),t)}return this._memoryUsagePromise}checkMemoryUsage(){this._childIdleMemoryUsageLimit?(this._memoryUsageCheck=!0,this._child.send([_types.CHILD_MESSAGE_MEM_USAGE],e=>{e&&console.error("Unable to check memory usage",e)})):console.warn("Memory usage of workers can only be checked if a limit is set")}isWorkerRunning(){return this._child.connected&&!this._child.killed}}exports.default=ChildProcessWorker;