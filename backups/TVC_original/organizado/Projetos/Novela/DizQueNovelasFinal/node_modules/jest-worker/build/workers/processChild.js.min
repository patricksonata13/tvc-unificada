"use strict";function _jestUtil(){const e=require("jest-util");return _jestUtil=function(){return e},e}var _types=require("../types");let file=null,setupArgs=[],initialized=!1;const messageListener=e=>{switch(e[0]){case _types.CHILD_MESSAGE_INITIALIZE:const r=e;file=r[2],setupArgs=r[3];break;case _types.CHILD_MESSAGE_CALL:const s=e;execMethod(s[2],s[3]);break;case _types.CHILD_MESSAGE_END:end();break;case _types.CHILD_MESSAGE_MEM_USAGE:reportMemoryUsage();break;case _types.CHILD_MESSAGE_CALL_SETUP:if(initialized)reportSuccess(void 0);else{const e=require(file);initialized=!0,e.setup?execFunction(e.setup,e,setupArgs,reportSuccess,reportInitializeError):reportSuccess(void 0)}break;default:throw new TypeError(`Unexpected request from parent process: ${e[0]}`)}};function reportSuccess(e){if(!process||!process.send)throw new Error("Child can only be used on a forked process");process.send([_types.PARENT_MESSAGE_OK,e])}function reportClientError(e){return reportError(e,_types.PARENT_MESSAGE_CLIENT_ERROR)}function reportInitializeError(e){return reportError(e,_types.PARENT_MESSAGE_SETUP_ERROR)}function reportMemoryUsage(){if(!process||!process.send)throw new Error("Child can only be used on a forked process");const e=[_types.PARENT_MESSAGE_MEM_USAGE,process.memoryUsage().heapUsed];process.send(e)}function reportError(e,r){if(!process||!process.send)throw new Error("Child can only be used on a forked process");null==e&&(e=new Error('"null" or "undefined" thrown')),process.send([r,e.constructor&&e.constructor.name,e.message,e.stack,"object"==typeof e?{...e}:e])}function end(){const e=require(file);e.teardown?execFunction(e.teardown,e,[],exitProcess,exitProcess):exitProcess()}function exitProcess(){process.removeListener("message",messageListener)}function execMethod(e,r){const s=require(file);let t;function o(){execFunction(t,s,r,reportSuccess,reportClientError)}t="default"===e?s.__esModule?s.default:s:s[e],!initialized&&s.setup?(initialized=!0,execFunction(s.setup,s,setupArgs,o,reportInitializeError)):o()}function execFunction(e,r,s,t,o){let n;try{n=e.apply(r,s)}catch(e){return void o(e)}(0,_jestUtil().isPromise)(n)?n.then(t,o):t(n)}process.on("message",messageListener);