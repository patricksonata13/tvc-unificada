import{AsyncLocalStorage}from"node:async_hooks";import{Readable}from"node:stream";import{pipeline}from"node:stream/promises";import{createRequestHandler as createExpoHandler}from"./abstract";import{createNodeEnv,createNodeRequestScope}from"./environment/node";export{ExpoError}from"./abstract";const STORE=new AsyncLocalStorage;export function createRequestHandler(e,t){const r=createNodeRequestScope(STORE,e),o=createExpoHandler({...createNodeEnv(e),...t});return async(e,n,a)=>{if(!e?.url||!e.method)return a();try{const a=convertRequest(e,n),s=await async function(e){try{return await r(o,e)}catch(e){const r=t?.handleRouteError;if(r&&null!=e&&"object"==typeof e)try{return await r(e)}catch{}throw e}}(a);await respond(n,s)}catch(e){a(e)}}}export function convertHeaders(e){const t=new Headers;for(const[r,o]of Object.entries(e))if(o)if(Array.isArray(o))for(const e of o)t.append(r,e);else t.set(r,o);return t}function convertRawHeaders(e){const t=new Headers;for(let r=0;r<e.length;r+=2)t.append(e[r],e[r+1]);return t}export function convertRequest(e,t){const r=new URL(`${e.protocol}://${e.get("host")}${e.url}`),o=new AbortController;t.on("close",()=>o.abort());const n={method:e.method,headers:convertRawHeaders(e.rawHeaders),signal:o.signal};return"GET"!==e.method&&"HEAD"!==e.method&&(n.body=Readable.toWeb(e),n.duplex="half"),new Request(r.href,n)}export async function respond(e,t){if(e.statusMessage=t.statusText,e.status(t.status),"function"==typeof e.setHeaders)e.setHeaders(t.headers);else for(const[r,o]of t.headers.entries())e.appendHeader(r,o);t.body?await pipeline(Readable.fromWeb(t.body),e):e.end()}