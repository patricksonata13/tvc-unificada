import{Readable}from"node:stream";import{pipeline}from"node:stream/promises";import{createRequestHandler as createExpoHandler}from"./abstract";import{createRequestScope}from"../runtime";import{createNodeEnv}from"./environment/node";import{createReadableStreamFromReadable}from"../utils/createReadableStreamFromReadable";export{ExpoError}from"./abstract";const scopeSymbol=Symbol.for("expoServerScope"),SYMBOL_FOR_REQ_CONTEXT=Symbol.for("@vercel/request-context");function getContext(){const e=globalThis;return e[SYMBOL_FOR_REQ_CONTEXT]?.get?.()??{}}const STORE={getStore:()=>getContext()[scopeSymbol],run:(e,t,...r)=>(getContext()[scopeSymbol]=e,t(...r))};export function createRequestHandler(e){const t=createRequestScope(STORE,e=>{const t=e.headers.get("host"),r=e.headers.get("x-forwarded-proto")||"https";return{origin:t?`${r}://${t}`:"null",environment:process.env.VERCEL_ENV??process.env.NODE_ENV,waitUntil:getContext().waitUntil}}),r=createExpoHandler(createNodeEnv(e));return async(e,o)=>respond(o,await t(r,convertRequest(e,o)))}export function convertHeaders(e){const t=new Headers;for(const[r,o]of Object.entries(e))if(o)if(Array.isArray(o))for(const e of o)t.append(r,e);else t.set(r,o);return t}function convertRawHeaders(e){const t=new Headers;for(let r=0;r<e.length;r+=2)t.append(e[r],e[r+1]);return t}export function convertRequest(e,t){const r=e.headers["x-forwarded-host"]||e.headers.host,o=e.headers["x-forwarded-proto"]||"https",a=new URL(`${o}://${r}${e.url}`),n=new AbortController;t.on("close",()=>n.abort());const s={method:e.method,headers:convertRawHeaders(e.rawHeaders),signal:n.signal};return"GET"!==e.method&&"HEAD"!==e.method&&(s.body=createReadableStreamFromReadable(e),s.duplex="half"),new Request(a.href,s)}export async function respond(e,t){e.statusMessage=t.statusText,e.writeHead(t.status,t.statusText,[...t.headers.entries()].flat()),t.body?await pipeline(Readable.fromWeb(t.body),e):e.end()}