"use strict";function _crypto(){const e=require("crypto");return _crypto=function(){return e},e}function path(){const e=_interopRequireWildcard(require("path"));return path=function(){return e},e}function _core(){const e=require("@babel/core");return _core=function(){return e},e}function _chalk(){const e=_interopRequireDefault(require("chalk"));return _chalk=function(){return e},e}function fs(){const e=_interopRequireWildcard(require("graceful-fs"));return fs=function(){return e},e}function _slash(){const e=_interopRequireDefault(require("slash"));return _slash=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.createTransformer=void 0;var _loadBabelConfig=require("./loadBabelConfig");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(_getRequireWildcardCache=function(e){return e?r:t})(e)}function _interopRequireWildcard(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=_getRequireWildcardCache(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var s=o?Object.getOwnPropertyDescriptor(e,a):null;s&&(s.get||s.set)?Object.defineProperty(n,a,s):n[a]=e[a]}return n.default=e,r&&r.set(e,n),n}const THIS_FILE=fs().readFileSync(__filename),jestPresetPath=require.resolve("babel-preset-jest"),babelIstanbulPlugin=require.resolve("babel-plugin-istanbul");function assertLoadedBabelConfig(e,t,r){if(!e)throw new Error(`babel-jest: Babel ignores ${_chalk().default.bold((0,_slash().default)(path().relative(t,r)))} - make sure to include the file in Jest's ${_chalk().default.bold("transformIgnorePatterns")} as well.`)}function addIstanbulInstrumentation(e,t){if(t.instrument){const r={...e};return r.auxiliaryCommentBefore=" istanbul ignore next ",r.plugins=(r.plugins??[]).concat([[babelIstanbulPlugin,{cwd:t.config.cwd,exclude:[]}]]),r}return e}function getCacheKeyFromConfig(e,t,r,n){const{config:o,configString:a,instrument:s}=n,u=[r.config??"",r.babelrc??""];return(0,_crypto().createHash)("sha1").update(THIS_FILE).update("\0","utf8").update(JSON.stringify(r.options)).update("\0","utf8").update(e).update("\0","utf8").update(path().relative(o.rootDir,t)).update("\0","utf8").update(a).update("\0","utf8").update(u.join("")).update("\0","utf8").update(s?"instrument":"").update("\0","utf8").update(process.env.NODE_ENV??"").update("\0","utf8").update(process.env.BABEL_ENV??"").update("\0","utf8").update(process.version).digest("hex").substring(0,32)}function loadBabelConfig(e,t,r){const n=(0,_loadBabelConfig.loadPartialConfig)(r);return assertLoadedBabelConfig(n,e,t),n}async function loadBabelConfigAsync(e,t,r){const n=await(0,_loadBabelConfig.loadPartialConfigAsync)(r);return assertLoadedBabelConfig(n,e,t),n}function loadBabelOptions(e,t,r,n){const{options:o}=loadBabelConfig(e,t,r);return addIstanbulInstrumentation(o,n)}async function loadBabelOptionsAsync(e,t,r,n){const{options:o}=await loadBabelConfigAsync(e,t,r);return addIstanbulInstrumentation(o,n)}const createTransformer=e=>{const t=e??{},r={...t,caller:{name:"babel-jest",supportsDynamicImport:!1,supportsExportNamespaceFrom:!1,supportsStaticESM:!1,supportsTopLevelAwait:!1,...t.caller},compact:!1,plugins:t.plugins??[],presets:(t.presets??[]).concat(jestPresetPath),sourceMaps:"both"};function n(e,t){const{cwd:n,rootDir:o}=t.config;return{cwd:n,root:o,...r,caller:{...r.caller,supportsDynamicImport:t.supportsDynamicImport??r.caller.supportsDynamicImport,supportsExportNamespaceFrom:t.supportsExportNamespaceFrom??r.caller.supportsExportNamespaceFrom,supportsStaticESM:t.supportsStaticESM??r.caller.supportsStaticESM,supportsTopLevelAwait:t.supportsTopLevelAwait??r.caller.supportsTopLevelAwait},filename:e}}return{canInstrument:!0,getCacheKey:(e,t,r)=>getCacheKeyFromConfig(e,t,loadBabelConfig(r.config.cwd,t,n(t,r)),r),getCacheKeyAsync:async(e,t,r)=>getCacheKeyFromConfig(e,t,await loadBabelConfigAsync(r.config.cwd,t,n(t,r)),r),process(e,t,r){const o=loadBabelOptions(r.config.cwd,t,n(t,r),r),a=(0,_core().transformSync)(e,o);if(a){const{code:e,map:t}=a;if("string"==typeof e)return{code:e,map:t}}return{code:e}},async processAsync(e,t,r){const o=await loadBabelOptionsAsync(r.config.cwd,t,n(t,r),r),a=await(0,_core().transformAsync)(e,o);if(a){const{code:e,map:t}=a;if("string"==typeof e)return{code:e,map:t}}return{code:e}}}};exports.createTransformer=createTransformer;const transformerFactory={createTransformer:createTransformer};var _default=transformerFactory;exports.default=_default;