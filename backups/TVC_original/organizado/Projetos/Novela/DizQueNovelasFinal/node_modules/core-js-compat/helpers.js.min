"use strict";const has=Object.hasOwn||Function.call.bind({}.hasOwnProperty),VERSION_PATTERN=/(\d+)(?:\.(\d+))?(?:\.(\d+))?/;class SemVer{constructor(e){const t=VERSION_PATTERN.exec(e);if(!t)throw new TypeError(`Invalid version: ${e}`);const[,r,n,s]=t;this.major=+r,this.minor=n?+n:0,this.patch=s?+s:0}toString(){return`${this.major}.${this.minor}.${this.patch}`}}function semver(e){return e instanceof SemVer?e:new SemVer(e)}function compare(e,t,r){const n=semver(e),s=semver(r);for(const e of["major","minor","patch"]){if(n[e]<s[e])return"<"===t||"<="===t||"!="===t;if(n[e]>s[e])return">"===t||">="===t||"!="===t}return"=="===t||"<="===t||">="===t}function filterOutStabilizedProposals(e){const t=new Set(e);for(const e of t)e.startsWith("esnext.")&&t.has(e.replace(/^esnext\./,"es."))&&t.delete(e);return[...t]}function intersection(e,t){const r=e instanceof Set?e:new Set(e);return t.filter(e=>r.has(e))}function sortObjectByKey(e,t){return Object.keys(e).sort(t).reduce((t,r)=>(t[r]=e[r],t),{})}module.exports={compare:compare,filterOutStabilizedProposals:filterOutStabilizedProposals,has:has,intersection:intersection,semver:semver,sortObjectByKey:sortObjectByKey};