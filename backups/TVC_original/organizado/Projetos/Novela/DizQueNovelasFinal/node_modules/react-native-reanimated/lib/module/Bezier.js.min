"use strict";import{ReanimatedError}from"./common";const NEWTON_ITERATIONS=4,NEWTON_MIN_SLOPE=.001,SUBDIVISION_PRECISION=1e-7,SUBDIVISION_MAX_ITERATIONS=10,kSplineTableSize=11,kSampleStepSize=.1;function A(e,n){return 1-3*n+3*e}function B(e,n){return 3*n-6*e}function C(e){return 3*e}function calcBezier(e,n,r){return((A(n,r)*e+B(n,r))*e+C(n))*e}function getSlope(e,n,r){return 3*A(n,r)*e*e+2*B(n,r)*e+C(n)}function binarySubdivide(e,n,r,t,i){let o,u,c=0;do{u=n+(r-n)/2,o=calcBezier(u,t,i)-e,o>0?r=u:n=u}while(Math.abs(o)>1e-7&&++c<10);return u}function newtonRaphsonIterate(e,n,r,t){for(let i=0;i<4;++i){const i=getSlope(n,r,t);if(0===i)return n;n-=(calcBezier(n,r,t)-e)/i}return n}export function Bezier(e,n,r,t){if(!(e>=0&&e<=1&&r>=0&&r<=1))throw new ReanimatedError("Bezier x values must be in [0, 1] range.");if(e===n&&r===t)return function(e){return e};const i=new Array(11);for(let n=0;n<11;++n)i[n]=calcBezier(.1*n,e,r);return function(o){return e===n&&r===t?o:0===o?0:1===o?1:calcBezier(function(n){let t=0,o=1;for(;10!==o&&i[o]<=n;++o)t+=.1;--o;const u=t+(n-i[o])/(i[o+1]-i[o])*.1,c=getSlope(u,e,r);return c>=.001?newtonRaphsonIterate(n,u,e,r):0===c?u:binarySubdivide(n,t,t+.1,e,r)}(o),n,t)}}