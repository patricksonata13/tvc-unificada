"use strict";import{ColorProperties}from"../Colors";import{logger,processColor}from"../common";import{withTiming}from"./timing";import{defineAnimation,isValidLayoutAnimationProp}from"./util";function resolvePath(t,e){return(Array.isArray(e)?e:[e]).reduce((t,e)=>Array.isArray(t)&&"number"==typeof e||null!==t&&"object"==typeof t&&e in t?t[e]:void 0,t)}function setPath(t,e,o){const a=Array.isArray(e)?e:[e];let r=t;for(let t=0;t<a.length-1;t++)a[t]in r||("number"==typeof a[t+1]?r[a[t]]=[]:r[a[t]]={}),r=r[a[t]];r[a[a.length-1]]=o}export function withStyleAnimation(t){return defineAnimation({},()=>({isHigherOrder:!0,onFrame:(t,e)=>{let o=!1;const a=[{value:t.styleAnimations,path:[]}];for(;a.length>0;){const r=a.pop();if(Array.isArray(r.value))for(let t=0;t<r.value.length;t++)a.push({value:r.value[t],path:r.path.concat(t)});else if("object"==typeof r.value&&void 0===r.value.onFrame)for(const t of Object.keys(r.value))a.push({value:r.value[t],path:r.path.concat(t)});else{const a=r.value;if(a.finished)continue;a.onFrame(a,e)?(a.finished=!0,a.callback&&a.callback(!0)):o=!0;const n=ColorProperties.includes(r.path[0]);setPath(t.current,r.path,n?processColor(a.current):a.current)}}return!o},onStart:(e,o,a,r)=>{const n=[{value:t,path:[]}];for(;n.length>0;){const t=n.pop();if(Array.isArray(t.value))for(let e=0;e<t.value.length;e++)n.push({value:t.value[e],path:t.path.concat(e)});else if("object"==typeof t.value&&void 0===t.value.onStart)for(const e of Object.keys(t.value))n.push({value:t.value[e],path:t.path.concat(e)});else{const n=resolvePath(r?.styleAnimations,t.path);let i,l=resolvePath(o,t.path);if(n&&!l&&(l=n.current),__DEV__){void 0===l&&logger.warn(`Initial values for animation are missing for property ${t.path.join(".")}`);const e=t.path[0];"string"!=typeof e||isValidLayoutAnimationProp(e.trim())||logger.warn(`'${e}' property is not officially supported for layout animations. It may not work as expected.`)}setPath(e.current,t.path,l),"object"==typeof t.value&&t.value.onStart?i=t.value:(i=withTiming(t.value,{duration:0}),setPath(e.styleAnimations,t.path,i)),i.onStart(i,l,a,n)}}},current:{},styleAnimations:t,callback:e=>{if(!e){const e=[t];for(;e.length>0;){const t=e.pop();if(Array.isArray(t))for(const o of t)e.push(o);else if("object"==typeof t&&void 0===t.onStart)for(const o of Object.values(t))e.push(o);else{const e=t;!e.finished&&e.callback&&e.callback(!1)}}}}}))}