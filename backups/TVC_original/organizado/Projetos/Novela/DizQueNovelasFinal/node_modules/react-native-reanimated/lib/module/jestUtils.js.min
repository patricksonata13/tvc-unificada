"use strict";import{IS_JEST,logger,ReanimatedError}from"./common";const defaultFramerateConfig={fps:60},isEmpty=e=>!e||0===Object.keys(e).length,getStylesFromObject=e=>void 0===e?{}:Object.fromEntries(Object.entries(e).map(([e,t])=>[e,t._isReanimatedSharedValue?t.value:t])),getCurrentProps=e=>{const t=e.props.jestAnimatedProps?.value;return t?{...t}:{}},getCurrentStyle=e=>{const t=e.props.style;let r={};Array.isArray(t)&&t.forEach(e=>{r={...r,...e}});const s=e.props.jestInlineStyle,n=e.props.jestAnimatedStyle?.value;if(Array.isArray(s)){for(const e of s){if("jestAnimatedValues"in e)continue;const t=getStylesFromObject(e);r={...r,...t}}return r={...r,...n},r}const o=getStylesFromObject(s);return r=isEmpty(n)?{...o}:{...n},r},checkEqual=(e,t)=>{if(Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return!1;for(let r=0;r<e.length;r++)if(!checkEqual(e[r],t[r]))return!1}else{if("object"!=typeof e||!e)return e===t;if("object"!=typeof t||!t)return!1;for(const r in t)if(!checkEqual(e[r],t[r]))return!1}return!0},findStyleDiff=(e,t,r)=>{const s=[];let n,o=!0;for(n in t)checkEqual(e[n],t[n])||(o=!1,s.push({property:n,current:e[n],expect:t[n]}));if(r&&Object.keys(e).length!==Object.keys(t).length){let r;for(r in o=!1,e)void 0===t[r]&&s.push({property:r,current:e[r],expect:t[r]})}return{isEqual:o,diffs:s}},compareAndFormatDifferences=(e,t,r=!1)=>{const{isEqual:s,diffs:n}=findStyleDiff(e,t,r);if(s)return{message:()=>"ok",pass:!0};const o=JSON.stringify(e),i=JSON.stringify(t),a=n.map(e=>`- '${e.property}' should be ${JSON.stringify(e.expect)}, but is ${JSON.stringify(e.current)}`).join("\n");return{message:()=>`Expected: ${i}\nReceived: ${o}\n\nDifferences:\n${a}`,pass:!1}},compareProps=(e,t)=>{if(e.props.jestAnimatedProps&&0===Object.keys(e.props.jestAnimatedProps.value).length)return{message:()=>"Component doesn't have props.",pass:!1};const r=getCurrentProps(e);return compareAndFormatDifferences(r,t)},compareStyle=(e,t,r)=>{if(!e.props.style)return{message:()=>"Component doesn't have a style.",pass:!1};const{shouldMatchAllProps:s}=r,n=getCurrentStyle(e);return compareAndFormatDifferences(n,t,s)};let frameTime=Math.round(1e3/defaultFramerateConfig.fps);const beforeTest=()=>{jest.useFakeTimers()},afterTest=()=>{jest.runOnlyPendingTimers(),jest.useRealTimers()};export const withReanimatedTimer=e=>{logger.warn("This method is deprecated, you should define your own before and after test hooks to enable jest.useFakeTimers(). Check out the documentation for details on testing"),beforeTest(),e(),afterTest()};export const advanceAnimationByTime=(e=frameTime)=>{logger.warn("This method is deprecated, use jest.advanceTimersByTime directly"),jest.advanceTimersByTime(e),jest.runOnlyPendingTimers()};export const advanceAnimationByFrame=e=>{logger.warn("This method is deprecated, use jest.advanceTimersByTime directly"),jest.advanceTimersByTime(e*frameTime),jest.runOnlyPendingTimers()};const requireFunction=IS_JEST?require:()=>{throw new ReanimatedError("`setUpTests` is available only in Jest environment.")};export const setUpTests=(e={})=>{let t=global.expect;if(void 0===t){const e=requireFunction("expect");if(t=e,"object"==typeof t){t=requireFunction("@jest/globals").expect}void 0!==t&&void 0!==t.extend||(t=e.default)}const r={...defaultFramerateConfig,...e};frameTime=Math.round(1e3/r.fps),t.extend({toHaveAnimatedProps:(e,t)=>compareProps(e,t)}),t.extend({toHaveAnimatedStyle:(e,t,r={})=>compareStyle(e,t,r)})};export const getAnimatedStyle=e=>getCurrentStyle(e);