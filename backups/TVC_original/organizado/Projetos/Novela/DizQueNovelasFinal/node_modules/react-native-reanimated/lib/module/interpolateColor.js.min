"use strict";import{blue,green,hsvToColor,opacity,red,rgbaColor,RGBtoHSV}from"./Colors";import{processColor,ReanimatedError}from"./common";import{makeMutable}from"./core";import culori from"./culori";import{useSharedValue}from"./hook/useSharedValue";import{Extrapolation,interpolate}from"./interpolation";export const Extrapolate=Extrapolation;const interpolateColorsHSV=(o,t,r,e)=>{let a=0;const{useCorrectedHSVInterpolation:n=!0}=e;if(n){const e=[t[0]],n=r.h,l=[n[0]];for(let o=1;o<n.length;++o){const r=n[o]-n[o-1];n[o]>n[o-1]&&r>.5?(e.push(t[o]),e.push(t[o]+1e-5),l.push(n[o]-1),l.push(n[o])):n[o]<n[o-1]&&r<-.5?(e.push(t[o]),e.push(t[o]+1e-5),l.push(n[o]+1),l.push(n[o])):(e.push(t[o]),l.push(n[o]))}a=(interpolate(o,e,l,Extrapolation.CLAMP)+1)%1}else a=interpolate(o,t,r.h,Extrapolation.CLAMP);const l=interpolate(o,t,r.s,Extrapolation.CLAMP),p=interpolate(o,t,r.v,Extrapolation.CLAMP),i=interpolate(o,t,r.a,Extrapolation.CLAMP);return hsvToColor(a,l,p,i)},toLinearSpace=(o,t)=>o.map(o=>Math.pow(o/255,t)),toGammaSpace=(o,t)=>Math.round(255*Math.pow(o,1/t)),interpolateColorsRGB=(o,t,r,e)=>{const{gamma:a=2.2}=e;let{r:n,g:l,b:p}=r;1!==a&&(n=toLinearSpace(n,a),l=toLinearSpace(l,a),p=toLinearSpace(p,a));const i=interpolate(o,t,n,Extrapolation.CLAMP),c=interpolate(o,t,l,Extrapolation.CLAMP),s=interpolate(o,t,p,Extrapolation.CLAMP),h=interpolate(o,t,r.a,Extrapolation.CLAMP);return 1===a?rgbaColor(i,c,s,h):rgbaColor(toGammaSpace(i,a),toGammaSpace(c,a),toGammaSpace(s,a),h)},interpolateColorsLAB=(o,t,r,e)=>{const a=interpolate(o,t,r.l,Extrapolation.CLAMP),n=interpolate(o,t,r.a,Extrapolation.CLAMP),l=interpolate(o,t,r.b,Extrapolation.CLAMP),p=interpolate(o,t,r.alpha,Extrapolation.CLAMP),{r:i,g:c,b:s,alpha:h}=culori.oklab.convert.toRgb({l:a,a:n,b:l,alpha:p});return rgbaColor(i,c,s,h)},_splitColorsIntoChannels=(o,t)=>{const r=[],e=[],a=[],n=[];for(let l=0;l<o.length;l++){const p=o[l],i=processColor(p);if("number"==typeof i){const o=t({r:red(i),g:green(i),b:blue(i)});r.push(o.ch1),e.push(o.ch2),a.push(o.ch3),n.push(opacity(i))}}return{ch1:r,ch2:e,ch3:a,alpha:n}},getInterpolateRGB=o=>{const{ch1:t,ch2:r,ch3:e,alpha:a}=_splitColorsIntoChannels(o,o=>({ch1:o.r,ch2:o.g,ch3:o.b}));return{r:t,g:r,b:e,a:a}},getInterpolateHSV=o=>{const{ch1:t,ch2:r,ch3:e,alpha:a}=_splitColorsIntoChannels(o,o=>{const t=RGBtoHSV(o.r,o.g,o.b);return{ch1:t.h,ch2:t.s,ch3:t.v}});return{h:t,s:r,v:e,a:a}},getInterpolateLAB=o=>{const{ch1:t,ch2:r,ch3:e,alpha:a}=_splitColorsIntoChannels(o,o=>{const t=culori.oklab.convert.fromRgb(o);return{ch1:t.l,ch2:t.a,ch3:t.b}});return{l:t,a:r,b:e,alpha:a}};export function interpolateColor(o,t,r,e="RGB",a={}){if("HSV"===e)return interpolateColorsHSV(o,t,getInterpolateHSV(r),a);if("RGB"===e)return interpolateColorsRGB(o,t,getInterpolateRGB(r),a);if("LAB"===e)return interpolateColorsLAB(o,t,getInterpolateLAB(r));throw new ReanimatedError(`Invalid color space provided: ${e}. Supported values are: ['RGB', 'HSV', 'LAB'].`)}export let ColorSpace=function(o){return o[o.RGB=0]="RGB",o[o.HSV=1]="HSV",o[o.LAB=2]="LAB",o}({});export function useInterpolateConfig(o,t,r=ColorSpace.RGB,e={}){return useSharedValue({inputRange:o,outputRange:t,colorSpace:r,cache:makeMutable(null),options:e})}