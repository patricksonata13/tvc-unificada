"use strict";import{ReanimatedError}from"../../../../common";import{cubicBezier,linear,steps}from"../../../easing";import{camelizeKebabCase,isArrayOfLength,isPercentage,isPredefinedTimingFunction,isStepsModifier,parseSingleTransitionShorthand,splitByComma,splitByWhitespace}from"../../../utils";export const createEmptyTransitionConfig=()=>({transitionProperty:[],transitionDuration:[],transitionTimingFunction:[],transitionDelay:[],transitionBehavior:[]});export function parseTransitionShorthand(i){return splitByComma(i).reduce((i,n)=>{const t=parseSingleTransitionShorthand(n);return i.transitionProperty.push(camelizeKebabCase(t.transitionProperty??"all")),i.transitionDuration.push(t.transitionDuration),i.transitionTimingFunction.push(t.transitionTimingFunction?parseTimingFunction(t.transitionTimingFunction):void 0),i.transitionDelay.push(t.transitionDelay),i.transitionBehavior.push(t.transitionBehavior),i},createEmptyTransitionConfig())}function asControlPoint(i){const[n,...t]=i;return n&&!isNaN(Number(n))&&t.every(isPercentage)?[Number(n),...t]:null}function parseTimingFunction(i){if(isPredefinedTimingFunction(i))return i;const n=/^(.+)\((.+)\)$/;if(!n.test(i))throw new ReanimatedError(`Unsupported timing function: ${i}`);const[,t,r]=i.match(n),e=splitByComma(r);switch(t){case"cubic-bezier":{const i=e.map(Number);if(isArrayOfLength(i,4)&&i.every(i=>!isNaN(i)))return cubicBezier(...i);break}case"linear":{const n=e.map(n=>{const t=asControlPoint(splitByWhitespace(n));if(!t)throw new ReanimatedError(`Invalid control point: ${n} in ${i} timing function`);return t});return linear(...n)}case"steps":{const i=Number(e[0]),n=e[1];if(!isNaN(i)&&i>0&&(void 0===n||isStepsModifier(n)))return steps(i,n);break}}throw new ReanimatedError(`Invalid timing function: ${i}`)}