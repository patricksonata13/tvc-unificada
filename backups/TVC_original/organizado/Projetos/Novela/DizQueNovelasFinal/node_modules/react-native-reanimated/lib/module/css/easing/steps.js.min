"use strict";import{ReanimatedError}from"../../common";export const ERROR_MESSAGES={invalidStepsNumber:t=>`Steps easing function accepts only positive integers as numbers of steps, ${t} isn't a one`};export class StepsEasing{static easingName="steps";constructor(t,s="jump-end"){if(t<=0||t%1!=0)throw new ReanimatedError(ERROR_MESSAGES.invalidStepsNumber(t));this.stepsNumber=t,this.modifier=s}toString(){return`${StepsEasing.easingName}(${this.stepsNumber}, ${this.modifier})`}normalize(){switch(this.modifier){case"jump-start":case"start":return this.jumpStart();case"jump-end":case"end":return this.jumpEnd();case"jump-both":return this.jumpBoth();default:return 1===this.stepsNumber?"linear":this.jumpNone()}}jumpNone(){const t=[],s=this.stepsNumber-1;for(let e=0;e<this.stepsNumber;e++)t.push({x:e/this.stepsNumber,y:e/s});return this.withName(t)}jumpStart(){const t=[];for(let s=0;s<this.stepsNumber;s++)t.push({x:s/this.stepsNumber,y:(s+1)/this.stepsNumber});return this.withName(t)}jumpEnd(){const t=[];for(let s=0;s<this.stepsNumber;s++)t.push({x:s/this.stepsNumber,y:s/this.stepsNumber});return t.push({x:1,y:1}),this.withName(t)}jumpBoth(){const t=[],s=this.stepsNumber+1;for(let e=0;e<this.stepsNumber;e++)t.push({x:e/this.stepsNumber,y:(e+1)/s});return t.push({x:1,y:1}),this.withName(t)}withName(t){return{name:StepsEasing.easingName,points:t}}}