"use strict";import{logger,ReanimatedError}from"../../common";import{PERCENTAGE_REGEX}from"../constants";export const ERROR_MESSAGES={invalidPointsCount:()=>"Invalid linear easing points count. There should be at least two points",invalidInputProgressValue:e=>`Invalid input progress ${e} value, it should be a percentage between 0% and 100%`};export const WARN_MESSAGES={inputProgressLessThanPrecedingPoint:(e,n)=>`Linear easing point x value ${e} is less than value of the preceding control point ${n}. Value will be overridden by ${n}`};const parsePercentage=e=>{let n;if("number"==typeof e?n=e:PERCENTAGE_REGEX.test(e)&&(n=parseFloat(e)/100),void 0===n||n<0||n>1)throw new ReanimatedError(ERROR_MESSAGES.invalidInputProgressValue(e));return n},extrapolate=(e,n,t)=>{const r=(t.y-n.y)/(t.x-n.x);return n.y+r*(e-n.x)};export class LinearEasing{static easingName="linear";constructor(e){if(e.length<2)throw new ReanimatedError(ERROR_MESSAGES.invalidPointsCount());this.points=e.map(e=>Array.isArray(e)&&1===e.length?e[0]:e)}toString(){return`${LinearEasing.easingName}(${this.points.map(e=>Array.isArray(e)?`[${e.map(e=>"string"==typeof e?`"${e}"`:e).join(", ")}]`:e).join(", ")})`}normalize(){const e=this.canonicalize();return e[0].x>0&&e.unshift({x:0,y:extrapolate(0,e[0],e[1])}),e[e.length-1].x<1&&e.push({x:1,y:extrapolate(1,e[e.length-2],e[e.length-1])}),{name:LinearEasing.easingName,points:e}}canonicalize(){const e=this.points.flatMap(e=>Array.isArray(e)?e.slice(1).map(n=>({x:parsePercentage(n),y:e[0]})):[{y:e}]);void 0===e[0].x&&(e[0].x=0),void 0===e[e.length-1].x&&(e[e.length-1].x=1);let n=0;for(let t=1;t<e.length-1;t++){const r=e[t].x;void 0!==r&&(r<n?(logger.warn(WARN_MESSAGES.inputProgressLessThanPrecedingPoint(r,n)),e[t].x=n):n=r)}let t=e[0].x,r=0;for(let n=1;n<e.length;n++){const i=e[n].x;if(void 0!==i){if(r>0){const a=i-t;for(let i=0;i<r;i++)e[n-r+i].x=t+a*(i+1)/(r+1)}t=i,r=0}else r++}return e}}