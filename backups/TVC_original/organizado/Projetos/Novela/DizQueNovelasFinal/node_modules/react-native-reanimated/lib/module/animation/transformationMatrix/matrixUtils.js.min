"use strict";import{ReanimatedError}from"../../common";export function isAffineMatrixFlat(t){return Array.isArray(t)&&16===t.length&&t.every(t=>"number"==typeof t&&!isNaN(t))}export function isAffineMatrix(t){return Array.isArray(t)&&4===t.length&&t.every(t=>Array.isArray(t)&&4===t.length&&t.every(t=>"number"==typeof t&&!isNaN(t)))}export function flatten(t){return t.flat()}export function unflatten(t){return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function maybeFlattenMatrix(t){return isAffineMatrix(t)?flatten(t):t}export function multiplyMatrices(t,r){return[[t[0][0]*r[0][0]+t[0][1]*r[1][0]+t[0][2]*r[2][0]+t[0][3]*r[3][0],t[0][0]*r[0][1]+t[0][1]*r[1][1]+t[0][2]*r[2][1]+t[0][3]*r[3][1],t[0][0]*r[0][2]+t[0][1]*r[1][2]+t[0][2]*r[2][2]+t[0][3]*r[3][2],t[0][0]*r[0][3]+t[0][1]*r[1][3]+t[0][2]*r[2][3]+t[0][3]*r[3][3]],[t[1][0]*r[0][0]+t[1][1]*r[1][0]+t[1][2]*r[2][0]+t[1][3]*r[3][0],t[1][0]*r[0][1]+t[1][1]*r[1][1]+t[1][2]*r[2][1]+t[1][3]*r[3][1],t[1][0]*r[0][2]+t[1][1]*r[1][2]+t[1][2]*r[2][2]+t[1][3]*r[3][2],t[1][0]*r[0][3]+t[1][1]*r[1][3]+t[1][2]*r[2][3]+t[1][3]*r[3][3]],[t[2][0]*r[0][0]+t[2][1]*r[1][0]+t[2][2]*r[2][0]+t[2][3]*r[3][0],t[2][0]*r[0][1]+t[2][1]*r[1][1]+t[2][2]*r[2][1]+t[2][3]*r[3][1],t[2][0]*r[0][2]+t[2][1]*r[1][2]+t[2][2]*r[2][2]+t[2][3]*r[3][2],t[2][0]*r[0][3]+t[2][1]*r[1][3]+t[2][2]*r[2][3]+t[2][3]*r[3][3]],[t[3][0]*r[0][0]+t[3][1]*r[1][0]+t[3][2]*r[2][0]+t[3][3]*r[3][0],t[3][0]*r[0][1]+t[3][1]*r[1][1]+t[3][2]*r[2][1]+t[3][3]*r[3][1],t[3][0]*r[0][2]+t[3][1]*r[1][2]+t[3][2]*r[2][2]+t[3][3]*r[3][2],t[3][0]*r[0][3]+t[3][1]*r[1][3]+t[3][2]*r[2][3]+t[3][3]*r[3][3]]]}export function subtractMatrices(t,r){const n=isAffineMatrixFlat(t),e=maybeFlattenMatrix(t),a=maybeFlattenMatrix(r),o=e.map((t,r)=>e[r]-a[r]);return n?o:unflatten(o)}export function addMatrices(t,r){const n=isAffineMatrixFlat(t),e=maybeFlattenMatrix(t),a=maybeFlattenMatrix(r),o=e.map((t,r)=>e[r]+a[r]);return n?o:unflatten(o)}export function scaleMatrix(t,r){const n=isAffineMatrixFlat(t),e=maybeFlattenMatrix(t).map(t=>t*r);return n?e:unflatten(e)}export function getRotationMatrix(t,r="z"){const n=Math.cos(t),e=Math.sin(t);switch(r){case"z":return[[n,e,0,0],[-e,n,0,0],[0,0,1,0],[0,0,0,1]];case"y":return[[n,0,-e,0],[0,1,0,0],[e,0,n,0],[0,0,0,1]];case"x":return[[1,0,0,0],[0,n,e,0],[0,-e,n,0],[0,0,0,1]]}}function norm3d(t,r,n){return Math.sqrt(t*t+r*r+n*n)}function transposeMatrix(t){const r=flatten(t);return[[r[0],r[4],r[8],r[12]],[r[1],r[5],r[9],r[13]],[r[2],r[6],r[10],r[14]],[r[3],r[7],r[11],r[15]]]}function assertVectorsHaveEqualLengths(t,r){if(__DEV__&&t.length!==r.length)throw new ReanimatedError(`Cannot calculate inner product of two vectors of different lengths. Length of ${t.toString()} is ${t.length} and length of ${r.toString()} is ${r.length}.`)}function innerProduct(t,r){return assertVectorsHaveEqualLengths(t,r),t.reduce((n,e,a)=>n+t[a]*r[a],0)}function projection(t,r){assertVectorsHaveEqualLengths(t,r);const n=innerProduct(t,r)/innerProduct(t,t);return t.map(t=>t*n)}function subtractVectors(t,r){return assertVectorsHaveEqualLengths(t,r),t.map((n,e)=>t[e]-r[e])}function scaleVector(t,r){return t.map(t=>t*r)}function gramSchmidtAlgorithm(t){const[r,n,e,a]=t,o=r,i=subtractVectors(n,projection(o,n)),c=subtractVectors(subtractVectors(e,projection(o,e)),projection(i,e)),s=subtractVectors(subtractVectors(subtractVectors(a,projection(o,a)),projection(i,a)),projection(c,a)),[u,f,x,l]=[o,i,c,s].map(t=>scaleVector(t,1/Math.sqrt(innerProduct(t,t)))),M=[[u[0],f[0],x[0],l[0]],[u[1],f[1],x[1],l[1]],[u[2],f[2],x[2],l[2]],[u[3],f[3],x[3],l[3]]],m=[[innerProduct(u,r),innerProduct(u,n),innerProduct(u,e),innerProduct(u,a)],[0,innerProduct(f,n),innerProduct(f,e),innerProduct(f,a)],[0,0,innerProduct(x,e),innerProduct(x,a)],[0,0,0,innerProduct(l,a)]];return{rotationMatrix:transposeMatrix(M),skewMatrix:transposeMatrix(m)}}export function decomposeMatrix(t){const r=maybeFlattenMatrix(t);if(0===r[15])throw new ReanimatedError("Invalid transform matrix.");r.forEach((t,n)=>r[n]/=r[15]);const n=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[r[12],r[13],r[14],1]],e=r[15]*norm3d(r[0],r[4],r[8]),a=r[15]*norm3d(r[1],r[5],r[9]),o=r[15]*norm3d(r[2],r[6],r[10]),i=[[e,0,0,0],[0,a,0,0],[0,0,o,0],[0,0,0,1]],c=[[r[0]/e,r[1]/e,r[2]/e,0],[r[4]/a,r[5]/a,r[6]/a,0],[r[8]/o,r[9]/o,r[10]/o,0],[0,0,0,1]],{rotationMatrix:s,skewMatrix:u}=gramSchmidtAlgorithm(c);return{translationMatrix:n,scaleMatrix:i,rotationMatrix:s,skewMatrix:u}}export function decomposeMatrixIntoMatricesAndAngles(t){const{scaleMatrix:r,rotationMatrix:n,translationMatrix:e,skewMatrix:a}=decomposeMatrix(t),o=-n[0][2],i=Math.asin(o);let c,s;return 1===o||-1===o?(s=0,c=Math.atan2(o*n[0][1],o*n[0][2])):(s=Math.atan2(n[0][1],n[0][0]),c=Math.atan2(n[1][2],n[2][2])),{scaleMatrix:r,rotationMatrix:n,translationMatrix:e,skewMatrix:a,rx:c||0,ry:i||0,rz:s||0}}