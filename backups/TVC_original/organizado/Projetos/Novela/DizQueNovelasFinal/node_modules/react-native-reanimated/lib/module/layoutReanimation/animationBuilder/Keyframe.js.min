"use strict";import{withDelay,withSequence,withTiming}from"../../animation";import{assertEasingIsWorklet,getReduceMotionFromConfig}from"../../animation/util";import{ReanimatedError}from"../../common";import{ReduceMotion}from"../../commonTypes";import{Easing}from"../../Easing";class InnerKeyframe{reduceMotionV=ReduceMotion.System;constructor(e){this.definitions=e}parseDefinitions(){const e={};if(this.definitions.from){if(this.definitions[0])throw new ReanimatedError("You cannot provide both keyframe 0 and 'from' as they both specified initial values.");this.definitions[0]=this.definitions.from,delete this.definitions.from}if(this.definitions.to){if(this.definitions[100])throw new ReanimatedError("You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.");this.definitions[100]=this.definitions.to,delete this.definitions.to}if(!this.definitions[0])throw new ReanimatedError("Please provide 0 or 'from' keyframe with initial state of your object.");const i=this.definitions[0];Object.keys(i).forEach(t=>{if("transform"===t){if(!Array.isArray(i.transform))return;i.transform.forEach((i,t)=>{Object.keys(i).forEach(i=>{e[makeKeyframeKey(t,i)]=[]})})}else e[t]=[]});const t=this.durationV?this.durationV:500,n=Array.from(Object.keys(this.definitions)).map(Number),r=(i,n)=>n/100*t-e[i].reduce((e,i)=>e+i.duration,0);return n.filter(e=>0!==e).sort((e,i)=>e-i).forEach(i=>{if(i<0||i>100)throw new ReanimatedError("Keyframe should be in between range 0 - 100.");const t=this.definitions[i],n=t.easing;delete t.easing;const o=(t,o)=>(({key:i,value:t,currentKeyPoint:n,easing:o})=>{if(!(i in e))throw new ReanimatedError("Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')");__DEV__&&o&&assertEasingIsWorklet(o),e[i].push({duration:r(i,n),value:t,easing:o})})({key:t,value:o,currentKeyPoint:i,easing:n});Object.keys(t).forEach(e=>{if("transform"===e){if(!Array.isArray(t.transform))return;t.transform.forEach((e,i)=>{Object.keys(e).forEach(t=>{o(makeKeyframeKey(i,t),e[t])})})}else o(e,t[e])})}),{initialValues:i,keyframes:e}}duration(e){return this.durationV=e,this}delay(e){return this.delayV=e,this}withCallback(e){return this.callbackV=e,this}reduceMotion(e){return this.reduceMotionV=e,this}getDelayFunction(){const e=this.delayV,i=this.reduceMotionV;return e?(e,t)=>withDelay(e,t,i):(e,t)=>(t.reduceMotion=getReduceMotionFromConfig(i),t)}build=()=>{const e=this.delayV,i=this.getDelayFunction(),{keyframes:t,initialValues:n}=this.parseDefinitions(),r=this.callbackV;return this.parsedAnimation||(this.parsedAnimation=()=>{const o={},a=n=>{const r=t[n];if(0===r.length)return;const a=i(e,1===r.length?withTiming(r[0].value,{duration:r[0].duration,easing:r[0].easing?r[0].easing:Easing.linear}):withSequence(...r.map(e=>withTiming(e.value,{duration:e.duration,easing:e.easing?e.easing:Easing.linear}))));n.includes("transform")?("transform"in o||(o.transform=[]),o.transform.push({[n.split(":")[1]]:a})):o[n]=a};return Object.keys(n).forEach(e=>{e.includes("transform")?n[e].forEach((e,i)=>{Object.keys(e).forEach(e=>{a(makeKeyframeKey(i,e))})}):a(e)}),{animations:o,initialValues:n,callback:r}}),this.parsedAnimation}}function makeKeyframeKey(e,i){return`${e}_transform:${i}`}export const Keyframe=InnerKeyframe;