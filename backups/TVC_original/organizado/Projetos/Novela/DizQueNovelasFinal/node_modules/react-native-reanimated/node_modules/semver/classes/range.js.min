"use strict";const SPACE_CHARACTERS=/\s+/g;class Range{constructor(e,t){if(t=parseOptions(t),e instanceof Range)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new Range(e.raw,t);if(e instanceof Comparator)return this.raw=e.value,this.set=[[e]],this.formatted=void 0,this;if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e.trim().replace(SPACE_CHARACTERS," "),this.set=this.raw.split("||").map(e=>this.parseRange(e.trim())).filter(e=>e.length),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${this.raw}`);if(this.set.length>1){const e=this.set[0];if(this.set=this.set.filter(e=>!isNullSet(e[0])),0===this.set.length)this.set=[e];else if(this.set.length>1)for(const e of this.set)if(1===e.length&&isAny(e[0])){this.set=[e];break}}this.formatted=void 0}get range(){if(void 0===this.formatted){this.formatted="";for(let e=0;e<this.set.length;e++){e>0&&(this.formatted+="||");const t=this.set[e];for(let e=0;e<t.length;e++)e>0&&(this.formatted+=" "),this.formatted+=t[e].toString().trim()}}return this.formatted}format(){return this.range}toString(){return this.range}parseRange(e){const r=((this.options.includePrerelease&&FLAG_INCLUDE_PRERELEASE)|(this.options.loose&&FLAG_LOOSE))+":"+e,s=cache.get(r);if(s)return s;const i=this.options.loose,a=i?re[t.HYPHENRANGELOOSE]:re[t.HYPHENRANGE];e=e.replace(a,hyphenReplace(this.options.includePrerelease)),debug("hyphen replace",e),e=e.replace(re[t.COMPARATORTRIM],comparatorTrimReplace),debug("comparator trim",e),e=e.replace(re[t.TILDETRIM],tildeTrimReplace),debug("tilde trim",e),e=e.replace(re[t.CARETTRIM],caretTrimReplace),debug("caret trim",e);let l=e.split(" ").map(e=>parseComparator(e,this.options)).join(" ").split(/\s+/).map(e=>replaceGTE0(e,this.options));i&&(l=l.filter(e=>(debug("loose invalid filter",e,this.options),!!e.match(re[t.COMPARATORLOOSE])))),debug("range list",l);const n=new Map,o=l.map(e=>new Comparator(e,this.options));for(const e of o){if(isNullSet(e))return[e];n.set(e.value,e)}n.size>1&&n.has("")&&n.delete("");const c=[...n.values()];return cache.set(r,c),c}intersects(e,t){if(!(e instanceof Range))throw new TypeError("a Range is required");return this.set.some(r=>isSatisfiable(r,t)&&e.set.some(e=>isSatisfiable(e,t)&&r.every(r=>e.every(e=>r.intersects(e,t)))))}test(e){if(!e)return!1;if("string"==typeof e)try{e=new SemVer(e,this.options)}catch(e){return!1}for(let t=0;t<this.set.length;t++)if(testSet(this.set[t],e,this.options))return!0;return!1}}module.exports=Range;const LRU=require("../internal/lrucache"),cache=new LRU,parseOptions=require("../internal/parse-options"),Comparator=require("./comparator"),debug=require("../internal/debug"),SemVer=require("./semver"),{safeRe:re,t:t,comparatorTrimReplace:comparatorTrimReplace,tildeTrimReplace:tildeTrimReplace,caretTrimReplace:caretTrimReplace}=require("../internal/re"),{FLAG_INCLUDE_PRERELEASE:FLAG_INCLUDE_PRERELEASE,FLAG_LOOSE:FLAG_LOOSE}=require("../internal/constants"),isNullSet=e=>"<0.0.0-0"===e.value,isAny=e=>""===e.value,isSatisfiable=(e,t)=>{let r=!0;const s=e.slice();let i=s.pop();for(;r&&s.length;)r=s.every(e=>i.intersects(e,t)),i=s.pop();return r},parseComparator=(e,t)=>(debug("comp",e,t),e=replaceCarets(e,t),debug("caret",e),e=replaceTildes(e,t),debug("tildes",e),e=replaceXRanges(e,t),debug("xrange",e),e=replaceStars(e,t),debug("stars",e),e),isX=e=>!e||"x"===e.toLowerCase()||"*"===e,replaceTildes=(e,t)=>e.trim().split(/\s+/).map(e=>replaceTilde(e,t)).join(" "),replaceTilde=(e,r)=>{const s=r.loose?re[t.TILDELOOSE]:re[t.TILDE];return e.replace(s,(t,r,s,i,a)=>{let l;return debug("tilde",e,t,r,s,i,a),isX(r)?l="":isX(s)?l=`>=${r}.0.0 <${+r+1}.0.0-0`:isX(i)?l=`>=${r}.${s}.0 <${r}.${+s+1}.0-0`:a?(debug("replaceTilde pr",a),l=`>=${r}.${s}.${i}-${a} <${r}.${+s+1}.0-0`):l=`>=${r}.${s}.${i} <${r}.${+s+1}.0-0`,debug("tilde return",l),l})},replaceCarets=(e,t)=>e.trim().split(/\s+/).map(e=>replaceCaret(e,t)).join(" "),replaceCaret=(e,r)=>{debug("caret",e,r);const s=r.loose?re[t.CARETLOOSE]:re[t.CARET],i=r.includePrerelease?"-0":"";return e.replace(s,(t,r,s,a,l)=>{let n;return debug("caret",e,t,r,s,a,l),isX(r)?n="":isX(s)?n=`>=${r}.0.0${i} <${+r+1}.0.0-0`:isX(a)?n="0"===r?`>=${r}.${s}.0${i} <${r}.${+s+1}.0-0`:`>=${r}.${s}.0${i} <${+r+1}.0.0-0`:l?(debug("replaceCaret pr",l),n="0"===r?"0"===s?`>=${r}.${s}.${a}-${l} <${r}.${s}.${+a+1}-0`:`>=${r}.${s}.${a}-${l} <${r}.${+s+1}.0-0`:`>=${r}.${s}.${a}-${l} <${+r+1}.0.0-0`):(debug("no pr"),n="0"===r?"0"===s?`>=${r}.${s}.${a}${i} <${r}.${s}.${+a+1}-0`:`>=${r}.${s}.${a}${i} <${r}.${+s+1}.0-0`:`>=${r}.${s}.${a} <${+r+1}.0.0-0`),debug("caret return",n),n})},replaceXRanges=(e,t)=>(debug("replaceXRanges",e,t),e.split(/\s+/).map(e=>replaceXRange(e,t)).join(" ")),replaceXRange=(e,r)=>{e=e.trim();const s=r.loose?re[t.XRANGELOOSE]:re[t.XRANGE];return e.replace(s,(t,s,i,a,l,n)=>{debug("xRange",e,t,s,i,a,l,n);const o=isX(i),c=o||isX(a),p=c||isX(l),$=p;return"="===s&&$&&(s=""),n=r.includePrerelease?"-0":"",o?t=">"===s||"<"===s?"<0.0.0-0":"*":s&&$?(c&&(a=0),l=0,">"===s?(s=">=",c?(i=+i+1,a=0,l=0):(a=+a+1,l=0)):"<="===s&&(s="<",c?i=+i+1:a=+a+1),"<"===s&&(n="-0"),t=`${s+i}.${a}.${l}${n}`):c?t=`>=${i}.0.0${n} <${+i+1}.0.0-0`:p&&(t=`>=${i}.${a}.0${n} <${i}.${+a+1}.0-0`),debug("xRange return",t),t})},replaceStars=(e,r)=>(debug("replaceStars",e,r),e.trim().replace(re[t.STAR],"")),replaceGTE0=(e,r)=>(debug("replaceGTE0",e,r),e.trim().replace(re[r.includePrerelease?t.GTE0PRE:t.GTE0],"")),hyphenReplace=e=>(t,r,s,i,a,l,n,o,c,p,$,u)=>`${r=isX(s)?"":isX(i)?`>=${s}.0.0${e?"-0":""}`:isX(a)?`>=${s}.${i}.0${e?"-0":""}`:l?`>=${r}`:`>=${r}${e?"-0":""}`} ${o=isX(c)?"":isX(p)?`<${+c+1}.0.0-0`:isX($)?`<${c}.${+p+1}.0-0`:u?`<=${c}.${p}.${$}-${u}`:e?`<${c}.${p}.${+$+1}-0`:`<=${o}`}`.trim(),testSet=(e,t,r)=>{for(let r=0;r<e.length;r++)if(!e[r].test(t))return!1;if(t.prerelease.length&&!r.includePrerelease){for(let r=0;r<e.length;r++)if(debug(e[r].semver),e[r].semver!==Comparator.ANY&&e[r].semver.prerelease.length>0){const s=e[r].semver;if(s.major===t.major&&s.minor===t.minor&&s.patch===t.patch)return!0}return!1}return!0};