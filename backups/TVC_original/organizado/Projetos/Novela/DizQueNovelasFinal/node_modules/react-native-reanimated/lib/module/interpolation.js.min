"use strict";import{ReanimatedError}from"./common";export let Extrapolation=function(t){return t.IDENTITY="identity",t.CLAMP="clamp",t.EXTEND="extend",t}({});function getVal(t,e,a,n,r,o){switch(t){case Extrapolation.IDENTITY:return o;case Extrapolation.CLAMP:return e*a<e*n?n:r;case Extrapolation.EXTEND:default:return a}}function isExtrapolate(t){return t===Extrapolation.EXTEND||t===Extrapolation.CLAMP||t===Extrapolation.IDENTITY}function validateType(t){const e={extrapolateLeft:Extrapolation.EXTEND,extrapolateRight:Extrapolation.EXTEND};if(!t)return e;if("string"==typeof t){if(!isExtrapolate(t))throw new ReanimatedError('Unsupported value for "interpolate" \nSupported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\n Valid example:\n        interpolate(value, [inputRange], [outputRange], "clamp")');return e.extrapolateLeft=t,e.extrapolateRight=t,e}if(t.extrapolateLeft&&!isExtrapolate(t.extrapolateLeft)||t.extrapolateRight&&!isExtrapolate(t.extrapolateRight))throw new ReanimatedError('Unsupported value for "interpolate" \nSupported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})');return Object.assign(e,t),e}function internalInterpolate(t,e,a){const{leftEdgeInput:n,rightEdgeInput:r,leftEdgeOutput:o,rightEdgeOutput:p}=e;if(r-n===0)return o;const i=o+(t-n)/(r-n)*(p-o),l=p>=o?1:-1;return l*i<l*o?getVal(a.extrapolateLeft,l,i,o,p,t):l*i>l*p?getVal(a.extrapolateRight,l,i,o,p,t):i}export function interpolate(t,e,a,n){if(e.length<2||a.length<2)throw new ReanimatedError("Interpolation input and output ranges should contain at least two values.");const r=validateType(n),o=e.length,p={leftEdgeInput:e[0],rightEdgeInput:e[1],leftEdgeOutput:a[0],rightEdgeOutput:a[1]};if(o>2)if(t>e[o-1])p.leftEdgeInput=e[o-2],p.rightEdgeInput=e[o-1],p.leftEdgeOutput=a[o-2],p.rightEdgeOutput=a[o-1];else for(let n=1;n<o;++n)if(t<=e[n]){p.leftEdgeInput=e[n-1],p.rightEdgeInput=e[n],p.leftEdgeOutput=a[n-1],p.rightEdgeOutput=a[n];break}return internalInterpolate(t,p,r)}export function clamp(t,e,a){return Math.min(Math.max(t,e),a)}