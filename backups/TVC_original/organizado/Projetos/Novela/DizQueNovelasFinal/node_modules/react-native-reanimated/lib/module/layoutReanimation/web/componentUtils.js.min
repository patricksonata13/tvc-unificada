"use strict";import{logger}from"../../common";import{LayoutAnimationType,ReduceMotion}from"../../commonTypes";import{EasingNameSymbol}from"../../Easing";import{_updatePropsJS}from"../../ReanimatedModule/js-reanimated";import{ReducedMotionManager}from"../../ReducedMotion";import{Keyframe}from"../animationBuilder";import{setElementPosition,snapshots}from"./componentStyle";import{Animations,TransitionType}from"./config";import{TransitionGenerator}from"./createAnimation";import{scheduleAnimationCleanup}from"./domUtils";import{getEasingByName,maybeGetBezierEasing,WebEasings}from"./Easing.web";import{prepareCurvedTransition}from"./transition/Curved.web";function getEasingFromConfig(e){if(!e.easingV)return getEasingByName("linear");const n=e.easingV[EasingNameSymbol];if(n in WebEasings)return getEasingByName(n);const t=maybeGetBezierEasing(e.easingV);return t||(logger.warn("Selected easing is not currently supported on web. Using linear easing instead."),getEasingByName("linear"))}function getRandomDelay(e=1e3){return Math.floor(Math.random()*(e+1))/1e3}function getDelayFromConfig(e){const n=e.randomizeDelay,t=n?getRandomDelay():0;return e.delayV?n?getRandomDelay(e.delayV):e.delayV/1e3:t}export function getReducedMotionFromConfig(e){if(!e.reduceMotionV)return ReducedMotionManager.jsValue;switch(e.reduceMotionV){case ReduceMotion.Never:return!1;case ReduceMotion.Always:return!0;default:return ReducedMotionManager.jsValue}}function getDurationFromConfig(e,n){const t=n in Animations?Animations[n].duration:.3;return void 0!==e.durationV?e.durationV/1e3:t}function getCallbackFromConfig(e){return void 0!==e.callbackV?e.callbackV:null}function getReversedFromConfig(e){return!!e.reversed}export function getProcessedConfig(e,n,t){return{animationName:e,animationType:n,duration:getDurationFromConfig(t,e),delay:getDelayFromConfig(t),easing:getEasingFromConfig(t),callback:getCallbackFromConfig(t),reversed:getReversedFromConfig(t)}}export function maybeModifyStyleForKeyframe(e,n){if(n instanceof Keyframe){e.style.animationFillMode="forwards";for(const t of Object.values(n.definitions))if("originX"in t||"originY"in t)return void(e.style.position="absolute")}}export function saveSnapshot(e){const n=e.getBoundingClientRect(),t={top:n.top,left:n.left,width:n.width,height:n.height,scrollOffsets:getElementScrollValue(e)};snapshots.set(e,t)}export function setElementAnimation(e,n,t=!1,o=null){const{animationName:i,duration:a,delay:r,easing:s}=n,l=()=>{e.style.animationName=i,e.style.animationFillMode="backwards",e.style.animationDuration=`${a}s`,e.style.animationDelay=`${r}s`,e.style.animationTimingFunction=s};n.animationType===LayoutAnimationType.ENTERING?requestAnimationFrame(l):l();const m=()=>{e.reanimatedDummy&&o?.contains(e)&&(e.removedAfterAnimation=!0,o.removeChild(e))};let c=!1;const f=e=>{!c&&n.callback&&(n.callback(e),c=!0)};e.onanimationend=()=>{t&&saveSnapshot(e),m(),f(!0),e.removeEventListener("animationcancel",d)};const d=()=>{m(),f(!1),e.removeEventListener("animationcancel",d)};e.onanimationstart=()=>{n.animationType===LayoutAnimationType.ENTERING&&_updatePropsJS({visibility:"initial"},e),e.addEventListener("animationcancel",d)},i in Animations||scheduleAnimationCleanup(i,a+r,()=>{t&&setElementPosition(e,snapshots.get(e)),m(),f(!1)})}export function handleLayoutTransition(e,n,t){const{animationName:o}=n;let i;switch(o){case"LinearTransition":default:i=TransitionType.LINEAR;break;case"SequencedTransition":i=TransitionType.SEQUENCED;break;case"FadingTransition":i=TransitionType.FADING;break;case"JumpingTransition":i=TransitionType.JUMPING;break;case"CurvedTransition":i=TransitionType.CURVED;break;case"EntryExitTransition":i=TransitionType.ENTRY_EXIT}const{transitionKeyframeName:a,dummyTransitionKeyframeName:r}=TransitionGenerator(i,t);if(n.animationName=a,i===TransitionType.CURVED){const{dummy:o,dummyAnimationConfig:i}=prepareCurvedTransition(e,n,t,r);setElementAnimation(o,i)}setElementAnimation(e,n)}function getElementScrollValue(e){let n=e;const t={scrollTopOffset:0,scrollLeftOffset:0};for(;n;)0!==n.scrollTop&&0===t.scrollTopOffset&&(t.scrollTopOffset=n.scrollTop),0!==n.scrollLeft&&0===t.scrollLeftOffset&&(t.scrollLeftOffset=n.scrollLeft),n=n.parentElement;return t}export function handleExitingAnimation(e,n){const t=e.offsetParent,o=e.cloneNode();o.reanimatedDummy=!0,e.style.animationName="",o.style.animationName="";const i=new Map,a=e=>{i.set(e,{top:e.scrollTop,left:e.scrollLeft});for(const n of Array.from(e.children))a(n)};for(a(e);e.firstChild;)o.appendChild(e.firstChild);t?.appendChild(o);const r=n=>{const t=i.get(n===o?e:n);t&&(n.scrollTop=t.top,n.scrollLeft=t.left);for(const e of Array.from(n.children))r(e)};r(o);const s=snapshots.get(e),l=getElementScrollValue(e),m=l.scrollTopOffset,c=s.scrollOffsets.scrollTopOffset;m!==c&&(s.top+=c-m);const f=l.scrollLeftOffset,d=s.scrollOffsets.scrollLeftOffset;f!==d&&(s.left+=d-f),snapshots.set(o,s),setElementPosition(o,s),setElementAnimation(o,n,!1,t)}