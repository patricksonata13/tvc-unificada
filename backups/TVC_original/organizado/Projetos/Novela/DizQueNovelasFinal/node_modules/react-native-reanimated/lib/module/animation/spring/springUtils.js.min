"use strict";import{logger}from"../../common";export function checkIfConfigIsValid(t){let a="";return["stiffness","damping","dampingRatio","mass","energyThreshold"].forEach(n=>{const e=t[n];e<=0&&(a+=`, ${n} must be grater than zero but got ${e}`)}),t.duration<0&&(a+=`, duration can't be negative, got ${t.duration}`),t.clamp?.min&&t.clamp?.max&&t.clamp.min>t.clamp.max&&(a+=`, clamp.min should be lower than clamp.max, got clamp: {min: ${t.clamp.min}, max: ${t.clamp.max}} `),""!==a&&logger.warn("Invalid spring config"+a),""===a}function bisectRoot({min:t,max:a,func:n,precision:e,maxIterations:o=20}){const i=n(a)>=n(t)?1:-1;let r=o,s=(a+t)/2;for(;Math.abs(n(s))>e&&r>0;)r-=1,n(s)*i<0?t=s:a=s,s=(t+a)/2;return s}export function initialCalculations(t=0,a){if(a.skipAnimation)return{zeta:0,omega0:0,omega1:0};if(a.useDuration){const{mass:n,dampingRatio:e}=a,o=Math.sqrt(t/n);return{zeta:e,omega0:o,omega1:o*Math.sqrt(1-e**2)}}{const{damping:t,mass:n,stiffness:e}=a,o=t/(2*Math.sqrt(e*n)),i=Math.sqrt(e/n);return{zeta:o,omega0:i,omega1:i*Math.sqrt(1-o**2)}}}export function scaleZetaToMatchClamps(t,a){const{zeta:n,toValue:e,startValue:o}=t,i=Number(e);if(0===o)return n;const[r,s]=o<=0?[a.min,a.max]:[a.max,a.min],m=void 0!==s?Math.abs((s-i)/o):void 0,c=void 0!==r?Math.abs((r-i)/o):void 0,u=[void 0!==m?Math.abs(Math.log(m)/Math.PI):void 0,void 0!==c?Math.abs(Math.log(c)/(2*Math.PI)):void 0].filter(t=>void 0!==t);return Math.max(...u,n)}export function getEnergy(t,a,n,e){return.5*n*t**2+.5*e*a**2}export function calculateNewStiffnessToMatchDuration(t,a,n){if(a.skipAnimation)return 0;const{dampingRatio:e,energyThreshold:o,mass:i,duration:r}=a,s=.001*a.energyThreshold;return bisectRoot({min:Number.EPSILON,max:8e3,func:a=>{const s=1.5*r/1e3,m=Math.sqrt(a/i)*e,c=(t+(n+t*m)*s)*Math.exp(-m*s),u=(t+(n+t*m)*s)*Math.exp(-m*s)*-m+(n+t*m)*Math.exp(-m*s),l=getEnergy(t,n,a,i);return getEnergy(c,u,a,i)/l-o},precision:s,maxIterations:100})}export function criticallyDampedSpringCalculations(t,a){const{toValue:n}=t,{v0:e,x0:o,omega0:i,t:r}=a,s=Math.exp(-i*r);return{position:n+s*(o+(e+i*o)*r),velocity:s*-i*(o+(e+i*o)*r)+s*(e+i*o)}}export function underDampedSpringCalculations(t,a){const{toValue:n}=t,{zeta:e,t:o,omega0:i,omega1:r,x0:s,v0:m}=a,c=Math.sin(r*o),u=Math.cos(r*o),l=Math.exp(-e*i*o),g=l*(c*((m+e*i*s)/r)+s*u);return{position:n+g,velocity:-e*i*g+l*(u*(m+e*i*s)-r*s*c)}}export function isAnimationTerminatingCalculation(t,a){const{toValue:n,velocity:e,startValue:o,current:i,initialEnergy:r}=t;if(a.overshootClamping){const t=o>=0?n:n+o,a=t+Math.abs(o);if(i<t||i>a)return!0}const s=getEnergy(n-i,e,a.stiffness,a.mass);return 0===r||s/r<=a.energyThreshold}