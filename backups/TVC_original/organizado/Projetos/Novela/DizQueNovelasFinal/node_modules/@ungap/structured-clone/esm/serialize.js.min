import{VOID,PRIMITIVE,ARRAY,OBJECT,DATE,REGEXP,MAP,SET,ERROR,BIGINT}from"./types.js";const EMPTY="",{toString:toString}={},{keys:keys}=Object,typeOf=e=>{const r=typeof e;if("object"!==r||!e)return[PRIMITIVE,r];const t=toString.call(e).slice(8,-1);switch(t){case"Array":return[ARRAY,""];case"Object":return[OBJECT,""];case"Date":return[DATE,""];case"RegExp":return[REGEXP,""];case"Map":return[MAP,""];case"Set":return[SET,""];case"DataView":return[ARRAY,t]}return t.includes("Array")?[ARRAY,t]:t.includes("Error")?[ERROR,t]:[OBJECT,t]},shouldSkip=([e,r])=>e===PRIMITIVE&&("function"===r||"symbol"===r),serializer=(e,r,t,s)=>{const n=(e,r)=>{const n=s.push(e)-1;return t.set(r,n),n},o=s=>{if(t.has(s))return t.get(s);let[c,a]=typeOf(s);switch(c){case PRIMITIVE:{let r=s;switch(a){case"bigint":c=BIGINT,r=s.toString();break;case"function":case"symbol":if(e)throw new TypeError("unable to serialize "+a);r=null;break;case"undefined":return n([VOID],s)}return n([c,r],s)}case ARRAY:{if(a){let e=s;return"DataView"===a?e=new Uint8Array(s.buffer):"ArrayBuffer"===a&&(e=new Uint8Array(s)),n([a,[...e]],s)}const e=[],r=n([c,e],s);for(const r of s)e.push(o(r));return r}case OBJECT:{if(a)switch(a){case"BigInt":return n([a,s.toString()],s);case"Boolean":case"Number":case"String":return n([a,s.valueOf()],s)}if(r&&"toJSON"in s)return o(s.toJSON());const t=[],u=n([c,t],s);for(const r of keys(s))!e&&shouldSkip(typeOf(s[r]))||t.push([o(r),o(s[r])]);return u}case DATE:return n([c,s.toISOString()],s);case REGEXP:{const{source:e,flags:r}=s;return n([c,{source:e,flags:r}],s)}case MAP:{const r=[],t=n([c,r],s);for(const[t,n]of s)(e||!shouldSkip(typeOf(t))&&!shouldSkip(typeOf(n)))&&r.push([o(t),o(n)]);return t}case SET:{const r=[],t=n([c,r],s);for(const t of s)!e&&shouldSkip(typeOf(t))||r.push(o(t));return t}}const{message:u}=s;return n([c,{name:a,message:u}],s)};return o};export const serialize=(e,{json:r,lossy:t}={})=>{const s=[];return serializer(!(r||t),!!r,new Map,s)(e),s};