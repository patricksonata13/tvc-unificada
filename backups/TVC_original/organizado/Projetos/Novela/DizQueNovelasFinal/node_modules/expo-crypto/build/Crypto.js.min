import{toByteArray}from"base64-js";import{UnavailabilityError}from"expo-modules-core";import{CryptoDigestAlgorithm,CryptoEncoding}from"./Crypto.types";import ExpoCrypto from"./ExpoCrypto";export*from"./Crypto.types";class CryptoError extends TypeError{code="ERR_CRYPTO";constructor(t){super(`expo-crypto: ${t}`)}}export function getRandomBytes(t){assertByteCount(t,"getRandomBytes");const o=Math.floor(t);if(__DEV__&&(!global.nativeCallSyncHook||global.__REMOTEDEV__)){const t=new Uint8Array(o);for(let r=0;r<o;r++)t[r]=Math.floor(256*Math.random());return t}if(ExpoCrypto.getRandomValues){const t=new Uint8Array(o);return ExpoCrypto.getRandomValues(t),t}if(ExpoCrypto.getRandomBase64String){const t=ExpoCrypto.getRandomBase64String(o);return toByteArray(t)}throw new UnavailabilityError("expo-crypto","getRandomBytes")}export async function getRandomBytesAsync(t){assertByteCount(t,"getRandomBytesAsync");const o=Math.floor(t);if(ExpoCrypto.getRandomValues){const t=new Uint8Array(o);return ExpoCrypto.getRandomValues(t),t}if(ExpoCrypto.getRandomBase64StringAsync){const t=await ExpoCrypto.getRandomBase64StringAsync(o);return toByteArray(t)}throw new UnavailabilityError("expo-crypto","getRandomBytesAsync")}function assertByteCount(t,o){if("number"!=typeof t||isNaN(t)||Math.floor(t)<0||Math.floor(t)>1024)throw new TypeError(`expo-crypto: ${o}(${t}) expected a valid number from range 0...1024`)}function assertAlgorithm(t){if(!Object.values(CryptoDigestAlgorithm).includes(t))throw new CryptoError(`Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(CryptoDigestAlgorithm).join(", AlgCryptoDigestAlgorithmorithm.")}`)}function assertData(t){if("string"!=typeof t)throw new CryptoError("Invalid data provided. Expected a string.")}function assertEncoding(t){if(!Object.values(CryptoEncoding).includes(t))throw new CryptoError(`Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(CryptoEncoding).join(", CryptoEncoding.")}`)}export async function digestStringAsync(t,o,r={encoding:CryptoEncoding.HEX}){if(!ExpoCrypto.digestStringAsync)throw new UnavailabilityError("expo-crypto","digestStringAsync");return assertAlgorithm(t),assertData(o),assertEncoding(r.encoding),await ExpoCrypto.digestStringAsync(t,o,r)}export function getRandomValues(t){return ExpoCrypto.getRandomValues(t),t}export function randomUUID(){return ExpoCrypto.randomUUID()}const digestLengths={[CryptoDigestAlgorithm.SHA1]:20,[CryptoDigestAlgorithm.SHA256]:32,[CryptoDigestAlgorithm.SHA384]:48,[CryptoDigestAlgorithm.SHA512]:64,[CryptoDigestAlgorithm.MD2]:16,[CryptoDigestAlgorithm.MD4]:16,[CryptoDigestAlgorithm.MD5]:16};export function digest(t,o){return new Promise((r,e)=>{try{if("function"==typeof ExpoCrypto.digestAsync)r(ExpoCrypto.digestAsync(t,o));else{const e=new Uint8Array(digestLengths[t]);ExpoCrypto.digest(t,e,o),r(e.buffer)}}catch(t){e(t)}})}