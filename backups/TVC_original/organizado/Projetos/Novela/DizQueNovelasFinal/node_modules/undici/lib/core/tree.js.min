"use strict";const{wellknownHeaderNames:wellknownHeaderNames,headerNameLowerCasedRecord:headerNameLowerCasedRecord}=require("./constants");class TstNode{value=null;left=null;middle=null;right=null;code;constructor(e,r,l){if(void 0===l||l>=e.length)throw new TypeError("Unreachable");if((this.code=e.charCodeAt(l))>127)throw new TypeError("key must be ascii string");e.length!==++l?this.middle=new TstNode(e,r,l):this.value=r}add(e,r){const l=e.length;if(0===l)throw new TypeError("Unreachable");let t=0,n=this;for(;;){const o=e.charCodeAt(t);if(o>127)throw new TypeError("key must be ascii string");if(n.code===o){if(l===++t){n.value=r;break}if(null===n.middle){n.middle=new TstNode(e,r,t);break}n=n.middle}else if(n.code<o){if(null===n.left){n.left=new TstNode(e,r,t);break}n=n.left}else{if(null===n.right){n.right=new TstNode(e,r,t);break}n=n.right}}}search(e){const r=e.length;let l=0,t=this;for(;null!==t&&l<r;){let n=e[l];for(n<=90&&n>=65&&(n|=32);null!==t;){if(n===t.code){if(r===++l)return t;t=t.middle;break}t=t.code<n?t.left:t.right}}return null}}class TernarySearchTree{node=null;insert(e,r){null===this.node?this.node=new TstNode(e,r,0):this.node.add(e,r)}lookup(e){return this.node?.search(e)?.value??null}}const tree=new TernarySearchTree;for(let e=0;e<wellknownHeaderNames.length;++e){const r=headerNameLowerCasedRecord[wellknownHeaderNames[e]];tree.insert(r,r)}module.exports={TernarySearchTree:TernarySearchTree,tree:tree};