"use strict";const{extractBody:extractBody,mixinBody:mixinBody,cloneBody:cloneBody,bodyUnusable:bodyUnusable}=require("./body"),{Headers:Headers,fill:fillHeaders,HeadersList:HeadersList,setHeadersGuard:setHeadersGuard,getHeadersGuard:getHeadersGuard,setHeadersList:setHeadersList,getHeadersList:getHeadersList}=require("./headers"),{FinalizationRegistry:FinalizationRegistry}=require("./dispatcher-weakref")(),util=require("../../core/util"),nodeUtil=require("node:util"),{isValidHTTPToken:isValidHTTPToken,sameOrigin:sameOrigin,environmentSettingsObject:environmentSettingsObject}=require("./util"),{forbiddenMethodsSet:forbiddenMethodsSet,corsSafeListedMethodsSet:corsSafeListedMethodsSet,referrerPolicy:referrerPolicy,requestRedirect:requestRedirect,requestMode:requestMode,requestCredentials:requestCredentials,requestCache:requestCache,requestDuplex:requestDuplex}=require("./constants"),{kEnumerableProperty:kEnumerableProperty,normalizedMethodRecordsBase:normalizedMethodRecordsBase,normalizedMethodRecords:normalizedMethodRecords}=util,{kHeaders:kHeaders,kSignal:kSignal,kState:kState,kDispatcher:kDispatcher}=require("./symbols"),{webidl:webidl}=require("./webidl"),{URLSerializer:URLSerializer}=require("./data-url"),{kConstruct:kConstruct}=require("../../core/symbols"),assert=require("node:assert"),{getMaxListeners:getMaxListeners,setMaxListeners:setMaxListeners,getEventListeners:getEventListeners,defaultMaxListeners:defaultMaxListeners}=require("node:events"),kAbortController=Symbol("abortController"),requestFinalizer=new FinalizationRegistry(({signal:e,abort:t})=>{e.removeEventListener("abort",t)}),dependentControllerMap=new WeakMap;function buildAbort(e){return function t(){const r=e.deref();if(void 0!==r){requestFinalizer.unregister(t),this.removeEventListener("abort",t),r.abort(this.reason);const e=dependentControllerMap.get(r.signal);if(void 0!==e){if(0!==e.size){for(const t of e){const e=t.deref();void 0!==e&&e.abort(this.reason)}e.clear()}dependentControllerMap.delete(r.signal)}}}}let patchMethodWarning=!1;class Request{constructor(e,t={}){if(webidl.util.markAsUncloneable(this),e===kConstruct)return;const r="Request constructor";webidl.argumentLengthCheck(arguments,1,r),e=webidl.converters.RequestInfo(e,r,"input"),t=webidl.converters.RequestInit(t,r,"init");let i=null,n=null;const s=environmentSettingsObject.settingsObject.baseUrl;let o=null;if("string"==typeof e){let r;this[kDispatcher]=t.dispatcher;try{r=new URL(e,s)}catch(t){throw new TypeError("Failed to parse URL from "+e,{cause:t})}if(r.username||r.password)throw new TypeError("Request cannot be constructed from a URL that includes credentials: "+e);i=makeRequest({urlList:[r]}),n="cors"}else this[kDispatcher]=t.dispatcher||e[kDispatcher],assert(e instanceof Request),i=e[kState],o=e[kSignal];const a=environmentSettingsObject.settingsObject.origin;let l="client";if("EnvironmentSettingsObject"===i.window?.constructor?.name&&sameOrigin(i.window,a)&&(l=i.window),null!=t.window)throw new TypeError(`'window' option '${l}' must be null`);"window"in t&&(l="no-window"),i=makeRequest({method:i.method,headersList:i.headersList,unsafeRequest:i.unsafeRequest,client:environmentSettingsObject.settingsObject,window:l,priority:i.priority,origin:i.origin,referrer:i.referrer,referrerPolicy:i.referrerPolicy,mode:i.mode,credentials:i.credentials,cache:i.cache,redirect:i.redirect,integrity:i.integrity,keepalive:i.keepalive,reloadNavigation:i.reloadNavigation,historyNavigation:i.historyNavigation,urlList:[...i.urlList]});const d=0!==Object.keys(t).length;if(d&&("navigate"===i.mode&&(i.mode="same-origin"),i.reloadNavigation=!1,i.historyNavigation=!1,i.origin="client",i.referrer="client",i.referrerPolicy="",i.url=i.urlList[i.urlList.length-1],i.urlList=[i.url]),void 0!==t.referrer){const e=t.referrer;if(""===e)i.referrer="no-referrer";else{let t;try{t=new URL(e,s)}catch(t){throw new TypeError(`Referrer "${e}" is not a valid URL.`,{cause:t})}"about:"===t.protocol&&"client"===t.hostname||a&&!sameOrigin(t,environmentSettingsObject.settingsObject.baseUrl)?i.referrer="client":i.referrer=t}}let c;if(void 0!==t.referrerPolicy&&(i.referrerPolicy=t.referrerPolicy),c=void 0!==t.mode?t.mode:n,"navigate"===c)throw webidl.errors.exception({header:"Request constructor",message:"invalid request mode navigate."});if(null!=c&&(i.mode=c),void 0!==t.credentials&&(i.credentials=t.credentials),void 0!==t.cache&&(i.cache=t.cache),"only-if-cached"===i.cache&&"same-origin"!==i.mode)throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");if(void 0!==t.redirect&&(i.redirect=t.redirect),null!=t.integrity&&(i.integrity=String(t.integrity)),void 0!==t.keepalive&&(i.keepalive=Boolean(t.keepalive)),void 0!==t.method){let e=t.method;const r=normalizedMethodRecords[e];if(void 0!==r)i.method=r;else{if(!isValidHTTPToken(e))throw new TypeError(`'${e}' is not a valid HTTP method.`);const t=e.toUpperCase();if(forbiddenMethodsSet.has(t))throw new TypeError(`'${e}' HTTP method is unsupported.`);e=normalizedMethodRecordsBase[t]??e,i.method=e}patchMethodWarning||"patch"!==i.method||(process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.",{code:"UNDICI-FETCH-patch"}),patchMethodWarning=!0)}void 0!==t.signal&&(o=t.signal),this[kState]=i;const u=new AbortController;if(this[kSignal]=u.signal,null!=o){if(!o||"boolean"!=typeof o.aborted||"function"!=typeof o.addEventListener)throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");if(o.aborted)u.abort(o.reason);else{this[kAbortController]=u;const e=buildAbort(new WeakRef(u));try{("function"==typeof getMaxListeners&&getMaxListeners(o)===defaultMaxListeners||getEventListeners(o,"abort").length>=defaultMaxListeners)&&setMaxListeners(1500,o)}catch{}util.addAbortListener(o,e),requestFinalizer.register(u,{signal:o,abort:e},e)}}if(this[kHeaders]=new Headers(kConstruct),setHeadersList(this[kHeaders],i.headersList),setHeadersGuard(this[kHeaders],"request"),"no-cors"===c){if(!corsSafeListedMethodsSet.has(i.method))throw new TypeError(`'${i.method} is unsupported in no-cors mode.`);setHeadersGuard(this[kHeaders],"request-no-cors")}if(d){const e=getHeadersList(this[kHeaders]),r=void 0!==t.headers?t.headers:new HeadersList(e);if(e.clear(),r instanceof HeadersList){for(const{name:t,value:i}of r.rawValues())e.append(t,i,!1);e.cookies=r.cookies}else fillHeaders(this[kHeaders],r)}const h=e instanceof Request?e[kState].body:null;if(!(null==t.body&&null==h||"GET"!==i.method&&"HEAD"!==i.method))throw new TypeError("Request with GET/HEAD method cannot have body.");let b=null;if(null!=t.body){const[e,r]=extractBody(t.body,i.keepalive);b=e,r&&!getHeadersList(this[kHeaders]).contains("content-type",!0)&&this[kHeaders].append("content-type",r)}const g=b??h;if(null!=g&&null==g.source){if(null!=b&&null==t.duplex)throw new TypeError("RequestInit: duplex option is required when sending a body.");if("same-origin"!==i.mode&&"cors"!==i.mode)throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');i.useCORSPreflightFlag=!0}let y=g;if(null==b&&null!=h){if(bodyUnusable(e))throw new TypeError("Cannot construct a Request with a Request object that has already been used.");const t=new TransformStream;h.stream.pipeThrough(t),y={source:h.source,length:h.length,stream:t.readable}}this[kState].body=y}get method(){return webidl.brandCheck(this,Request),this[kState].method}get url(){return webidl.brandCheck(this,Request),URLSerializer(this[kState].url)}get headers(){return webidl.brandCheck(this,Request),this[kHeaders]}get destination(){return webidl.brandCheck(this,Request),this[kState].destination}get referrer(){return webidl.brandCheck(this,Request),"no-referrer"===this[kState].referrer?"":"client"===this[kState].referrer?"about:client":this[kState].referrer.toString()}get referrerPolicy(){return webidl.brandCheck(this,Request),this[kState].referrerPolicy}get mode(){return webidl.brandCheck(this,Request),this[kState].mode}get credentials(){return this[kState].credentials}get cache(){return webidl.brandCheck(this,Request),this[kState].cache}get redirect(){return webidl.brandCheck(this,Request),this[kState].redirect}get integrity(){return webidl.brandCheck(this,Request),this[kState].integrity}get keepalive(){return webidl.brandCheck(this,Request),this[kState].keepalive}get isReloadNavigation(){return webidl.brandCheck(this,Request),this[kState].reloadNavigation}get isHistoryNavigation(){return webidl.brandCheck(this,Request),this[kState].historyNavigation}get signal(){return webidl.brandCheck(this,Request),this[kSignal]}get body(){return webidl.brandCheck(this,Request),this[kState].body?this[kState].body.stream:null}get bodyUsed(){return webidl.brandCheck(this,Request),!!this[kState].body&&util.isDisturbed(this[kState].body.stream)}get duplex(){return webidl.brandCheck(this,Request),"half"}clone(){if(webidl.brandCheck(this,Request),bodyUnusable(this))throw new TypeError("unusable");const e=cloneRequest(this[kState]),t=new AbortController;if(this.signal.aborted)t.abort(this.signal.reason);else{let e=dependentControllerMap.get(this.signal);void 0===e&&(e=new Set,dependentControllerMap.set(this.signal,e));const r=new WeakRef(t);e.add(r),util.addAbortListener(t.signal,buildAbort(r))}return fromInnerRequest(e,t.signal,getHeadersGuard(this[kHeaders]))}[nodeUtil.inspect.custom](e,t){null===t.depth&&(t.depth=2),t.colors??=!0;const r={method:this.method,url:this.url,headers:this.headers,destination:this.destination,referrer:this.referrer,referrerPolicy:this.referrerPolicy,mode:this.mode,credentials:this.credentials,cache:this.cache,redirect:this.redirect,integrity:this.integrity,keepalive:this.keepalive,isReloadNavigation:this.isReloadNavigation,isHistoryNavigation:this.isHistoryNavigation,signal:this.signal};return`Request ${nodeUtil.formatWithOptions(t,r)}`}}function makeRequest(e){return{method:e.method??"GET",localURLsOnly:e.localURLsOnly??!1,unsafeRequest:e.unsafeRequest??!1,body:e.body??null,client:e.client??null,reservedClient:e.reservedClient??null,replacesClientId:e.replacesClientId??"",window:e.window??"client",keepalive:e.keepalive??!1,serviceWorkers:e.serviceWorkers??"all",initiator:e.initiator??"",destination:e.destination??"",priority:e.priority??null,origin:e.origin??"client",policyContainer:e.policyContainer??"client",referrer:e.referrer??"client",referrerPolicy:e.referrerPolicy??"",mode:e.mode??"no-cors",useCORSPreflightFlag:e.useCORSPreflightFlag??!1,credentials:e.credentials??"same-origin",useCredentials:e.useCredentials??!1,cache:e.cache??"default",redirect:e.redirect??"follow",integrity:e.integrity??"",cryptoGraphicsNonceMetadata:e.cryptoGraphicsNonceMetadata??"",parserMetadata:e.parserMetadata??"",reloadNavigation:e.reloadNavigation??!1,historyNavigation:e.historyNavigation??!1,userActivation:e.userActivation??!1,taintedOrigin:e.taintedOrigin??!1,redirectCount:e.redirectCount??0,responseTainting:e.responseTainting??"basic",preventNoCacheCacheControlHeaderModification:e.preventNoCacheCacheControlHeaderModification??!1,done:e.done??!1,timingAllowFailed:e.timingAllowFailed??!1,urlList:e.urlList,url:e.urlList[0],headersList:e.headersList?new HeadersList(e.headersList):new HeadersList}}function cloneRequest(e){const t=makeRequest({...e,body:null});return null!=e.body&&(t.body=cloneBody(t,e.body)),t}function fromInnerRequest(e,t,r){const i=new Request(kConstruct);return i[kState]=e,i[kSignal]=t,i[kHeaders]=new Headers(kConstruct),setHeadersList(i[kHeaders],e.headersList),setHeadersGuard(i[kHeaders],r),i}mixinBody(Request),Object.defineProperties(Request.prototype,{method:kEnumerableProperty,url:kEnumerableProperty,headers:kEnumerableProperty,redirect:kEnumerableProperty,clone:kEnumerableProperty,signal:kEnumerableProperty,duplex:kEnumerableProperty,destination:kEnumerableProperty,body:kEnumerableProperty,bodyUsed:kEnumerableProperty,isHistoryNavigation:kEnumerableProperty,isReloadNavigation:kEnumerableProperty,keepalive:kEnumerableProperty,integrity:kEnumerableProperty,cache:kEnumerableProperty,credentials:kEnumerableProperty,attribute:kEnumerableProperty,referrerPolicy:kEnumerableProperty,referrer:kEnumerableProperty,mode:kEnumerableProperty,[Symbol.toStringTag]:{value:"Request",configurable:!0}}),webidl.converters.Request=webidl.interfaceConverter(Request),webidl.converters.RequestInfo=function(e,t,r){return"string"==typeof e?webidl.converters.USVString(e,t,r):e instanceof Request?webidl.converters.Request(e,t,r):webidl.converters.USVString(e,t,r)},webidl.converters.AbortSignal=webidl.interfaceConverter(AbortSignal),webidl.converters.RequestInit=webidl.dictionaryConverter([{key:"method",converter:webidl.converters.ByteString},{key:"headers",converter:webidl.converters.HeadersInit},{key:"body",converter:webidl.nullableConverter(webidl.converters.BodyInit)},{key:"referrer",converter:webidl.converters.USVString},{key:"referrerPolicy",converter:webidl.converters.DOMString,allowedValues:referrerPolicy},{key:"mode",converter:webidl.converters.DOMString,allowedValues:requestMode},{key:"credentials",converter:webidl.converters.DOMString,allowedValues:requestCredentials},{key:"cache",converter:webidl.converters.DOMString,allowedValues:requestCache},{key:"redirect",converter:webidl.converters.DOMString,allowedValues:requestRedirect},{key:"integrity",converter:webidl.converters.DOMString},{key:"keepalive",converter:webidl.converters.boolean},{key:"signal",converter:webidl.nullableConverter(e=>webidl.converters.AbortSignal(e,"RequestInit","signal",{strict:!1}))},{key:"window",converter:webidl.converters.any},{key:"duplex",converter:webidl.converters.DOMString,allowedValues:requestDuplex},{key:"dispatcher",converter:webidl.converters.any}]),module.exports={Request:Request,makeRequest:makeRequest,fromInnerRequest:fromInnerRequest,cloneRequest:cloneRequest};