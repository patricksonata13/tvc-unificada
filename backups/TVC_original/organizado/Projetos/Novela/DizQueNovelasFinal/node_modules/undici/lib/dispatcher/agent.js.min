"use strict";const{InvalidArgumentError:InvalidArgumentError}=require("../core/errors"),{kClients:kClients,kRunning:kRunning,kClose:kClose,kDestroy:kDestroy,kDispatch:kDispatch,kInterceptors:kInterceptors}=require("../core/symbols"),DispatcherBase=require("./dispatcher-base"),Pool=require("./pool"),Client=require("./client"),util=require("../core/util"),createRedirectInterceptor=require("../interceptor/redirect-interceptor"),kOnConnect=Symbol("onConnect"),kOnDisconnect=Symbol("onDisconnect"),kOnConnectionError=Symbol("onConnectionError"),kMaxRedirections=Symbol("maxRedirections"),kOnDrain=Symbol("onDrain"),kFactory=Symbol("factory"),kOptions=Symbol("options");function defaultFactory(t,n){return n&&1===n.connections?new Client(t,n):new Pool(t,n)}class Agent extends DispatcherBase{constructor({factory:t=defaultFactory,maxRedirections:n=0,connect:e,...r}={}){if(super(),"function"!=typeof t)throw new InvalidArgumentError("factory must be a function.");if(null!=e&&"function"!=typeof e&&"object"!=typeof e)throw new InvalidArgumentError("connect must be a function or an object");if(!Number.isInteger(n)||n<0)throw new InvalidArgumentError("maxRedirections must be a positive number");e&&"function"!=typeof e&&(e={...e}),this[kInterceptors]=r.interceptors?.Agent&&Array.isArray(r.interceptors.Agent)?r.interceptors.Agent:[createRedirectInterceptor({maxRedirections:n})],this[kOptions]={...util.deepClone(r),connect:e},this[kOptions].interceptors=r.interceptors?{...r.interceptors}:void 0,this[kMaxRedirections]=n,this[kFactory]=t,this[kClients]=new Map,this[kOnDrain]=(t,n)=>{this.emit("drain",t,[this,...n])},this[kOnConnect]=(t,n)=>{this.emit("connect",t,[this,...n])},this[kOnDisconnect]=(t,n,e)=>{this.emit("disconnect",t,[this,...n],e)},this[kOnConnectionError]=(t,n,e)=>{this.emit("connectionError",t,[this,...n],e)}}get[kRunning](){let t=0;for(const n of this[kClients].values())t+=n[kRunning];return t}[kDispatch](t,n){let e;if(!t.origin||!("string"==typeof t.origin||t.origin instanceof URL))throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");e=String(t.origin);let r=this[kClients].get(e);return r||(r=this[kFactory](t.origin,this[kOptions]).on("drain",this[kOnDrain]).on("connect",this[kOnConnect]).on("disconnect",this[kOnDisconnect]).on("connectionError",this[kOnConnectionError]),this[kClients].set(e,r)),r.dispatch(t,n)}async[kClose](){const t=[];for(const n of this[kClients].values())t.push(n.close());this[kClients].clear(),await Promise.all(t)}async[kDestroy](t){const n=[];for(const e of this[kClients].values())n.push(e.destroy(t));this[kClients].clear(),await Promise.all(n)}}module.exports=Agent;