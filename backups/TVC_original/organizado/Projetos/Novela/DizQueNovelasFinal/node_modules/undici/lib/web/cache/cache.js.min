"use strict";const{kConstruct:kConstruct}=require("./symbols"),{urlEquals:urlEquals,getFieldValues:getFieldValues}=require("./util"),{kEnumerableProperty:kEnumerableProperty,isDisturbed:isDisturbed}=require("../../core/util"),{webidl:webidl}=require("../fetch/webidl"),{Response:Response,cloneResponse:cloneResponse,fromInnerResponse:fromInnerResponse}=require("../fetch/response"),{Request:Request,fromInnerRequest:fromInnerRequest}=require("../fetch/request"),{kState:kState}=require("../fetch/symbols"),{fetching:fetching}=require("../fetch/index"),{urlIsHttpHttpsScheme:urlIsHttpHttpsScheme,createDeferredPromise:createDeferredPromise,readAllBytes:readAllBytes}=require("../fetch/util"),assert=require("node:assert");class Cache{#e;constructor(){arguments[0]!==kConstruct&&webidl.illegalConstructor(),webidl.util.markAsUncloneable(this),this.#e=arguments[1]}async match(e,t={}){webidl.brandCheck(this,Cache);const r="Cache.match";webidl.argumentLengthCheck(arguments,1,r),e=webidl.converters.RequestInfo(e,r,"request"),t=webidl.converters.CacheQueryOptions(t,r,"options");const s=this.#t(e,t,1);if(0!==s.length)return s[0]}async matchAll(e=void 0,t={}){webidl.brandCheck(this,Cache);const r="Cache.matchAll";return void 0!==e&&(e=webidl.converters.RequestInfo(e,r,"request")),t=webidl.converters.CacheQueryOptions(t,r,"options"),this.#t(e,t)}async add(e){webidl.brandCheck(this,Cache);const t="Cache.add";webidl.argumentLengthCheck(arguments,1,t);const r=[e=webidl.converters.RequestInfo(e,t,"request")],s=this.addAll(r);return await s}async addAll(e){webidl.brandCheck(this,Cache);const t="Cache.addAll";webidl.argumentLengthCheck(arguments,1,t);const r=[],s=[];for(let r of e){if(void 0===r)throw webidl.errors.conversionFailed({prefix:t,argument:"Argument 1",types:["undefined is not allowed"]});if(r=webidl.converters.RequestInfo(r),"string"==typeof r)continue;const e=r[kState];if(!urlIsHttpHttpsScheme(e.url)||"GET"!==e.method)throw webidl.errors.exception({header:t,message:"Expected http/s scheme when method is not GET."})}const o=[];for(const n of e){const e=new Request(n)[kState];if(!urlIsHttpHttpsScheme(e.url))throw webidl.errors.exception({header:t,message:"Expected http/s scheme."});e.initiator="fetch",e.destination="subresource",s.push(e);const i=createDeferredPromise();o.push(fetching({request:e,processResponse(e){if("error"===e.type||206===e.status||e.status<200||e.status>299)i.reject(webidl.errors.exception({header:"Cache.addAll",message:"Received an invalid status code or the request failed."}));else if(e.headersList.contains("vary")){const t=getFieldValues(e.headersList.get("vary"));for(const e of t)if("*"===e){i.reject(webidl.errors.exception({header:"Cache.addAll",message:"invalid vary field value"}));for(const e of o)e.abort();return}}},processResponseEndOfBody(e){e.aborted?i.reject(new DOMException("aborted","AbortError")):i.resolve(e)}})),r.push(i.promise)}const n=Promise.all(r),i=await n,a=[];let c=0;for(const e of i){const t={type:"put",request:s[c],response:e};a.push(t),c++}const l=createDeferredPromise();let h=null;try{this.#r(a)}catch(e){h=e}return queueMicrotask(()=>{null===h?l.resolve(void 0):l.reject(h)}),l.promise}async put(e,t){webidl.brandCheck(this,Cache);const r="Cache.put";webidl.argumentLengthCheck(arguments,2,r),e=webidl.converters.RequestInfo(e,r,"request"),t=webidl.converters.Response(t,r,"response");let s=null;if(s=e instanceof Request?e[kState]:new Request(e)[kState],!urlIsHttpHttpsScheme(s.url)||"GET"!==s.method)throw webidl.errors.exception({header:r,message:"Expected an http/s scheme when method is not GET"});const o=t[kState];if(206===o.status)throw webidl.errors.exception({header:r,message:"Got 206 status"});if(o.headersList.contains("vary")){const e=getFieldValues(o.headersList.get("vary"));for(const t of e)if("*"===t)throw webidl.errors.exception({header:r,message:"Got * vary field value"})}if(o.body&&(isDisturbed(o.body.stream)||o.body.stream.locked))throw webidl.errors.exception({header:r,message:"Response body is locked or disturbed"});const n=cloneResponse(o),i=createDeferredPromise();if(null!=o.body){const e=o.body.stream.getReader();readAllBytes(e).then(i.resolve,i.reject)}else i.resolve(void 0);const a=[],c={type:"put",request:s,response:n};a.push(c);const l=await i.promise;null!=n.body&&(n.body.source=l);const h=createDeferredPromise();let u=null;try{this.#r(a)}catch(e){u=e}return queueMicrotask(()=>{null===u?h.resolve():h.reject(u)}),h.promise}async delete(e,t={}){webidl.brandCheck(this,Cache);const r="Cache.delete";webidl.argumentLengthCheck(arguments,1,r),e=webidl.converters.RequestInfo(e,r,"request"),t=webidl.converters.CacheQueryOptions(t,r,"options");let s=null;if(e instanceof Request){if(s=e[kState],"GET"!==s.method&&!t.ignoreMethod)return!1}else assert("string"==typeof e),s=new Request(e)[kState];const o=[],n={type:"delete",request:s,options:t};o.push(n);const i=createDeferredPromise();let a,c=null;try{a=this.#r(o)}catch(e){c=e}return queueMicrotask(()=>{null===c?i.resolve(!!a?.length):i.reject(c)}),i.promise}async keys(e=void 0,t={}){webidl.brandCheck(this,Cache);const r="Cache.keys";void 0!==e&&(e=webidl.converters.RequestInfo(e,r,"request")),t=webidl.converters.CacheQueryOptions(t,r,"options");let s=null;if(void 0!==e)if(e instanceof Request){if(s=e[kState],"GET"!==s.method&&!t.ignoreMethod)return[]}else"string"==typeof e&&(s=new Request(e)[kState]);const o=createDeferredPromise(),n=[];if(void 0===e)for(const e of this.#e)n.push(e[0]);else{const e=this.#s(s,t);for(const t of e)n.push(t[0])}return queueMicrotask(()=>{const e=[];for(const t of n){const r=fromInnerRequest(t,(new AbortController).signal,"immutable");e.push(r)}o.resolve(Object.freeze(e))}),o.promise}#r(e){const t=this.#e,r=[...t],s=[],o=[];try{for(const r of e){if("delete"!==r.type&&"put"!==r.type)throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:'operation type does not match "delete" or "put"'});if("delete"===r.type&&null!=r.response)throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:"delete operation should not have an associated response"});if(this.#s(r.request,r.options,s).length)throw new DOMException("???","InvalidStateError");let e;if("delete"===r.type){if(e=this.#s(r.request,r.options),0===e.length)return[];for(const r of e){const e=t.indexOf(r);assert(-1!==e),t.splice(e,1)}}else if("put"===r.type){if(null==r.response)throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:"put operation should have an associated response"});const o=r.request;if(!urlIsHttpHttpsScheme(o.url))throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:"expected http or https scheme"});if("GET"!==o.method)throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:"not get method"});if(null!=r.options)throw webidl.errors.exception({header:"Cache.#batchCacheOperations",message:"options must not be defined"});e=this.#s(r.request);for(const r of e){const e=t.indexOf(r);assert(-1!==e),t.splice(e,1)}t.push([r.request,r.response]),s.push([r.request,r.response])}o.push([r.request,r.response])}return o}catch(e){throw this.#e.length=0,this.#e=r,e}}#s(e,t,r){const s=[],o=r??this.#e;for(const r of o){const[o,n]=r;this.#o(e,o,n,t)&&s.push(r)}return s}#o(e,t,r=null,s){const o=new URL(e.url),n=new URL(t.url);if(s?.ignoreSearch&&(n.search="",o.search=""),!urlEquals(o,n,!0))return!1;if(null==r||s?.ignoreVary||!r.headersList.contains("vary"))return!0;const i=getFieldValues(r.headersList.get("vary"));for(const r of i){if("*"===r)return!1;if(t.headersList.get(r)!==e.headersList.get(r))return!1}return!0}#t(e,t,r=1/0){let s=null;if(void 0!==e)if(e instanceof Request){if(s=e[kState],"GET"!==s.method&&!t.ignoreMethod)return[]}else"string"==typeof e&&(s=new Request(e)[kState]);const o=[];if(void 0===e)for(const e of this.#e)o.push(e[1]);else{const e=this.#s(s,t);for(const t of e)o.push(t[1])}const n=[];for(const e of o){const t=fromInnerResponse(e,"immutable");if(n.push(t.clone()),n.length>=r)break}return Object.freeze(n)}}Object.defineProperties(Cache.prototype,{[Symbol.toStringTag]:{value:"Cache",configurable:!0},match:kEnumerableProperty,matchAll:kEnumerableProperty,add:kEnumerableProperty,addAll:kEnumerableProperty,put:kEnumerableProperty,delete:kEnumerableProperty,keys:kEnumerableProperty});const cacheQueryOptionConverters=[{key:"ignoreSearch",converter:webidl.converters.boolean,defaultValue:()=>!1},{key:"ignoreMethod",converter:webidl.converters.boolean,defaultValue:()=>!1},{key:"ignoreVary",converter:webidl.converters.boolean,defaultValue:()=>!1}];webidl.converters.CacheQueryOptions=webidl.dictionaryConverter(cacheQueryOptionConverters),webidl.converters.MultiCacheQueryOptions=webidl.dictionaryConverter([...cacheQueryOptionConverters,{key:"cacheName",converter:webidl.converters.DOMString}]),webidl.converters.Response=webidl.interfaceConverter(Response),webidl.converters["sequence<RequestInfo>"]=webidl.sequenceConverter(webidl.converters.RequestInfo),module.exports={Cache:Cache};