"use strict";const assert=require("node:assert"),util=require("../core/util.js"),{channels:channels}=require("../core/diagnostics.js"),timers=require("../util/timers.js"),{RequestContentLengthMismatchError:RequestContentLengthMismatchError,ResponseContentLengthMismatchError:ResponseContentLengthMismatchError,RequestAbortedError:RequestAbortedError,HeadersTimeoutError:HeadersTimeoutError,HeadersOverflowError:HeadersOverflowError,SocketError:SocketError,InformationalError:InformationalError,BodyTimeoutError:BodyTimeoutError,HTTPParserError:HTTPParserError,ResponseExceededMaxSizeError:ResponseExceededMaxSizeError}=require("../core/errors.js"),{kUrl:kUrl,kReset:kReset,kClient:kClient,kParser:kParser,kBlocking:kBlocking,kRunning:kRunning,kPending:kPending,kSize:kSize,kWriting:kWriting,kQueue:kQueue,kNoRef:kNoRef,kKeepAliveDefaultTimeout:kKeepAliveDefaultTimeout,kHostHeader:kHostHeader,kPendingIdx:kPendingIdx,kRunningIdx:kRunningIdx,kError:kError,kPipelining:kPipelining,kSocket:kSocket,kKeepAliveTimeoutValue:kKeepAliveTimeoutValue,kMaxHeadersSize:kMaxHeadersSize,kKeepAliveMaxTimeout:kKeepAliveMaxTimeout,kKeepAliveTimeoutThreshold:kKeepAliveTimeoutThreshold,kHeadersTimeout:kHeadersTimeout,kBodyTimeout:kBodyTimeout,kStrictContentLength:kStrictContentLength,kMaxRequests:kMaxRequests,kCounter:kCounter,kMaxResponseSize:kMaxResponseSize,kOnError:kOnError,kResume:kResume,kHTTPContext:kHTTPContext}=require("../core/symbols.js"),constants=require("../llhttp/constants.js"),EMPTY_BUF=Buffer.alloc(0),FastBuffer=Buffer[Symbol.species],addListener=util.addListener,removeAllListeners=util.removeAllListeners;let extractBody;async function lazyllhttp(){const e=process.env.JEST_WORKER_ID?require("../llhttp/llhttp-wasm.js"):void 0;let t;try{t=await WebAssembly.compile(require("../llhttp/llhttp_simd-wasm.js"))}catch(r){t=await WebAssembly.compile(e||require("../llhttp/llhttp-wasm.js"))}return await WebAssembly.instantiate(t,{env:{wasm_on_url:(e,t,r)=>0,wasm_on_status:(e,t,r)=>{assert(currentParser.ptr===e);const s=t-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer,s,r))||0},wasm_on_message_begin:e=>(assert(currentParser.ptr===e),currentParser.onMessageBegin()||0),wasm_on_header_field:(e,t,r)=>{assert(currentParser.ptr===e);const s=t-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer,s,r))||0},wasm_on_header_value:(e,t,r)=>{assert(currentParser.ptr===e);const s=t-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer,s,r))||0},wasm_on_headers_complete:(e,t,r,s)=>(assert(currentParser.ptr===e),currentParser.onHeadersComplete(t,Boolean(r),Boolean(s))||0),wasm_on_body:(e,t,r)=>{assert(currentParser.ptr===e);const s=t-currentBufferPtr+currentBufferRef.byteOffset;return currentParser.onBody(new FastBuffer(currentBufferRef.buffer,s,r))||0},wasm_on_message_complete:e=>(assert(currentParser.ptr===e),currentParser.onMessageComplete()||0)}})}let llhttpInstance=null,llhttpPromise=lazyllhttp();llhttpPromise.catch();let currentParser=null,currentBufferRef=null,currentBufferSize=0,currentBufferPtr=null;const USE_NATIVE_TIMER=0,USE_FAST_TIMER=1,TIMEOUT_HEADERS=3,TIMEOUT_BODY=5,TIMEOUT_KEEP_ALIVE=8;class Parser{constructor(e,t,{exports:r}){assert(Number.isFinite(e[kMaxHeadersSize])&&e[kMaxHeadersSize]>0),this.llhttp=r,this.ptr=this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE),this.client=e,this.socket=t,this.timeout=null,this.timeoutValue=null,this.timeoutType=null,this.statusCode=null,this.statusText="",this.upgrade=!1,this.headers=[],this.headersSize=0,this.headersMaxSize=e[kMaxHeadersSize],this.shouldKeepAlive=!1,this.paused=!1,this.resume=this.resume.bind(this),this.bytesRead=0,this.keepAlive="",this.contentLength="",this.connection="",this.maxResponseSize=e[kMaxResponseSize]}setTimeout(e,t){e!==this.timeoutValue||1&t^1&this.timeoutType?(this.timeout&&(timers.clearTimeout(this.timeout),this.timeout=null),e&&(1&t?this.timeout=timers.setFastTimeout(onParserTimeout,e,new WeakRef(this)):(this.timeout=setTimeout(onParserTimeout,e,new WeakRef(this)),this.timeout.unref())),this.timeoutValue=e):this.timeout&&this.timeout.refresh&&this.timeout.refresh(),this.timeoutType=t}resume(){!this.socket.destroyed&&this.paused&&(assert(null!=this.ptr),assert(null==currentParser),this.llhttp.llhttp_resume(this.ptr),assert(5===this.timeoutType),this.timeout&&this.timeout.refresh&&this.timeout.refresh(),this.paused=!1,this.execute(this.socket.read()||EMPTY_BUF),this.readMore())}readMore(){for(;!this.paused&&this.ptr;){const e=this.socket.read();if(null===e)break;this.execute(e)}}execute(e){assert(null!=this.ptr),assert(null==currentParser),assert(!this.paused);const{socket:t,llhttp:r}=this;e.length>currentBufferSize&&(currentBufferPtr&&r.free(currentBufferPtr),currentBufferSize=4096*Math.ceil(e.length/4096),currentBufferPtr=r.malloc(currentBufferSize)),new Uint8Array(r.memory.buffer,currentBufferPtr,currentBufferSize).set(e);try{let s;try{currentBufferRef=e,currentParser=this,s=r.llhttp_execute(this.ptr,currentBufferPtr,e.length)}catch(e){throw e}finally{currentParser=null,currentBufferRef=null}const n=r.llhttp_get_error_pos(this.ptr)-currentBufferPtr;if(s===constants.ERROR.PAUSED_UPGRADE)this.onUpgrade(e.slice(n));else if(s===constants.ERROR.PAUSED)this.paused=!0,t.unshift(e.slice(n));else if(s!==constants.ERROR.OK){const t=r.llhttp_get_error_reason(this.ptr);let i="";if(t){const e=new Uint8Array(r.memory.buffer,t).indexOf(0);i="Response does not match the HTTP/1.1 protocol ("+Buffer.from(r.memory.buffer,t,e).toString()+")"}throw new HTTPParserError(i,constants.ERROR[s],e.slice(n))}}catch(e){util.destroy(t,e)}}destroy(){assert(null!=this.ptr),assert(null==currentParser),this.llhttp.llhttp_free(this.ptr),this.ptr=null,this.timeout&&timers.clearTimeout(this.timeout),this.timeout=null,this.timeoutValue=null,this.timeoutType=null,this.paused=!1}onStatus(e){this.statusText=e.toString()}onMessageBegin(){const{socket:e,client:t}=this;if(e.destroyed)return-1;const r=t[kQueue][t[kRunningIdx]];if(!r)return-1;r.onResponseStarted()}onHeaderField(e){const t=this.headers.length;1&t?this.headers[t-1]=Buffer.concat([this.headers[t-1],e]):this.headers.push(e),this.trackHeader(e.length)}onHeaderValue(e){let t=this.headers.length;1&~t?this.headers[t-1]=Buffer.concat([this.headers[t-1],e]):(this.headers.push(e),t+=1);const r=this.headers[t-2];if(10===r.length){const t=util.bufferToLowerCasedHeaderName(r);"keep-alive"===t?this.keepAlive+=e.toString():"connection"===t&&(this.connection+=e.toString())}else 14===r.length&&"content-length"===util.bufferToLowerCasedHeaderName(r)&&(this.contentLength+=e.toString());this.trackHeader(e.length)}trackHeader(e){this.headersSize+=e,this.headersSize>=this.headersMaxSize&&util.destroy(this.socket,new HeadersOverflowError)}onUpgrade(e){const{upgrade:t,client:r,socket:s,headers:n,statusCode:i}=this;assert(t),assert(r[kSocket]===s),assert(!s.destroyed),assert(!this.paused),assert(!(1&n.length));const o=r[kQueue][r[kRunningIdx]];assert(o),assert(o.upgrade||"CONNECT"===o.method),this.statusCode=null,this.statusText="",this.shouldKeepAlive=null,this.headers=[],this.headersSize=0,s.unshift(e),s[kParser].destroy(),s[kParser]=null,s[kClient]=null,s[kError]=null,removeAllListeners(s),r[kSocket]=null,r[kHTTPContext]=null,r[kQueue][r[kRunningIdx]++]=null,r.emit("disconnect",r[kUrl],[r],new InformationalError("upgrade"));try{o.onUpgrade(i,n,s)}catch(e){util.destroy(s,e)}r[kResume]()}onHeadersComplete(e,t,r){const{client:s,socket:n,headers:i,statusText:o}=this;if(n.destroyed)return-1;const u=s[kQueue][s[kRunningIdx]];if(!u)return-1;if(assert(!this.upgrade),assert(this.statusCode<200),100===e)return util.destroy(n,new SocketError("bad response",util.getSocketInfo(n))),-1;if(t&&!u.upgrade)return util.destroy(n,new SocketError("bad upgrade",util.getSocketInfo(n))),-1;if(assert(3===this.timeoutType),this.statusCode=e,this.shouldKeepAlive=r||"HEAD"===u.method&&!n[kReset]&&"keep-alive"===this.connection.toLowerCase(),this.statusCode>=200){const e=null!=u.bodyTimeout?u.bodyTimeout:s[kBodyTimeout];this.setTimeout(e,5)}else this.timeout&&this.timeout.refresh&&this.timeout.refresh();if("CONNECT"===u.method)return assert(1===s[kRunning]),this.upgrade=!0,2;if(t)return assert(1===s[kRunning]),this.upgrade=!0,2;if(assert(!(1&this.headers.length)),this.headers=[],this.headersSize=0,this.shouldKeepAlive&&s[kPipelining]){const e=this.keepAlive?util.parseKeepAliveTimeout(this.keepAlive):null;if(null!=e){const t=Math.min(e-s[kKeepAliveTimeoutThreshold],s[kKeepAliveMaxTimeout]);t<=0?n[kReset]=!0:s[kKeepAliveTimeoutValue]=t}else s[kKeepAliveTimeoutValue]=s[kKeepAliveDefaultTimeout]}else n[kReset]=!0;const a=!1===u.onHeaders(e,i,this.resume,o);return u.aborted?-1:"HEAD"===u.method||e<200?1:(n[kBlocking]&&(n[kBlocking]=!1,s[kResume]()),a?constants.ERROR.PAUSED:0)}onBody(e){const{client:t,socket:r,statusCode:s,maxResponseSize:n}=this;if(r.destroyed)return-1;const i=t[kQueue][t[kRunningIdx]];return assert(i),assert(5===this.timeoutType),this.timeout&&this.timeout.refresh&&this.timeout.refresh(),assert(s>=200),n>-1&&this.bytesRead+e.length>n?(util.destroy(r,new ResponseExceededMaxSizeError),-1):(this.bytesRead+=e.length,!1===i.onData(e)?constants.ERROR.PAUSED:void 0)}onMessageComplete(){const{client:e,socket:t,statusCode:r,upgrade:s,headers:n,contentLength:i,bytesRead:o,shouldKeepAlive:u}=this;if(t.destroyed&&(!r||u))return-1;if(s)return;assert(r>=100),assert(!(1&this.headers.length));const a=e[kQueue][e[kRunningIdx]];return assert(a),this.statusCode=null,this.statusText="",this.bytesRead=0,this.contentLength="",this.keepAlive="",this.connection="",this.headers=[],this.headersSize=0,r<200?void 0:"HEAD"!==a.method&&i&&o!==parseInt(i,10)?(util.destroy(t,new ResponseContentLengthMismatchError),-1):(a.onComplete(n),e[kQueue][e[kRunningIdx]++]=null,t[kWriting]?(assert(0===e[kRunning]),util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED):u?t[kReset]&&0===e[kRunning]?(util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED):void(null==e[kPipelining]||1===e[kPipelining]?setImmediate(()=>e[kResume]()):e[kResume]()):(util.destroy(t,new InformationalError("reset")),constants.ERROR.PAUSED))}}function onParserTimeout(e){const{socket:t,timeoutType:r,client:s,paused:n}=e.deref();3===r?(!t[kWriting]||t.writableNeedDrain||s[kRunning]>1)&&(assert(!n,"cannot be paused while waiting for headers"),util.destroy(t,new HeadersTimeoutError)):5===r?n||util.destroy(t,new BodyTimeoutError):8===r&&(assert(0===s[kRunning]&&s[kKeepAliveTimeoutValue]),util.destroy(t,new InformationalError("socket idle timeout")))}async function connectH1(e,t){e[kSocket]=t,llhttpInstance||(llhttpInstance=await llhttpPromise,llhttpPromise=null),t[kNoRef]=!1,t[kWriting]=!1,t[kReset]=!1,t[kBlocking]=!1,t[kParser]=new Parser(e,t,llhttpInstance),addListener(t,"error",function(e){assert("ERR_TLS_CERT_ALTNAME_INVALID"!==e.code);const t=this[kParser];"ECONNRESET"!==e.code||!t.statusCode||t.shouldKeepAlive?(this[kError]=e,this[kClient][kOnError](e)):t.onMessageComplete()}),addListener(t,"readable",function(){const e=this[kParser];e&&e.readMore()}),addListener(t,"end",function(){const e=this[kParser];!e.statusCode||e.shouldKeepAlive?util.destroy(this,new SocketError("other side closed",util.getSocketInfo(this))):e.onMessageComplete()}),addListener(t,"close",function(){const e=this[kClient],t=this[kParser];t&&(this[kError]||!t.statusCode||t.shouldKeepAlive||t.onMessageComplete(),this[kParser].destroy(),this[kParser]=null);const r=this[kError]||new SocketError("closed",util.getSocketInfo(this));if(e[kSocket]=null,e[kHTTPContext]=null,e.destroyed){assert(0===e[kPending]);const t=e[kQueue].splice(e[kRunningIdx]);for(let s=0;s<t.length;s++){const n=t[s];util.errorRequest(e,n,r)}}else if(e[kRunning]>0&&"UND_ERR_INFO"!==r.code){const t=e[kQueue][e[kRunningIdx]];e[kQueue][e[kRunningIdx]++]=null,util.errorRequest(e,t,r)}e[kPendingIdx]=e[kRunningIdx],assert(0===e[kRunning]),e.emit("disconnect",e[kUrl],[e],r),e[kResume]()});let r=!1;return t.on("close",()=>{r=!0}),{version:"h1",defaultPipelining:1,write:(...t)=>writeH1(e,...t),resume(){resumeH1(e)},destroy(e,s){r?queueMicrotask(s):t.destroy(e).on("close",s)},get destroyed(){return t.destroyed},busy(r){if(t[kWriting]||t[kReset]||t[kBlocking])return!0;if(r){if(e[kRunning]>0&&!r.idempotent)return!0;if(e[kRunning]>0&&(r.upgrade||"CONNECT"===r.method))return!0;if(e[kRunning]>0&&0!==util.bodyLength(r.body)&&(util.isStream(r.body)||util.isAsyncIterable(r.body)||util.isFormDataLike(r.body)))return!0}return!1}}}function resumeH1(e){const t=e[kSocket];if(t&&!t.destroyed)if(0===e[kSize]?!t[kNoRef]&&t.unref&&(t.unref(),t[kNoRef]=!0):t[kNoRef]&&t.ref&&(t.ref(),t[kNoRef]=!1),0===e[kSize])8!==t[kParser].timeoutType&&t[kParser].setTimeout(e[kKeepAliveTimeoutValue],8);else if(e[kRunning]>0&&t[kParser].statusCode<200&&3!==t[kParser].timeoutType){const r=e[kQueue][e[kRunningIdx]],s=null!=r.headersTimeout?r.headersTimeout:e[kHeadersTimeout];t[kParser].setTimeout(s,3)}}function shouldSendContentLength(e){return"GET"!==e&&"HEAD"!==e&&"OPTIONS"!==e&&"TRACE"!==e&&"CONNECT"!==e}function writeH1(e,t){const{method:r,path:s,host:n,upgrade:i,blocking:o,reset:u}=t;let{body:a,headers:l,contentLength:c}=t;const h="PUT"===r||"POST"===r||"PATCH"===r||"QUERY"===r||"PROPFIND"===r||"PROPPATCH"===r;if(util.isFormDataLike(a)){extractBody||(extractBody=require("../web/fetch/body.js").extractBody);const[e,r]=extractBody(a);null==t.contentType&&l.push("content-type",r),a=e.stream,c=e.length}else util.isBlobLike(a)&&null==t.contentType&&a.type&&l.push("content-type",a.type);a&&"function"==typeof a.read&&a.read(0);const d=util.bodyLength(a);if(c=d??c,null===c&&(c=t.contentLength),0!==c||h||(c=null),shouldSendContentLength(r)&&c>0&&null!==t.contentLength&&t.contentLength!==c){if(e[kStrictContentLength])return util.errorRequest(e,t,new RequestContentLengthMismatchError),!1;process.emitWarning(new RequestContentLengthMismatchError)}const k=e[kSocket],f=r=>{t.aborted||t.completed||(util.errorRequest(e,t,r||new RequestAbortedError),util.destroy(a),util.destroy(k,new InformationalError("aborted")))};try{t.onConnect(f)}catch(r){util.errorRequest(e,t,r)}if(t.aborted)return!1;"HEAD"===r&&(k[kReset]=!0),(i||"CONNECT"===r)&&(k[kReset]=!0),null!=u&&(k[kReset]=u),e[kMaxRequests]&&k[kCounter]++>=e[kMaxRequests]&&(k[kReset]=!0),o&&(k[kBlocking]=!0);let m=`${r} ${s} HTTP/1.1\r\n`;if(m+="string"==typeof n?`host: ${n}\r\n`:e[kHostHeader],i?m+=`connection: upgrade\r\nupgrade: ${i}\r\n`:e[kPipelining]&&!k[kReset]?m+="connection: keep-alive\r\n":m+="connection: close\r\n",Array.isArray(l))for(let e=0;e<l.length;e+=2){const t=l[e+0],r=l[e+1];if(Array.isArray(r))for(let e=0;e<r.length;e++)m+=`${t}: ${r[e]}\r\n`;else m+=`${t}: ${r}\r\n`}return channels.sendHeaders.hasSubscribers&&channels.sendHeaders.publish({request:t,headers:m,socket:k}),a&&0!==d?util.isBuffer(a)?writeBuffer(f,a,e,t,k,c,m,h):util.isBlobLike(a)?"function"==typeof a.stream?writeIterable(f,a.stream(),e,t,k,c,m,h):writeBlob(f,a,e,t,k,c,m,h):util.isStream(a)?writeStream(f,a,e,t,k,c,m,h):util.isIterable(a)?writeIterable(f,a,e,t,k,c,m,h):assert(!1):writeBuffer(f,null,e,t,k,c,m,h),!0}function writeStream(e,t,r,s,n,i,o,u){assert(0!==i||0===r[kRunning],"stream body cannot be pipelined");let a=!1;const l=new AsyncWriter({abort:e,socket:n,request:s,contentLength:i,client:r,expectsPayload:u,header:o}),c=function(e){if(!a)try{!l.write(e)&&this.pause&&this.pause()}catch(e){util.destroy(this,e)}},h=function(){a||t.resume&&t.resume()},d=function(){if(queueMicrotask(()=>{t.removeListener("error",k)}),!a){const e=new RequestAbortedError;queueMicrotask(()=>k(e))}},k=function(e){if(!a){if(a=!0,assert(n.destroyed||n[kWriting]&&r[kRunning]<=1),n.off("drain",h).off("error",k),t.removeListener("data",c).removeListener("end",k).removeListener("close",d),!e)try{l.end()}catch(t){e=t}l.destroy(e),!e||"UND_ERR_INFO"===e.code&&"reset"===e.message?util.destroy(t):util.destroy(t,e)}};t.on("data",c).on("end",k).on("error",k).on("close",d),t.resume&&t.resume(),n.on("drain",h).on("error",k),t.errorEmitted??t.errored?setImmediate(()=>k(t.errored)):(t.endEmitted??t.readableEnded)&&setImmediate(()=>k(null)),(t.closeEmitted??t.closed)&&setImmediate(d)}function writeBuffer(e,t,r,s,n,i,o,u){try{t?util.isBuffer(t)&&(assert(i===t.byteLength,"buffer body must have content length"),n.cork(),n.write(`${o}content-length: ${i}\r\n\r\n`,"latin1"),n.write(t),n.uncork(),s.onBodySent(t),u||!1===s.reset||(n[kReset]=!0)):0===i?n.write(`${o}content-length: 0\r\n\r\n`,"latin1"):(assert(null===i,"no body must not have content length"),n.write(`${o}\r\n`,"latin1")),s.onRequestSent(),r[kResume]()}catch(t){e(t)}}async function writeBlob(e,t,r,s,n,i,o,u){assert(i===t.size,"blob body must have content length");try{if(null!=i&&i!==t.size)throw new RequestContentLengthMismatchError;const e=Buffer.from(await t.arrayBuffer());n.cork(),n.write(`${o}content-length: ${i}\r\n\r\n`,"latin1"),n.write(e),n.uncork(),s.onBodySent(e),s.onRequestSent(),u||!1===s.reset||(n[kReset]=!0),r[kResume]()}catch(t){e(t)}}async function writeIterable(e,t,r,s,n,i,o,u){assert(0!==i||0===r[kRunning],"iterator body cannot be pipelined");let a=null;function l(){if(a){const e=a;a=null,e()}}const c=()=>new Promise((e,t)=>{assert(null===a),n[kError]?t(n[kError]):a=e});n.on("close",l).on("drain",l);const h=new AsyncWriter({abort:e,socket:n,request:s,contentLength:i,client:r,expectsPayload:u,header:o});try{for await(const e of t){if(n[kError])throw n[kError];h.write(e)||await c()}h.end()}catch(e){h.destroy(e)}finally{n.off("close",l).off("drain",l)}}class AsyncWriter{constructor({abort:e,socket:t,request:r,contentLength:s,client:n,expectsPayload:i,header:o}){this.socket=t,this.request=r,this.contentLength=s,this.client=n,this.bytesWritten=0,this.expectsPayload=i,this.header=o,this.abort=e,t[kWriting]=!0}write(e){const{socket:t,request:r,contentLength:s,client:n,bytesWritten:i,expectsPayload:o,header:u}=this;if(t[kError])throw t[kError];if(t.destroyed)return!1;const a=Buffer.byteLength(e);if(!a)return!0;if(null!==s&&i+a>s){if(n[kStrictContentLength])throw new RequestContentLengthMismatchError;process.emitWarning(new RequestContentLengthMismatchError)}t.cork(),0===i&&(o||!1===r.reset||(t[kReset]=!0),null===s?t.write(`${u}transfer-encoding: chunked\r\n`,"latin1"):t.write(`${u}content-length: ${s}\r\n\r\n`,"latin1")),null===s&&t.write(`\r\n${a.toString(16)}\r\n`,"latin1"),this.bytesWritten+=a;const l=t.write(e);return t.uncork(),r.onBodySent(e),l||t[kParser].timeout&&3===t[kParser].timeoutType&&t[kParser].timeout.refresh&&t[kParser].timeout.refresh(),l}end(){const{socket:e,contentLength:t,client:r,bytesWritten:s,expectsPayload:n,header:i,request:o}=this;if(o.onRequestSent(),e[kWriting]=!1,e[kError])throw e[kError];if(!e.destroyed){if(0===s?n?e.write(`${i}content-length: 0\r\n\r\n`,"latin1"):e.write(`${i}\r\n`,"latin1"):null===t&&e.write("\r\n0\r\n\r\n","latin1"),null!==t&&s!==t){if(r[kStrictContentLength])throw new RequestContentLengthMismatchError;process.emitWarning(new RequestContentLengthMismatchError)}e[kParser].timeout&&3===e[kParser].timeoutType&&e[kParser].timeout.refresh&&e[kParser].timeout.refresh(),r[kResume]()}}destroy(e){const{socket:t,client:r,abort:s}=this;t[kWriting]=!1,e&&(assert(r[kRunning]<=1,"pipeline should only contain this request"),s(e))}}module.exports=connectH1;