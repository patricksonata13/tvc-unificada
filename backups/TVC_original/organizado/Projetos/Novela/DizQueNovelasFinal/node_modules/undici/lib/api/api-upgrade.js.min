"use strict";const{InvalidArgumentError:InvalidArgumentError,SocketError:SocketError}=require("../core/errors"),{AsyncResource:AsyncResource}=require("node:async_hooks"),util=require("../core/util"),{addSignal:addSignal,removeSignal:removeSignal}=require("./abort-signal"),assert=require("node:assert");class UpgradeHandler extends AsyncResource{constructor(e,r){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof r)throw new InvalidArgumentError("invalid callback");const{signal:t,opaque:n,responseHeaders:o}=e;if(t&&"function"!=typeof t.on&&"function"!=typeof t.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");super("UNDICI_UPGRADE"),this.responseHeaders=o||null,this.opaque=n||null,this.callback=r,this.abort=null,this.context=null,addSignal(this,t)}onConnect(e,r){this.reason?e(this.reason):(assert(this.callback),this.abort=e,this.context=null)}onHeaders(){throw new SocketError("bad upgrade",null)}onUpgrade(e,r,t){assert(101===e);const{callback:n,opaque:o,context:s}=this;removeSignal(this),this.callback=null;const a="raw"===this.responseHeaders?util.parseRawHeaders(r):util.parseHeaders(r);this.runInAsyncScope(n,null,null,{headers:a,socket:t,opaque:o,context:s})}onError(e){const{callback:r,opaque:t}=this;removeSignal(this),r&&(this.callback=null,queueMicrotask(()=>{this.runInAsyncScope(r,null,e,{opaque:t})}))}}function upgrade(e,r){if(void 0===r)return new Promise((r,t)=>{upgrade.call(this,e,(e,n)=>e?t(e):r(n))});try{const t=new UpgradeHandler(e,r);this.dispatch({...e,method:e.method||"GET",upgrade:e.protocol||"Websocket"},t)}catch(t){if("function"!=typeof r)throw t;const n=e?.opaque;queueMicrotask(()=>r(t,{opaque:n}))}}module.exports=upgrade;