"use strict";const net=require("node:net"),assert=require("node:assert"),util=require("./util"),{InvalidArgumentError:InvalidArgumentError,ConnectTimeoutError:ConnectTimeoutError}=require("./errors"),timers=require("../util/timers");function noop(){}let tls,SessionCache;function buildConnector({allowH2:e,maxCachedSessions:t,socketPath:s,timeout:o,session:n,...i}){if(null!=t&&(!Number.isInteger(t)||t<0))throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");const r={path:s,...i},a=new SessionCache(null==t?100:t);return o=null==o?1e4:o,e=null!=e&&e,function({hostname:t,host:s,protocol:i,port:l,servername:c,localAddress:u,httpSocket:m},h){let d;if("https:"===i){tls||(tls=require("node:tls"));const o=(c=c||r.servername||util.getServerName(s)||null)||t;assert(o);const i=n||a.get(o)||null;l=l||443,d=tls.connect({highWaterMark:16384,...r,servername:c,session:i,localAddress:u,ALPNProtocols:e?["http/1.1","h2"]:["http/1.1"],socket:m,port:l,host:t}),d.on("session",function(e){a.set(o,e)})}else assert(!m,"httpSocket can only be sent on TLS update"),l=l||80,d=net.connect({highWaterMark:65536,...r,localAddress:u,port:l,host:t});if(null==r.keepAlive||r.keepAlive){const e=void 0===r.keepAliveInitialDelay?6e4:r.keepAliveInitialDelay;d.setKeepAlive(!0,e)}const C=setupConnectTimeout(new WeakRef(d),{timeout:o,hostname:t,port:l});return d.setNoDelay(!0).once("https:"===i?"secureConnect":"connect",function(){if(queueMicrotask(C),h){const e=h;h=null,e(null,this)}}).on("error",function(e){if(queueMicrotask(C),h){const t=h;h=null,t(e)}}),d}}SessionCache=!global.FinalizationRegistry||process.env.NODE_V8_COVERAGE||process.env.UNDICI_NO_FG?class{constructor(e){this._maxCachedSessions=e,this._sessionCache=new Map}get(e){return this._sessionCache.get(e)}set(e,t){if(0!==this._maxCachedSessions){if(this._sessionCache.size>=this._maxCachedSessions){const{value:e}=this._sessionCache.keys().next();this._sessionCache.delete(e)}this._sessionCache.set(e,t)}}}:class{constructor(e){this._maxCachedSessions=e,this._sessionCache=new Map,this._sessionRegistry=new global.FinalizationRegistry(e=>{if(this._sessionCache.size<this._maxCachedSessions)return;const t=this._sessionCache.get(e);void 0!==t&&void 0===t.deref()&&this._sessionCache.delete(e)})}get(e){const t=this._sessionCache.get(e);return t?t.deref():null}set(e,t){0!==this._maxCachedSessions&&(this._sessionCache.set(e,new WeakRef(t)),this._sessionRegistry.register(t,e))}};const setupConnectTimeout="win32"===process.platform?(e,t)=>{if(!t.timeout)return noop;let s=null,o=null;const n=timers.setFastTimeout(()=>{s=setImmediate(()=>{o=setImmediate(()=>onConnectTimeout(e.deref(),t))})},t.timeout);return()=>{timers.clearFastTimeout(n),clearImmediate(s),clearImmediate(o)}}:(e,t)=>{if(!t.timeout)return noop;let s=null;const o=timers.setFastTimeout(()=>{s=setImmediate(()=>{onConnectTimeout(e.deref(),t)})},t.timeout);return()=>{timers.clearFastTimeout(o),clearImmediate(s)}};function onConnectTimeout(e,t){if(null==e)return;let s="Connect Timeout Error";Array.isArray(e.autoSelectFamilyAttemptedAddresses)?s+=` (attempted addresses: ${e.autoSelectFamilyAttemptedAddresses.join(", ")},`:s+=` (attempted address: ${t.hostname}:${t.port},`,s+=` timeout: ${t.timeout}ms)`,util.destroy(e,new ConnectTimeoutError(s))}module.exports=buildConnector;