"use strict";const{kProxy:kProxy,kClose:kClose,kDestroy:kDestroy,kDispatch:kDispatch,kInterceptors:kInterceptors}=require("../core/symbols"),{URL:URL}=require("node:url"),Agent=require("./agent"),Pool=require("./pool"),DispatcherBase=require("./dispatcher-base"),{InvalidArgumentError:InvalidArgumentError,RequestAbortedError:RequestAbortedError,SecureProxyConnectionError:SecureProxyConnectionError}=require("../core/errors"),buildConnector=require("../core/connect"),Client=require("./client"),kAgent=Symbol("proxy agent"),kClient=Symbol("proxy client"),kProxyHeaders=Symbol("proxy headers"),kRequestTls=Symbol("request tls settings"),kProxyTls=Symbol("proxy tls settings"),kConnectEndpoint=Symbol("connect endpoint function"),kTunnelProxy=Symbol("tunnel proxy");function defaultProtocolPort(t){return"https:"===t?443:80}function defaultFactory(t,e){return new Pool(t,e)}const noop=()=>{};function defaultAgentFactory(t,e){return 1===e.connections?new Client(t,e):new Pool(t,e)}class Http1ProxyWrapper extends DispatcherBase{#t;constructor(t,{headers:e={},connect:r,factory:o}){if(super(),!t)throw new InvalidArgumentError("Proxy URL is mandatory");this[kProxyHeaders]=e,this.#t=o?o(t,{connect:r}):new Client(t,{connect:r})}[kDispatch](t,e){const r=e.onHeaders;e.onHeaders=function(t,o,n){407!==t?r&&r.call(this,t,o,n):"function"==typeof e.onError&&e.onError(new InvalidArgumentError("Proxy Authentication Required (407)"))};const{origin:o,path:n="/",headers:s={}}=t;if(t.path=o+n,!("host"in s)&&!("Host"in s)){const{host:t}=new URL(o);s.host=t}return t.headers={...this[kProxyHeaders],...s},this.#t[kDispatch](t,e)}async[kClose](){return this.#t.close()}async[kDestroy](t){return this.#t.destroy(t)}}class ProxyAgent extends DispatcherBase{constructor(t){if(super(),!t||"object"==typeof t&&!(t instanceof URL)&&!t.uri)throw new InvalidArgumentError("Proxy uri is mandatory");const{clientFactory:e=defaultFactory}=t;if("function"!=typeof e)throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");const{proxyTunnel:r=!0}=t,o=this.#e(t),{href:n,origin:s,port:i,protocol:c,username:a,password:u,hostname:l}=o;if(this[kProxy]={uri:n,protocol:c},this[kInterceptors]=t.interceptors?.ProxyAgent&&Array.isArray(t.interceptors.ProxyAgent)?t.interceptors.ProxyAgent:[],this[kRequestTls]=t.requestTls,this[kProxyTls]=t.proxyTls,this[kProxyHeaders]=t.headers||{},this[kTunnelProxy]=r,t.auth&&t.token)throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");t.auth?this[kProxyHeaders]["proxy-authorization"]=`Basic ${t.auth}`:t.token?this[kProxyHeaders]["proxy-authorization"]=t.token:a&&u&&(this[kProxyHeaders]["proxy-authorization"]=`Basic ${Buffer.from(`${decodeURIComponent(a)}:${decodeURIComponent(u)}`).toString("base64")}`);const h=buildConnector({...t.proxyTls});this[kConnectEndpoint]=buildConnector({...t.requestTls});const y=t.factory||defaultAgentFactory;this[kClient]=e(o,{connect:h}),this[kAgent]=new Agent({...t,factory:(t,e)=>{const{protocol:r}=new URL(t);return this[kTunnelProxy]||"http:"!==r||"http:"!==this[kProxy].protocol?y(t,e):new Http1ProxyWrapper(this[kProxy].uri,{headers:this[kProxyHeaders],connect:h,factory:y})},connect:async(t,e)=>{let r=t.host;t.port||(r+=`:${defaultProtocolPort(t.protocol)}`);try{const{socket:o,statusCode:n}=await this[kClient].connect({origin:s,port:i,path:r,signal:t.signal,headers:{...this[kProxyHeaders],host:t.host},servername:this[kProxyTls]?.servername||l});if(200!==n&&(o.on("error",noop).destroy(),e(new RequestAbortedError(`Proxy response (${n}) !== 200 when HTTP Tunneling`))),"https:"!==t.protocol)return void e(null,o);let c;c=this[kRequestTls]?this[kRequestTls].servername:t.servername,this[kConnectEndpoint]({...t,servername:c,httpSocket:o},e)}catch(t){"ERR_TLS_CERT_ALTNAME_INVALID"===t.code?e(new SecureProxyConnectionError(t)):e(t)}}})}dispatch(t,e){const r=buildHeaders(t.headers);if(throwIfProxyAuthIsSent(r),r&&!("host"in r)&&!("Host"in r)){const{host:e}=new URL(t.origin);r.host=e}return this[kAgent].dispatch({...t,headers:r},e)}#e(t){return"string"==typeof t?new URL(t):t instanceof URL?t:new URL(t.uri)}async[kClose](){await this[kAgent].close(),await this[kClient].close()}async[kDestroy](){await this[kAgent].destroy(),await this[kClient].destroy()}}function buildHeaders(t){if(Array.isArray(t)){const e={};for(let r=0;r<t.length;r+=2)e[t[r]]=t[r+1];return e}return t}function throwIfProxyAuthIsSent(t){if(t&&Object.keys(t).find(t=>"proxy-authorization"===t.toLowerCase()))throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor")}module.exports=ProxyAgent;