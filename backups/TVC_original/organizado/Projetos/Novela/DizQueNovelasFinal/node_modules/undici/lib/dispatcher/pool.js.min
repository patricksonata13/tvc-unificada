"use strict";const{PoolBase:PoolBase,kClients:kClients,kNeedDrain:kNeedDrain,kAddClient:kAddClient,kGetDispatcher:kGetDispatcher}=require("./pool-base"),Client=require("./client"),{InvalidArgumentError:InvalidArgumentError}=require("../core/errors"),util=require("../core/util"),{kUrl:kUrl,kInterceptors:kInterceptors}=require("../core/symbols"),buildConnector=require("../core/connect"),kOptions=Symbol("options"),kConnections=Symbol("connections"),kFactory=Symbol("factory");function defaultFactory(t,e){return new Client(t,e)}class Pool extends PoolBase{constructor(t,{connections:e,factory:o=defaultFactory,connect:n,connectTimeout:i,tls:r,maxCachedSessions:s,socketPath:c,autoSelectFamily:l,autoSelectFamilyAttemptTimeout:a,allowH2:u,...k}={}){if(super(),null!=e&&(!Number.isFinite(e)||e<0))throw new InvalidArgumentError("invalid connections");if("function"!=typeof o)throw new InvalidArgumentError("factory must be a function.");if(null!=n&&"function"!=typeof n&&"object"!=typeof n)throw new InvalidArgumentError("connect must be a function or an object");"function"!=typeof n&&(n=buildConnector({...r,maxCachedSessions:s,allowH2:u,socketPath:c,timeout:i,...l?{autoSelectFamily:l,autoSelectFamilyAttemptTimeout:a}:void 0,...n})),this[kInterceptors]=k.interceptors?.Pool&&Array.isArray(k.interceptors.Pool)?k.interceptors.Pool:[],this[kConnections]=e||null,this[kUrl]=util.parseOrigin(t),this[kOptions]={...util.deepClone(k),connect:n,allowH2:u},this[kOptions].interceptors=k.interceptors?{...k.interceptors}:void 0,this[kFactory]=o,this.on("connectionError",(t,e,o)=>{for(const t of e){const e=this[kClients].indexOf(t);-1!==e&&this[kClients].splice(e,1)}})}[kGetDispatcher](){for(const t of this[kClients])if(!t[kNeedDrain])return t;if(!this[kConnections]||this[kClients].length<this[kConnections]){const t=this[kFactory](this[kUrl],this[kOptions]);return this[kAddClient](t),t}}}module.exports=Pool;