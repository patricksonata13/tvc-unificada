"use strict";const Dispatcher=require("./dispatcher"),{ClientDestroyedError:ClientDestroyedError,ClientClosedError:ClientClosedError,InvalidArgumentError:InvalidArgumentError}=require("../core/errors"),{kDestroy:kDestroy,kClose:kClose,kClosed:kClosed,kDestroyed:kDestroyed,kDispatch:kDispatch,kInterceptors:kInterceptors}=require("../core/symbols"),kOnDestroyed=Symbol("onDestroyed"),kOnClosed=Symbol("onClosed"),kInterceptedDispatch=Symbol("Intercepted Dispatch");class DispatcherBase extends Dispatcher{constructor(){super(),this[kDestroyed]=!1,this[kOnDestroyed]=null,this[kClosed]=!1,this[kOnClosed]=[]}get destroyed(){return this[kDestroyed]}get closed(){return this[kClosed]}get interceptors(){return this[kInterceptors]}set interceptors(e){if(e)for(let t=e.length-1;t>=0;t--){if("function"!=typeof this[kInterceptors][t])throw new InvalidArgumentError("interceptor must be an function")}this[kInterceptors]=e}close(e){if(void 0===e)return new Promise((e,t)=>{this.close((r,s)=>r?t(r):e(s))});if("function"!=typeof e)throw new InvalidArgumentError("invalid callback");if(this[kDestroyed])return void queueMicrotask(()=>e(new ClientDestroyedError,null));if(this[kClosed])return void(this[kOnClosed]?this[kOnClosed].push(e):queueMicrotask(()=>e(null,null)));this[kClosed]=!0,this[kOnClosed].push(e);const t=()=>{const e=this[kOnClosed];this[kOnClosed]=null;for(let t=0;t<e.length;t++)e[t](null,null)};this[kClose]().then(()=>this.destroy()).then(()=>{queueMicrotask(t)})}destroy(e,t){if("function"==typeof e&&(t=e,e=null),void 0===t)return new Promise((t,r)=>{this.destroy(e,(e,s)=>e?r(e):t(s))});if("function"!=typeof t)throw new InvalidArgumentError("invalid callback");if(this[kDestroyed])return void(this[kOnDestroyed]?this[kOnDestroyed].push(t):queueMicrotask(()=>t(null,null)));e||(e=new ClientDestroyedError),this[kDestroyed]=!0,this[kOnDestroyed]=this[kOnDestroyed]||[],this[kOnDestroyed].push(t);const r=()=>{const e=this[kOnDestroyed];this[kOnDestroyed]=null;for(let t=0;t<e.length;t++)e[t](null,null)};this[kDestroy](e).then(()=>{queueMicrotask(r)})}[kInterceptedDispatch](e,t){if(!this[kInterceptors]||0===this[kInterceptors].length)return this[kInterceptedDispatch]=this[kDispatch],this[kDispatch](e,t);let r=this[kDispatch].bind(this);for(let e=this[kInterceptors].length-1;e>=0;e--)r=this[kInterceptors][e](r);return this[kInterceptedDispatch]=r,r(e,t)}dispatch(e,t){if(!t||"object"!=typeof t)throw new InvalidArgumentError("handler must be an object");try{if(!e||"object"!=typeof e)throw new InvalidArgumentError("opts must be an object.");if(this[kDestroyed]||this[kOnDestroyed])throw new ClientDestroyedError;if(this[kClosed])throw new ClientClosedError;return this[kInterceptedDispatch](e,t)}catch(e){if("function"!=typeof t.onError)throw new InvalidArgumentError("invalid onError method");return t.onError(e),!1}}}module.exports=DispatcherBase;