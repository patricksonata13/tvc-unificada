"use strict";const assert=require("node:assert"),net=require("node:net"),http=require("node:http"),util=require("../core/util.js"),{channels:channels}=require("../core/diagnostics.js"),Request=require("../core/request.js"),DispatcherBase=require("./dispatcher-base"),{InvalidArgumentError:InvalidArgumentError,InformationalError:InformationalError,ClientDestroyedError:ClientDestroyedError}=require("../core/errors.js"),buildConnector=require("../core/connect.js"),{kUrl:kUrl,kServerName:kServerName,kClient:kClient,kBusy:kBusy,kConnect:kConnect,kResuming:kResuming,kRunning:kRunning,kPending:kPending,kSize:kSize,kQueue:kQueue,kConnected:kConnected,kConnecting:kConnecting,kNeedDrain:kNeedDrain,kKeepAliveDefaultTimeout:kKeepAliveDefaultTimeout,kHostHeader:kHostHeader,kPendingIdx:kPendingIdx,kRunningIdx:kRunningIdx,kError:kError,kPipelining:kPipelining,kKeepAliveTimeoutValue:kKeepAliveTimeoutValue,kMaxHeadersSize:kMaxHeadersSize,kKeepAliveMaxTimeout:kKeepAliveMaxTimeout,kKeepAliveTimeoutThreshold:kKeepAliveTimeoutThreshold,kHeadersTimeout:kHeadersTimeout,kBodyTimeout:kBodyTimeout,kStrictContentLength:kStrictContentLength,kConnector:kConnector,kMaxRedirections:kMaxRedirections,kMaxRequests:kMaxRequests,kCounter:kCounter,kClose:kClose,kDestroy:kDestroy,kDispatch:kDispatch,kInterceptors:kInterceptors,kLocalAddress:kLocalAddress,kMaxResponseSize:kMaxResponseSize,kOnError:kOnError,kHTTPContext:kHTTPContext,kMaxConcurrentStreams:kMaxConcurrentStreams,kResume:kResume}=require("../core/symbols.js"),connectH1=require("./client-h1.js"),connectH2=require("./client-h2.js");let deprecatedInterceptorWarned=!1;const kClosedResolve=Symbol("kClosedResolve"),noop=()=>{};function getPipelining(e){return e[kPipelining]??e[kHTTPContext]?.defaultPipelining??1}class Client extends DispatcherBase{constructor(e,{interceptors:t,maxHeaderSize:n,headersTimeout:r,socketTimeout:i,requestTimeout:o,connectTimeout:s,bodyTimeout:u,idleTimeout:l,keepAlive:a,keepAliveTimeout:k,maxKeepAliveTimeout:d,keepAliveMaxTimeout:c,keepAliveTimeoutThreshold:m,socketPath:h,pipelining:p,tls:g,strictContentLength:v,maxCachedSessions:T,maxRedirections:C,connect:x,maxRequestsPerClient:R,localAddress:I,maxResponseSize:A,autoSelectFamily:P,autoSelectFamilyAttemptTimeout:f,maxConcurrentStreams:b,allowH2:w}={}){if(super(),void 0!==a)throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");if(void 0!==i)throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");if(void 0!==o)throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");if(void 0!==l)throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");if(void 0!==d)throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");if(null!=n&&!Number.isFinite(n))throw new InvalidArgumentError("invalid maxHeaderSize");if(null!=h&&"string"!=typeof h)throw new InvalidArgumentError("invalid socketPath");if(null!=s&&(!Number.isFinite(s)||s<0))throw new InvalidArgumentError("invalid connectTimeout");if(null!=k&&(!Number.isFinite(k)||k<=0))throw new InvalidArgumentError("invalid keepAliveTimeout");if(null!=c&&(!Number.isFinite(c)||c<=0))throw new InvalidArgumentError("invalid keepAliveMaxTimeout");if(null!=m&&!Number.isFinite(m))throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");if(null!=r&&(!Number.isInteger(r)||r<0))throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");if(null!=u&&(!Number.isInteger(u)||u<0))throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");if(null!=x&&"function"!=typeof x&&"object"!=typeof x)throw new InvalidArgumentError("connect must be a function or an object");if(null!=C&&(!Number.isInteger(C)||C<0))throw new InvalidArgumentError("maxRedirections must be a positive number");if(null!=R&&(!Number.isInteger(R)||R<0))throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");if(null!=I&&("string"!=typeof I||0===net.isIP(I)))throw new InvalidArgumentError("localAddress must be valid string IP address");if(null!=A&&(!Number.isInteger(A)||A<-1))throw new InvalidArgumentError("maxResponseSize must be a positive number");if(null!=f&&(!Number.isInteger(f)||f<-1))throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");if(null!=w&&"boolean"!=typeof w)throw new InvalidArgumentError("allowH2 must be a valid boolean value");if(null!=b&&("number"!=typeof b||b<1))throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");"function"!=typeof x&&(x=buildConnector({...g,maxCachedSessions:T,allowH2:w,socketPath:h,timeout:s,...P?{autoSelectFamily:P,autoSelectFamilyAttemptTimeout:f}:void 0,...x})),t?.Client&&Array.isArray(t.Client)?(this[kInterceptors]=t.Client,deprecatedInterceptorWarned||(deprecatedInterceptorWarned=!0,process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.",{code:"UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"}))):this[kInterceptors]=[createRedirectInterceptor({maxRedirections:C})],this[kUrl]=util.parseOrigin(e),this[kConnector]=x,this[kPipelining]=null!=p?p:1,this[kMaxHeadersSize]=n||http.maxHeaderSize,this[kKeepAliveDefaultTimeout]=null==k?4e3:k,this[kKeepAliveMaxTimeout]=null==c?6e5:c,this[kKeepAliveTimeoutThreshold]=null==m?2e3:m,this[kKeepAliveTimeoutValue]=this[kKeepAliveDefaultTimeout],this[kServerName]=null,this[kLocalAddress]=null!=I?I:null,this[kResuming]=0,this[kNeedDrain]=0,this[kHostHeader]=`host: ${this[kUrl].hostname}${this[kUrl].port?`:${this[kUrl].port}`:""}\r\n`,this[kBodyTimeout]=null!=u?u:3e5,this[kHeadersTimeout]=null!=r?r:3e5,this[kStrictContentLength]=null==v||v,this[kMaxRedirections]=C,this[kMaxRequests]=R,this[kClosedResolve]=null,this[kMaxResponseSize]=A>-1?A:-1,this[kMaxConcurrentStreams]=null!=b?b:100,this[kHTTPContext]=null,this[kQueue]=[],this[kRunningIdx]=0,this[kPendingIdx]=0,this[kResume]=e=>resume(this,e),this[kOnError]=e=>onError(this,e)}get pipelining(){return this[kPipelining]}set pipelining(e){this[kPipelining]=e,this[kResume](!0)}get[kPending](){return this[kQueue].length-this[kPendingIdx]}get[kRunning](){return this[kPendingIdx]-this[kRunningIdx]}get[kSize](){return this[kQueue].length-this[kRunningIdx]}get[kConnected](){return!!this[kHTTPContext]&&!this[kConnecting]&&!this[kHTTPContext].destroyed}get[kBusy](){return Boolean(this[kHTTPContext]?.busy(null)||this[kSize]>=(getPipelining(this)||1)||this[kPending]>0)}[kConnect](e){connect(this),this.once("connect",e)}[kDispatch](e,t){const n=e.origin||this[kUrl].origin,r=new Request(n,e,t);return this[kQueue].push(r),this[kResuming]||(null==util.bodyLength(r.body)&&util.isIterable(r.body)?(this[kResuming]=1,queueMicrotask(()=>resume(this))):this[kResume](!0)),this[kResuming]&&2!==this[kNeedDrain]&&this[kBusy]&&(this[kNeedDrain]=2),this[kNeedDrain]<2}async[kClose](){return new Promise(e=>{this[kSize]?this[kClosedResolve]=e:e(null)})}async[kDestroy](e){return new Promise(t=>{const n=this[kQueue].splice(this[kPendingIdx]);for(let t=0;t<n.length;t++){const r=n[t];util.errorRequest(this,r,e)}const r=()=>{this[kClosedResolve]&&(this[kClosedResolve](),this[kClosedResolve]=null),t(null)};this[kHTTPContext]?(this[kHTTPContext].destroy(e,r),this[kHTTPContext]=null):queueMicrotask(r),this[kResume]()})}}const createRedirectInterceptor=require("../interceptor/redirect-interceptor.js");function onError(e,t){if(0===e[kRunning]&&"UND_ERR_INFO"!==t.code&&"UND_ERR_SOCKET"!==t.code){assert(e[kPendingIdx]===e[kRunningIdx]);const n=e[kQueue].splice(e[kRunningIdx]);for(let r=0;r<n.length;r++){const i=n[r];util.errorRequest(e,i,t)}assert(0===e[kSize])}}async function connect(e){assert(!e[kConnecting]),assert(!e[kHTTPContext]);let{host:t,hostname:n,protocol:r,port:i}=e[kUrl];if("["===n[0]){const e=n.indexOf("]");assert(-1!==e);const t=n.substring(1,e);assert(net.isIP(t)),n=t}e[kConnecting]=!0,channels.beforeConnect.hasSubscribers&&channels.beforeConnect.publish({connectParams:{host:t,hostname:n,protocol:r,port:i,version:e[kHTTPContext]?.version,servername:e[kServerName],localAddress:e[kLocalAddress]},connector:e[kConnector]});try{const o=await new Promise((o,s)=>{e[kConnector]({host:t,hostname:n,protocol:r,port:i,servername:e[kServerName],localAddress:e[kLocalAddress]},(e,t)=>{e?s(e):o(t)})});if(e.destroyed)return void util.destroy(o.on("error",noop),new ClientDestroyedError);assert(o);try{e[kHTTPContext]="h2"===o.alpnProtocol?await connectH2(e,o):await connectH1(e,o)}catch(e){throw o.destroy().on("error",noop),e}e[kConnecting]=!1,o[kCounter]=0,o[kMaxRequests]=e[kMaxRequests],o[kClient]=e,o[kError]=null,channels.connected.hasSubscribers&&channels.connected.publish({connectParams:{host:t,hostname:n,protocol:r,port:i,version:e[kHTTPContext]?.version,servername:e[kServerName],localAddress:e[kLocalAddress]},connector:e[kConnector],socket:o}),e.emit("connect",e[kUrl],[e])}catch(o){if(e.destroyed)return;if(e[kConnecting]=!1,channels.connectError.hasSubscribers&&channels.connectError.publish({connectParams:{host:t,hostname:n,protocol:r,port:i,version:e[kHTTPContext]?.version,servername:e[kServerName],localAddress:e[kLocalAddress]},connector:e[kConnector],error:o}),"ERR_TLS_CERT_ALTNAME_INVALID"===o.code)for(assert(0===e[kRunning]);e[kPending]>0&&e[kQueue][e[kPendingIdx]].servername===e[kServerName];){const t=e[kQueue][e[kPendingIdx]++];util.errorRequest(e,t,o)}else onError(e,o);e.emit("connectionError",e[kUrl],[e],o)}e[kResume]()}function emitDrain(e){e[kNeedDrain]=0,e.emit("drain",e[kUrl],[e])}function resume(e,t){2!==e[kResuming]&&(e[kResuming]=2,_resume(e,t),e[kResuming]=0,e[kRunningIdx]>256&&(e[kQueue].splice(0,e[kRunningIdx]),e[kPendingIdx]-=e[kRunningIdx],e[kRunningIdx]=0))}function _resume(e,t){for(;;){if(e.destroyed)return void assert(0===e[kPending]);if(e[kClosedResolve]&&!e[kSize])return e[kClosedResolve](),void(e[kClosedResolve]=null);if(e[kHTTPContext]&&e[kHTTPContext].resume(),e[kBusy])e[kNeedDrain]=2;else if(2===e[kNeedDrain]){t?(e[kNeedDrain]=1,queueMicrotask(()=>emitDrain(e))):emitDrain(e);continue}if(0===e[kPending])return;if(e[kRunning]>=(getPipelining(e)||1))return;const n=e[kQueue][e[kPendingIdx]];if("https:"===e[kUrl].protocol&&e[kServerName]!==n.servername){if(e[kRunning]>0)return;e[kServerName]=n.servername,e[kHTTPContext]?.destroy(new InformationalError("servername changed"),()=>{e[kHTTPContext]=null,resume(e)})}if(e[kConnecting])return;if(!e[kHTTPContext])return void connect(e);if(e[kHTTPContext].destroyed)return;if(e[kHTTPContext].busy(n))return;!n.aborted&&e[kHTTPContext].write(n)?e[kPendingIdx]++:e[kQueue].splice(e[kPendingIdx],1)}}module.exports=Client;