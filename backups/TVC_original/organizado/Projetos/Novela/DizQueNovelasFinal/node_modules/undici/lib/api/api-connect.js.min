"use strict";const assert=require("node:assert"),{AsyncResource:AsyncResource}=require("node:async_hooks"),{InvalidArgumentError:InvalidArgumentError,SocketError:SocketError}=require("../core/errors"),util=require("../core/util"),{addSignal:addSignal,removeSignal:removeSignal}=require("./abort-signal");class ConnectHandler extends AsyncResource{constructor(e,n){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof n)throw new InvalidArgumentError("invalid callback");const{signal:r,opaque:t,responseHeaders:o}=e;if(r&&"function"!=typeof r.on&&"function"!=typeof r.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");super("UNDICI_CONNECT"),this.opaque=t||null,this.responseHeaders=o||null,this.callback=n,this.abort=null,addSignal(this,r)}onConnect(e,n){this.reason?e(this.reason):(assert(this.callback),this.abort=e,this.context=n)}onHeaders(){throw new SocketError("bad connect",null)}onUpgrade(e,n,r){const{callback:t,opaque:o,context:s}=this;removeSignal(this),this.callback=null;let a=n;null!=a&&(a="raw"===this.responseHeaders?util.parseRawHeaders(n):util.parseHeaders(n)),this.runInAsyncScope(t,null,null,{statusCode:e,headers:a,socket:r,opaque:o,context:s})}onError(e){const{callback:n,opaque:r}=this;removeSignal(this),n&&(this.callback=null,queueMicrotask(()=>{this.runInAsyncScope(n,null,e,{opaque:r})}))}}function connect(e,n){if(void 0===n)return new Promise((n,r)=>{connect.call(this,e,(e,t)=>e?r(e):n(t))});try{const r=new ConnectHandler(e,n);this.dispatch({...e,method:"CONNECT"},r)}catch(r){if("function"!=typeof n)throw r;const t=e?.opaque;queueMicrotask(()=>n(r,{opaque:t}))}}module.exports=connect;