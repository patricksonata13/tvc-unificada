"use strict";const{uid:uid,states:states,sentCloseFrameState:sentCloseFrameState,emptyBuffer:emptyBuffer,opcodes:opcodes}=require("./constants"),{kReadyState:kReadyState,kSentClose:kSentClose,kByteParser:kByteParser,kReceivedClose:kReceivedClose,kResponse:kResponse}=require("./symbols"),{fireEvent:fireEvent,failWebsocketConnection:failWebsocketConnection,isClosing:isClosing,isClosed:isClosed,isEstablished:isEstablished,parseExtensions:parseExtensions}=require("./util"),{channels:channels}=require("../../core/diagnostics"),{CloseEvent:CloseEvent}=require("./events"),{makeRequest:makeRequest}=require("../fetch/request"),{fetching:fetching}=require("../fetch/index"),{Headers:Headers,getHeadersList:getHeadersList}=require("../fetch/headers"),{getDecodeSplit:getDecodeSplit}=require("../fetch/util"),{WebsocketFrameSend:WebsocketFrameSend}=require("./frame");let crypto;try{crypto=require("node:crypto")}catch{}function establishWebSocketConnection(e,t,s,o,n,r){const c=e;c.protocol="ws:"===e.protocol?"http:":"https:";const a=makeRequest({urlList:[c],client:s,serviceWorkers:"none",referrer:"no-referrer",mode:"websocket",credentials:"include",cache:"no-store",redirect:"error"});if(r.headers){const e=getHeadersList(new Headers(r.headers));a.headersList=e}const i=crypto.randomBytes(16).toString("base64");a.headersList.append("sec-websocket-key",i),a.headersList.append("sec-websocket-version","13");for(const e of t)a.headersList.append("sec-websocket-protocol",e);a.headersList.append("sec-websocket-extensions","permessage-deflate; client_max_window_bits");return fetching({request:a,useParallelQueue:!0,dispatcher:r.dispatcher,processResponse(e){if("error"===e.type||101!==e.status)return void failWebsocketConnection(o,"Received network error or non-101 status code.");if(0!==t.length&&!e.headersList.get("Sec-WebSocket-Protocol"))return void failWebsocketConnection(o,"Server did not respond with sent protocols.");if("websocket"!==e.headersList.get("Upgrade")?.toLowerCase())return void failWebsocketConnection(o,'Server did not set Upgrade header to "websocket".');if("upgrade"!==e.headersList.get("Connection")?.toLowerCase())return void failWebsocketConnection(o,'Server did not set Connection header to "upgrade".');if(e.headersList.get("Sec-WebSocket-Accept")!==crypto.createHash("sha1").update(i+uid).digest("base64"))return void failWebsocketConnection(o,"Incorrect hash received in Sec-WebSocket-Accept header.");const s=e.headersList.get("Sec-WebSocket-Extensions");let r;if(null!==s&&(r=parseExtensions(s),!r.has("permessage-deflate")))return void failWebsocketConnection(o,"Sec-WebSocket-Extensions header does not match.");const c=e.headersList.get("Sec-WebSocket-Protocol");if(null!==c){if(!getDecodeSplit("sec-websocket-protocol",a.headersList).includes(c))return void failWebsocketConnection(o,"Protocol was not set in the opening handshake.")}e.socket.on("data",onSocketData),e.socket.on("close",onSocketClose),e.socket.on("error",onSocketError),channels.open.hasSubscribers&&channels.open.publish({address:e.socket.address(),protocol:c,extensions:s}),n(e,r)}})}function closeWebSocketConnection(e,t,s,o){if(isClosing(e)||isClosed(e));else if(isEstablished(e))if(e[kSentClose]===sentCloseFrameState.NOT_SENT){e[kSentClose]=sentCloseFrameState.PROCESSING;const n=new WebsocketFrameSend;void 0!==t&&void 0===s?(n.frameData=Buffer.allocUnsafe(2),n.frameData.writeUInt16BE(t,0)):void 0!==t&&void 0!==s?(n.frameData=Buffer.allocUnsafe(2+o),n.frameData.writeUInt16BE(t,0),n.frameData.write(s,2,"utf-8")):n.frameData=emptyBuffer;e[kResponse].socket.write(n.createFrame(opcodes.CLOSE)),e[kSentClose]=sentCloseFrameState.SENT,e[kReadyState]=states.CLOSING}else e[kReadyState]=states.CLOSING;else failWebsocketConnection(e,"Connection was closed before it was established."),e[kReadyState]=states.CLOSING}function onSocketData(e){this.ws[kByteParser].write(e)||this.pause()}function onSocketClose(){const{ws:e}=this,{[kResponse]:t}=e;t.socket.off("data",onSocketData),t.socket.off("close",onSocketClose),t.socket.off("error",onSocketError);const s=e[kSentClose]===sentCloseFrameState.SENT&&e[kReceivedClose];let o=1005,n="";const r=e[kByteParser].closingInfo;r&&!r.error?(o=r.code??1005,n=r.reason):e[kReceivedClose]||(o=1006),e[kReadyState]=states.CLOSED,fireEvent("close",e,(e,t)=>new CloseEvent(e,t),{wasClean:s,code:o,reason:n}),channels.close.hasSubscribers&&channels.close.publish({websocket:e,code:o,reason:n})}function onSocketError(e){const{ws:t}=this;t[kReadyState]=states.CLOSING,channels.socketError.hasSubscribers&&channels.socketError.publish(e),this.destroy()}module.exports={establishWebSocketConnection:establishWebSocketConnection,closeWebSocketConnection:closeWebSocketConnection};