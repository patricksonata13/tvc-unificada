"use strict";const DispatcherBase=require("./dispatcher-base"),FixedQueue=require("./fixed-queue"),{kConnected:kConnected,kSize:kSize,kRunning:kRunning,kPending:kPending,kQueued:kQueued,kBusy:kBusy,kFree:kFree,kUrl:kUrl,kClose:kClose,kDestroy:kDestroy,kDispatch:kDispatch}=require("../core/symbols"),PoolStats=require("./pool-stats"),kClients=Symbol("clients"),kNeedDrain=Symbol("needDrain"),kQueue=Symbol("queue"),kClosedResolve=Symbol("closed resolve"),kOnDrain=Symbol("onDrain"),kOnConnect=Symbol("onConnect"),kOnDisconnect=Symbol("onDisconnect"),kOnConnectionError=Symbol("onConnectionError"),kGetDispatcher=Symbol("get dispatcher"),kAddClient=Symbol("add client"),kRemoveClient=Symbol("remove client"),kStats=Symbol("stats");class PoolBase extends DispatcherBase{constructor(){super(),this[kQueue]=new FixedQueue,this[kClients]=[],this[kQueued]=0;const e=this;this[kOnDrain]=function(t,n){const i=e[kQueue];let s=!1;for(;!s;){const t=i.shift();if(!t)break;e[kQueued]--,s=!this.dispatch(t.opts,t.handler)}this[kNeedDrain]=s,!this[kNeedDrain]&&e[kNeedDrain]&&(e[kNeedDrain]=!1,e.emit("drain",t,[e,...n])),e[kClosedResolve]&&i.isEmpty()&&Promise.all(e[kClients].map(e=>e.close())).then(e[kClosedResolve])},this[kOnConnect]=(t,n)=>{e.emit("connect",t,[e,...n])},this[kOnDisconnect]=(t,n,i)=>{e.emit("disconnect",t,[e,...n],i)},this[kOnConnectionError]=(t,n,i)=>{e.emit("connectionError",t,[e,...n],i)},this[kStats]=new PoolStats(this)}get[kBusy](){return this[kNeedDrain]}get[kConnected](){return this[kClients].filter(e=>e[kConnected]).length}get[kFree](){return this[kClients].filter(e=>e[kConnected]&&!e[kNeedDrain]).length}get[kPending](){let e=this[kQueued];for(const{[kPending]:t}of this[kClients])e+=t;return e}get[kRunning](){let e=0;for(const{[kRunning]:t}of this[kClients])e+=t;return e}get[kSize](){let e=this[kQueued];for(const{[kSize]:t}of this[kClients])e+=t;return e}get stats(){return this[kStats]}async[kClose](){this[kQueue].isEmpty()?await Promise.all(this[kClients].map(e=>e.close())):await new Promise(e=>{this[kClosedResolve]=e})}async[kDestroy](e){for(;;){const t=this[kQueue].shift();if(!t)break;t.handler.onError(e)}await Promise.all(this[kClients].map(t=>t.destroy(e)))}[kDispatch](e,t){const n=this[kGetDispatcher]();return n?n.dispatch(e,t)||(n[kNeedDrain]=!0,this[kNeedDrain]=!this[kGetDispatcher]()):(this[kNeedDrain]=!0,this[kQueue].push({opts:e,handler:t}),this[kQueued]++),!this[kNeedDrain]}[kAddClient](e){return e.on("drain",this[kOnDrain]).on("connect",this[kOnConnect]).on("disconnect",this[kOnDisconnect]).on("connectionError",this[kOnConnectionError]),this[kClients].push(e),this[kNeedDrain]&&queueMicrotask(()=>{this[kNeedDrain]&&this[kOnDrain](e[kUrl],[this,e])}),this}[kRemoveClient](e){e.close(()=>{const t=this[kClients].indexOf(e);-1!==t&&this[kClients].splice(t,1)}),this[kNeedDrain]=this[kClients].some(e=>!e[kNeedDrain]&&!0!==e.closed&&!0!==e.destroyed)}}module.exports={PoolBase:PoolBase,kClients:kClients,kNeedDrain:kNeedDrain,kAddClient:kAddClient,kRemoveClient:kRemoveClient,kGetDispatcher:kGetDispatcher};