"use strict";const assert=require("node:assert"),{pipeline:pipeline}=require("node:stream"),util=require("../core/util.js"),{RequestContentLengthMismatchError:RequestContentLengthMismatchError,RequestAbortedError:RequestAbortedError,SocketError:SocketError,InformationalError:InformationalError}=require("../core/errors.js"),{kUrl:kUrl,kReset:kReset,kClient:kClient,kRunning:kRunning,kPending:kPending,kQueue:kQueue,kPendingIdx:kPendingIdx,kRunningIdx:kRunningIdx,kError:kError,kSocket:kSocket,kStrictContentLength:kStrictContentLength,kOnError:kOnError,kMaxConcurrentStreams:kMaxConcurrentStreams,kHTTP2Session:kHTTP2Session,kResume:kResume,kSize:kSize,kHTTPContext:kHTTPContext}=require("../core/symbols.js"),kOpenStreams=Symbol("open streams");let extractBody,http2,h2ExperimentalWarned=!1;try{http2=require("node:http2")}catch{http2={constants:{}}}const{constants:{HTTP2_HEADER_AUTHORITY:HTTP2_HEADER_AUTHORITY,HTTP2_HEADER_METHOD:HTTP2_HEADER_METHOD,HTTP2_HEADER_PATH:HTTP2_HEADER_PATH,HTTP2_HEADER_SCHEME:HTTP2_HEADER_SCHEME,HTTP2_HEADER_CONTENT_LENGTH:HTTP2_HEADER_CONTENT_LENGTH,HTTP2_HEADER_EXPECT:HTTP2_HEADER_EXPECT,HTTP2_HEADER_STATUS:HTTP2_HEADER_STATUS}}=http2;function parseH2Headers(e){const t=[];for(const[n,r]of Object.entries(e))if(Array.isArray(r))for(const e of r)t.push(Buffer.from(n),Buffer.from(e));else t.push(Buffer.from(n),Buffer.from(r));return t}async function connectH2(e,t){e[kSocket]=t,h2ExperimentalWarned||(h2ExperimentalWarned=!0,process.emitWarning("H2 support is experimental, expect them to change at any time.",{code:"UNDICI-H2"}));const n=http2.connect(e[kUrl],{createConnection:()=>t,peerMaxConcurrentStreams:e[kMaxConcurrentStreams]});n[kOpenStreams]=0,n[kClient]=e,n[kSocket]=t,util.addListener(n,"error",onHttp2SessionError),util.addListener(n,"frameError",onHttp2FrameError),util.addListener(n,"end",onHttp2SessionEnd),util.addListener(n,"goaway",onHTTP2GoAway),util.addListener(n,"close",function(){const{[kClient]:e}=this,{[kSocket]:t}=e,n=this[kSocket][kError]||this[kError]||new SocketError("closed",util.getSocketInfo(t));if(e[kHTTP2Session]=null,e.destroyed){assert(0===e[kPending]);const t=e[kQueue].splice(e[kRunningIdx]);for(let r=0;r<t.length;r++){const o=t[r];util.errorRequest(e,o,n)}}}),n.unref(),e[kHTTP2Session]=n,t[kHTTP2Session]=n,util.addListener(t,"error",function(e){assert("ERR_TLS_CERT_ALTNAME_INVALID"!==e.code),this[kError]=e,this[kClient][kOnError](e)}),util.addListener(t,"end",function(){util.destroy(this,new SocketError("other side closed",util.getSocketInfo(this)))}),util.addListener(t,"close",function(){const t=this[kError]||new SocketError("closed",util.getSocketInfo(this));e[kSocket]=null,null!=this[kHTTP2Session]&&this[kHTTP2Session].destroy(t),e[kPendingIdx]=e[kRunningIdx],assert(0===e[kRunning]),e.emit("disconnect",e[kUrl],[e],t),e[kResume]()});let r=!1;return t.on("close",()=>{r=!0}),{version:"h2",defaultPipelining:1/0,write:(...t)=>writeH2(e,...t),resume(){resumeH2(e)},destroy(e,n){r?queueMicrotask(n):t.destroy(e).on("close",n)},get destroyed(){return t.destroyed},busy:()=>!1}}function resumeH2(e){const t=e[kSocket];!1===t?.destroyed&&(0===e[kSize]&&0===e[kMaxConcurrentStreams]?(t.unref(),e[kHTTP2Session].unref()):(t.ref(),e[kHTTP2Session].ref()))}function onHttp2SessionError(e){assert("ERR_TLS_CERT_ALTNAME_INVALID"!==e.code),this[kSocket][kError]=e,this[kClient][kOnError](e)}function onHttp2FrameError(e,t,n){if(0===n){const n=new InformationalError(`HTTP/2: "frameError" received - type ${e}, code ${t}`);this[kSocket][kError]=n,this[kClient][kOnError](n)}}function onHttp2SessionEnd(){const e=new SocketError("other side closed",util.getSocketInfo(this[kSocket]));this.destroy(e),util.destroy(this[kSocket],e)}function onHTTP2GoAway(e){const t=this[kError]||new SocketError(`HTTP/2: "GOAWAY" frame received with code ${e}`,util.getSocketInfo(this)),n=this[kClient];if(n[kSocket]=null,n[kHTTPContext]=null,null!=this[kHTTP2Session]&&(this[kHTTP2Session].destroy(t),this[kHTTP2Session]=null),util.destroy(this[kSocket],t),n[kRunningIdx]<n[kQueue].length){const e=n[kQueue][n[kRunningIdx]];n[kQueue][n[kRunningIdx]++]=null,util.errorRequest(n,e,t),n[kPendingIdx]=n[kRunningIdx]}assert(0===n[kRunning]),n.emit("disconnect",n[kUrl],[n],t),n[kResume]()}function shouldSendContentLength(e){return"GET"!==e&&"HEAD"!==e&&"OPTIONS"!==e&&"TRACE"!==e&&"CONNECT"!==e}function writeH2(e,t){const n=e[kHTTP2Session],{method:r,path:o,host:s,upgrade:i,expectContinue:u,signal:c,headers:l}=t;let{body:k}=t;if(i)return util.errorRequest(e,t,new Error("Upgrade not supported for H2")),!1;const a={};for(let e=0;e<l.length;e+=2){const t=l[e+0],n=l[e+1];if(Array.isArray(n))for(let e=0;e<n.length;e++)a[t]?a[t]+=`,${n[e]}`:a[t]=n[e];else a[t]=n}let d;const{hostname:T,port:E}=e[kUrl];a[HTTP2_HEADER_AUTHORITY]=s||`${T}${E?`:${E}`:""}`,a[HTTP2_HEADER_METHOD]=r;const f=n=>{t.aborted||t.completed||(n=n||new RequestAbortedError,util.errorRequest(e,t,n),null!=d&&util.destroy(d,n),util.destroy(k,n),e[kQueue][e[kRunningIdx]++]=null,e[kResume]())};try{t.onConnect(f)}catch(n){util.errorRequest(e,t,n)}if(t.aborted)return!1;if("CONNECT"===r)return n.ref(),d=n.request(a,{endStream:!1,signal:c}),d.id&&!d.pending?(t.onUpgrade(null,null,d),++n[kOpenStreams],e[kQueue][e[kRunningIdx]++]=null):d.once("ready",()=>{t.onUpgrade(null,null,d),++n[kOpenStreams],e[kQueue][e[kRunningIdx]++]=null}),d.once("close",()=>{n[kOpenStreams]-=1,0===n[kOpenStreams]&&n.unref()}),!0;a[HTTP2_HEADER_PATH]=o,a[HTTP2_HEADER_SCHEME]="https";const H="PUT"===r||"POST"===r||"PATCH"===r;k&&"function"==typeof k.read&&k.read(0);let S=util.bodyLength(k);if(util.isFormDataLike(k)){extractBody??=require("../web/fetch/body.js").extractBody;const[e,t]=extractBody(k);a["content-type"]=t,k=e.stream,S=e.length}if(null==S&&(S=t.contentLength),0!==S&&H||(S=null),shouldSendContentLength(r)&&S>0&&null!=t.contentLength&&t.contentLength!==S){if(e[kStrictContentLength])return util.errorRequest(e,t,new RequestContentLengthMismatchError),!1;process.emitWarning(new RequestContentLengthMismatchError)}null!=S&&(assert(k,"no body must not have content length"),a[HTTP2_HEADER_CONTENT_LENGTH]=`${S}`),n.ref();const h="GET"===r||"HEAD"===r||null===k;return u?(a[HTTP2_HEADER_EXPECT]="100-continue",d=n.request(a,{endStream:h,signal:c}),d.once("continue",m)):(d=n.request(a,{endStream:h,signal:c}),m()),++n[kOpenStreams],d.once("response",n=>{const{[HTTP2_HEADER_STATUS]:r,...o}=n;if(t.onResponseStarted(),t.aborted){const n=new RequestAbortedError;return util.errorRequest(e,t,n),void util.destroy(d,n)}!1===t.onHeaders(Number(r),parseH2Headers(o),d.resume.bind(d),"")&&d.pause(),d.on("data",e=>{!1===t.onData(e)&&d.pause()})}),d.once("end",()=>{(null==d.state?.state||d.state.state<6)&&t.onComplete([]),0===n[kOpenStreams]&&n.unref(),f(new InformationalError("HTTP/2: stream half-closed (remote)")),e[kQueue][e[kRunningIdx]++]=null,e[kPendingIdx]=e[kRunningIdx],e[kResume]()}),d.once("close",()=>{n[kOpenStreams]-=1,0===n[kOpenStreams]&&n.unref()}),d.once("error",function(e){f(e)}),d.once("frameError",(e,t)=>{f(new InformationalError(`HTTP/2: "frameError" received - type ${e}, code ${t}`))}),!0;function m(){k&&0!==S?util.isBuffer(k)?writeBuffer(f,d,k,e,t,e[kSocket],S,H):util.isBlobLike(k)?"function"==typeof k.stream?writeIterable(f,d,k.stream(),e,t,e[kSocket],S,H):writeBlob(f,d,k,e,t,e[kSocket],S,H):util.isStream(k)?writeStream(f,e[kSocket],H,d,k,e,t,S):util.isIterable(k)?writeIterable(f,d,k,e,t,e[kSocket],S,H):assert(!1):writeBuffer(f,d,null,e,t,e[kSocket],S,H)}}function writeBuffer(e,t,n,r,o,s,i,u){try{null!=n&&util.isBuffer(n)&&(assert(i===n.byteLength,"buffer body must have content length"),t.cork(),t.write(n),t.uncork(),t.end(),o.onBodySent(n)),u||(s[kReset]=!0),o.onRequestSent(),r[kResume]()}catch(t){e(t)}}function writeStream(e,t,n,r,o,s,i,u){assert(0!==u||0===s[kRunning],"stream body cannot be pipelined");const c=pipeline(o,r,r=>{r?(util.destroy(c,r),e(r)):(util.removeAllListeners(c),i.onRequestSent(),n||(t[kReset]=!0),s[kResume]())});util.addListener(c,"data",function(e){i.onBodySent(e)})}async function writeBlob(e,t,n,r,o,s,i,u){assert(i===n.size,"blob body must have content length");try{if(null!=i&&i!==n.size)throw new RequestContentLengthMismatchError;const e=Buffer.from(await n.arrayBuffer());t.cork(),t.write(e),t.uncork(),t.end(),o.onBodySent(e),o.onRequestSent(),u||(s[kReset]=!0),r[kResume]()}catch(t){e(t)}}async function writeIterable(e,t,n,r,o,s,i,u){assert(0!==i||0===r[kRunning],"iterator body cannot be pipelined");let c=null;function l(){if(c){const e=c;c=null,e()}}const k=()=>new Promise((e,t)=>{assert(null===c),s[kError]?t(s[kError]):c=e});t.on("close",l).on("drain",l);try{for await(const e of n){if(s[kError])throw s[kError];const n=t.write(e);o.onBodySent(e),n||await k()}t.end(),o.onRequestSent(),u||(s[kReset]=!0),r[kResume]()}catch(t){e(t)}finally{t.off("close",l).off("drain",l)}}module.exports=connectH2;