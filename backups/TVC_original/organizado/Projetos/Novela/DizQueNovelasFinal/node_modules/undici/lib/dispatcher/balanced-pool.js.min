"use strict";const{BalancedPoolMissingUpstreamError:BalancedPoolMissingUpstreamError,InvalidArgumentError:InvalidArgumentError}=require("../core/errors"),{PoolBase:PoolBase,kClients:kClients,kNeedDrain:kNeedDrain,kAddClient:kAddClient,kRemoveClient:kRemoveClient,kGetDispatcher:kGetDispatcher}=require("./pool-base"),Pool=require("./pool"),{kUrl:kUrl,kInterceptors:kInterceptors}=require("../core/symbols"),{parseOrigin:parseOrigin}=require("../core/util"),kFactory=Symbol("factory"),kOptions=Symbol("options"),kGreatestCommonDivisor=Symbol("kGreatestCommonDivisor"),kCurrentWeight=Symbol("kCurrentWeight"),kIndex=Symbol("kIndex"),kWeight=Symbol("kWeight"),kMaxWeightPerServer=Symbol("kMaxWeightPerServer"),kErrorPenalty=Symbol("kErrorPenalty");function getGreatestCommonDivisor(e,t){if(0===e)return t;for(;0!==t;){const r=t;t=e%t,e=r}return e}function defaultFactory(e,t){return new Pool(e,t)}class BalancedPool extends PoolBase{constructor(e=[],{factory:t=defaultFactory,...r}={}){if(super(),this[kOptions]=r,this[kIndex]=-1,this[kCurrentWeight]=0,this[kMaxWeightPerServer]=this[kOptions].maxWeightPerServer||100,this[kErrorPenalty]=this[kOptions].errorPenalty||15,Array.isArray(e)||(e=[e]),"function"!=typeof t)throw new InvalidArgumentError("factory must be a function.");this[kInterceptors]=r.interceptors?.BalancedPool&&Array.isArray(r.interceptors.BalancedPool)?r.interceptors.BalancedPool:[],this[kFactory]=t;for(const t of e)this.addUpstream(t);this._updateBalancedPoolStats()}addUpstream(e){const t=parseOrigin(e).origin;if(this[kClients].find(e=>e[kUrl].origin===t&&!0!==e.closed&&!0!==e.destroyed))return this;const r=this[kFactory](t,Object.assign({},this[kOptions]));this[kAddClient](r),r.on("connect",()=>{r[kWeight]=Math.min(this[kMaxWeightPerServer],r[kWeight]+this[kErrorPenalty])}),r.on("connectionError",()=>{r[kWeight]=Math.max(1,r[kWeight]-this[kErrorPenalty]),this._updateBalancedPoolStats()}),r.on("disconnect",(...e)=>{const t=e[2];t&&"UND_ERR_SOCKET"===t.code&&(r[kWeight]=Math.max(1,r[kWeight]-this[kErrorPenalty]),this._updateBalancedPoolStats())});for(const e of this[kClients])e[kWeight]=this[kMaxWeightPerServer];return this._updateBalancedPoolStats(),this}_updateBalancedPoolStats(){let e=0;for(let t=0;t<this[kClients].length;t++)e=getGreatestCommonDivisor(this[kClients][t][kWeight],e);this[kGreatestCommonDivisor]=e}removeUpstream(e){const t=parseOrigin(e).origin,r=this[kClients].find(e=>e[kUrl].origin===t&&!0!==e.closed&&!0!==e.destroyed);return r&&this[kRemoveClient](r),this}get upstreams(){return this[kClients].filter(e=>!0!==e.closed&&!0!==e.destroyed).map(e=>e[kUrl].origin)}[kGetDispatcher](){if(0===this[kClients].length)throw new BalancedPoolMissingUpstreamError;if(!this[kClients].find(e=>!e[kNeedDrain]&&!0!==e.closed&&!0!==e.destroyed))return;if(this[kClients].map(e=>e[kNeedDrain]).reduce((e,t)=>e&&t,!0))return;let e=0,t=this[kClients].findIndex(e=>!e[kNeedDrain]);for(;e++<this[kClients].length;){this[kIndex]=(this[kIndex]+1)%this[kClients].length;const e=this[kClients][this[kIndex]];if(e[kWeight]>this[kClients][t][kWeight]&&!e[kNeedDrain]&&(t=this[kIndex]),0===this[kIndex]&&(this[kCurrentWeight]=this[kCurrentWeight]-this[kGreatestCommonDivisor],this[kCurrentWeight]<=0&&(this[kCurrentWeight]=this[kMaxWeightPerServer])),e[kWeight]>=this[kCurrentWeight]&&!e[kNeedDrain])return e}return this[kCurrentWeight]=this[kClients][t][kWeight],this[kIndex]=t,this[kClients][t]}}module.exports=BalancedPool;