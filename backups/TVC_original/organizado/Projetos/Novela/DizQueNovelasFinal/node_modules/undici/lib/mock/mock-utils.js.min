"use strict";const{MockNotMatchedError:MockNotMatchedError}=require("./mock-errors"),{kDispatches:kDispatches,kMockAgent:kMockAgent,kOriginalDispatch:kOriginalDispatch,kOrigin:kOrigin,kGetNetConnect:kGetNetConnect}=require("./mock-symbols"),{buildURL:buildURL}=require("../core/util"),{STATUS_CODES:STATUS_CODES}=require("node:http"),{types:{isPromise:isPromise}}=require("node:util");function matchValue(e,t){return"string"==typeof e?e===t:e instanceof RegExp?e.test(t):"function"==typeof e&&!0===e(t)}function lowerCaseEntries(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e.toLocaleLowerCase(),t]))}function getHeaderByName(e,t){if(!Array.isArray(e))return"function"==typeof e.get?e.get(t):lowerCaseEntries(e)[t.toLocaleLowerCase()];for(let o=0;o<e.length;o+=2)if(e[o].toLocaleLowerCase()===t.toLocaleLowerCase())return e[o+1]}function buildHeadersFromArray(e){const t=e.slice(),o=[];for(let e=0;e<t.length;e+=2)o.push([t[e],t[e+1]]);return Object.fromEntries(o)}function matchHeaders(e,t){if("function"==typeof e.headers)return Array.isArray(t)&&(t=buildHeadersFromArray(t)),e.headers(t?lowerCaseEntries(t):{});if(void 0===e.headers)return!0;if("object"!=typeof t||"object"!=typeof e.headers)return!1;for(const[o,r]of Object.entries(e.headers)){if(!matchValue(r,getHeaderByName(t,o)))return!1}return!0}function safeUrl(e){if("string"!=typeof e)return e;const t=e.split("?");if(2!==t.length)return e;const o=new URLSearchParams(t.pop());return o.sort(),[...t,o.toString()].join("?")}function matchKey(e,{path:t,method:o,body:r,headers:n}){const a=matchValue(e.path,t),s=matchValue(e.method,o),c=void 0===e.body||matchValue(e.body,r),i=matchHeaders(e,n);return a&&s&&c&&i}function getResponseData(e){return Buffer.isBuffer(e)||e instanceof Uint8Array||e instanceof ArrayBuffer?e:"object"==typeof e?JSON.stringify(e):e.toString()}function getMockDispatch(e,t){const o=t.query?buildURL(t.path,t.query):t.path,r="string"==typeof o?safeUrl(o):o;let n=e.filter(({consumed:e})=>!e).filter(({path:e})=>matchValue(safeUrl(e),r));if(0===n.length)throw new MockNotMatchedError(`Mock dispatch not matched for path '${r}'`);if(n=n.filter(({method:e})=>matchValue(e,t.method)),0===n.length)throw new MockNotMatchedError(`Mock dispatch not matched for method '${t.method}' on path '${r}'`);if(n=n.filter(({body:e})=>void 0===e||matchValue(e,t.body)),0===n.length)throw new MockNotMatchedError(`Mock dispatch not matched for body '${t.body}' on path '${r}'`);if(n=n.filter(e=>matchHeaders(e,t.headers)),0===n.length){const e="object"==typeof t.headers?JSON.stringify(t.headers):t.headers;throw new MockNotMatchedError(`Mock dispatch not matched for headers '${e}' on path '${r}'`)}return n[0]}function addMockDispatch(e,t,o){const r={timesInvoked:0,times:1,persist:!1,consumed:!1,...t,pending:!0,data:{error:null,..."function"==typeof o?{callback:o}:{...o}}};return e.push(r),r}function deleteMockDispatch(e,t){const o=e.findIndex(e=>!!e.consumed&&matchKey(e,t));-1!==o&&e.splice(o,1)}function buildKey(e){const{path:t,method:o,body:r,headers:n,query:a}=e;return{path:t,method:o,body:r,headers:n,query:a}}function generateKeyValues(e){const t=Object.keys(e),o=[];for(let r=0;r<t.length;++r){const n=t[r],a=e[n],s=Buffer.from(`${n}`);if(Array.isArray(a))for(let e=0;e<a.length;++e)o.push(s,Buffer.from(`${a[e]}`));else o.push(s,Buffer.from(`${a}`))}return o}function getStatusText(e){return STATUS_CODES[e]||"unknown"}async function getResponse(e){const t=[];for await(const o of e)t.push(o);return Buffer.concat(t).toString("utf8")}function mockDispatch(e,t){const o=buildKey(e),r=getMockDispatch(this[kDispatches],o);r.timesInvoked++,r.data.callback&&(r.data={...r.data,...r.data.callback(e)});const{data:{statusCode:n,data:a,headers:s,trailers:c,error:i},delay:h,persist:u}=r,{timesInvoked:d,times:f}=r;if(r.consumed=!u&&d>=f,r.pending=d<f,null!==i)return deleteMockDispatch(this[kDispatches],o),t.onError(i),!0;function l(r,i=a){const h=Array.isArray(e.headers)?buildHeadersFromArray(e.headers):e.headers,u="function"==typeof i?i({...e,headers:h}):i;if(isPromise(u))return void u.then(e=>l(r,e));const d=getResponseData(u),f=generateKeyValues(s),k=generateKeyValues(c);t.onConnect?.(e=>t.onError(e),null),t.onHeaders?.(n,f,p,getStatusText(n)),t.onData?.(Buffer.from(d)),t.onComplete?.(k),deleteMockDispatch(r,o)}function p(){}return"number"==typeof h&&h>0?setTimeout(()=>{l(this[kDispatches])},h):l(this[kDispatches]),!0}function buildMockDispatch(){const e=this[kMockAgent],t=this[kOrigin],o=this[kOriginalDispatch];return function(r,n){if(e.isMockActive)try{mockDispatch.call(this,r,n)}catch(a){if(!(a instanceof MockNotMatchedError))throw a;{const s=e[kGetNetConnect]();if(!1===s)throw new MockNotMatchedError(`${a.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`);if(!checkNetConnect(s,t))throw new MockNotMatchedError(`${a.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`);o.call(this,r,n)}}else o.call(this,r,n)}}function checkNetConnect(e,t){const o=new URL(t);return!0===e||!(!Array.isArray(e)||!e.some(e=>matchValue(e,o.host)))}function buildMockOptions(e){if(e){const{agent:t,...o}=e;return o}}module.exports={getResponseData:getResponseData,getMockDispatch:getMockDispatch,addMockDispatch:addMockDispatch,deleteMockDispatch:deleteMockDispatch,buildKey:buildKey,generateKeyValues:generateKeyValues,matchValue:matchValue,getResponse:getResponse,getStatusText:getStatusText,mockDispatch:mockDispatch,buildMockDispatch:buildMockDispatch,checkNetConnect:checkNetConnect,buildMockOptions:buildMockOptions,getHeaderByName:getHeaderByName,buildHeadersFromArray:buildHeadersFromArray};