"use strict";const{kClients:kClients}=require("../core/symbols"),Agent=require("../dispatcher/agent"),{kAgent:kAgent,kMockAgentSet:kMockAgentSet,kMockAgentGet:kMockAgentGet,kDispatches:kDispatches,kIsMockActive:kIsMockActive,kNetConnect:kNetConnect,kGetNetConnect:kGetNetConnect,kOptions:kOptions,kFactory:kFactory}=require("./mock-symbols"),MockClient=require("./mock-client"),MockPool=require("./mock-pool"),{matchValue:matchValue,buildMockOptions:buildMockOptions}=require("./mock-utils"),{InvalidArgumentError:InvalidArgumentError,UndiciError:UndiciError}=require("../core/errors"),Dispatcher=require("../dispatcher/dispatcher"),Pluralizer=require("./pluralizer"),PendingInterceptorsFormatter=require("./pending-interceptors-formatter");class MockAgent extends Dispatcher{constructor(t){if(super(t),this[kNetConnect]=!0,this[kIsMockActive]=!0,t?.agent&&"function"!=typeof t.agent.dispatch)throw new InvalidArgumentError("Argument opts.agent must implement Agent");const e=t?.agent?t.agent:new Agent(t);this[kAgent]=e,this[kClients]=e[kClients],this[kOptions]=buildMockOptions(t)}get(t){let e=this[kMockAgentGet](t);return e||(e=this[kFactory](t),this[kMockAgentSet](t,e)),e}dispatch(t,e){return this.get(t.origin),this[kAgent].dispatch(t,e)}async close(){await this[kAgent].close(),this[kClients].clear()}deactivate(){this[kIsMockActive]=!1}activate(){this[kIsMockActive]=!0}enableNetConnect(t){if("string"==typeof t||"function"==typeof t||t instanceof RegExp)Array.isArray(this[kNetConnect])?this[kNetConnect].push(t):this[kNetConnect]=[t];else{if(void 0!==t)throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");this[kNetConnect]=!0}}disableNetConnect(){this[kNetConnect]=!1}get isMockActive(){return this[kIsMockActive]}[kMockAgentSet](t,e){this[kClients].set(t,e)}[kFactory](t){const e=Object.assign({agent:this},this[kOptions]);return this[kOptions]&&1===this[kOptions].connections?new MockClient(t,e):new MockPool(t,e)}[kMockAgentGet](t){const e=this[kClients].get(t);if(e)return e;if("string"!=typeof t){const e=this[kFactory]("http://localhost:9999");return this[kMockAgentSet](t,e),e}for(const[e,n]of Array.from(this[kClients]))if(n&&"string"!=typeof e&&matchValue(e,t)){const e=this[kFactory](t);return this[kMockAgentSet](t,e),e[kDispatches]=n[kDispatches],e}}[kGetNetConnect](){return this[kNetConnect]}pendingInterceptors(){const t=this[kClients];return Array.from(t.entries()).flatMap(([t,e])=>e[kDispatches].map(e=>({...e,origin:t}))).filter(({pending:t})=>t)}assertNoPendingInterceptors({pendingInterceptorsFormatter:t=new PendingInterceptorsFormatter}={}){const e=this.pendingInterceptors();if(0===e.length)return;const n=new Pluralizer("interceptor","interceptors").pluralize(e.length);throw new UndiciError(`\n${n.count} ${n.noun} ${n.is} pending:\n\n${t.format(e)}\n`.trim())}}module.exports=MockAgent;