"use strict";const{parseHeaders:parseHeaders}=require("../core/util"),DecoratorHandler=require("../handler/decorator-handler"),{ResponseError:ResponseError}=require("../core/errors");class Handler extends DecoratorHandler{#e;#r;#t;#s;#o;#n;constructor(e,{handler:r}){super(r),this.#e=r}onConnect(e){return this.#r=0,this.#t=null,this.#s=null,this.#o=null,this.#n="",this.#e.onConnect(e)}onHeaders(e,r,t,s,o=parseHeaders(r)){if(this.#r=e,this.#o=o,this.#t=o["content-type"],this.#r<400)return this.#e.onHeaders(e,r,t,s,o);"application/json"!==this.#t&&"text/plain"!==this.#t||(this.#s=new TextDecoder("utf-8"))}onData(e){if(this.#r<400)return this.#e.onData(e);this.#n+=this.#s?.decode(e,{stream:!0})??""}onComplete(e){if(this.#r>=400){if(this.#n+=this.#s?.decode(void 0,{stream:!1})??"","application/json"===this.#t)try{this.#n=JSON.parse(this.#n)}catch{}let e;const r=Error.stackTraceLimit;Error.stackTraceLimit=0;try{e=new ResponseError("Response Error",this.#r,this.#o,this.#n)}finally{Error.stackTraceLimit=r}this.#e.onError(e)}else this.#e.onComplete(e)}onError(e){this.#e.onError(e)}}module.exports=e=>(r,t)=>r.throwOnError?e(r,new Handler(r,{handler:t})):e(r,t);