"use strict";const{Readable:Readable,Duplex:Duplex,PassThrough:PassThrough}=require("node:stream"),{InvalidArgumentError:InvalidArgumentError,InvalidReturnValueError:InvalidReturnValueError,RequestAbortedError:RequestAbortedError}=require("../core/errors"),util=require("../core/util"),{AsyncResource:AsyncResource}=require("node:async_hooks"),{addSignal:addSignal,removeSignal:removeSignal}=require("./abort-signal"),assert=require("node:assert"),kResume=Symbol("resume");class PipelineRequest extends Readable{constructor(){super({autoDestroy:!0}),this[kResume]=null}_read(){const{[kResume]:e}=this;e&&(this[kResume]=null,e())}_destroy(e,t){this._read(),t(e)}}class PipelineResponse extends Readable{constructor(e){super({autoDestroy:!0}),this[kResume]=e}_read(){this[kResume]()}_destroy(e,t){e||this._readableState.endEmitted||(e=new RequestAbortedError),t(e)}}class PipelineHandler extends AsyncResource{constructor(e,t){if(!e||"object"!=typeof e)throw new InvalidArgumentError("invalid opts");if("function"!=typeof t)throw new InvalidArgumentError("invalid handler");const{signal:r,method:s,opaque:n,onInfo:o,responseHeaders:i}=e;if(r&&"function"!=typeof r.on&&"function"!=typeof r.addEventListener)throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");if("CONNECT"===s)throw new InvalidArgumentError("invalid method");if(o&&"function"!=typeof o)throw new InvalidArgumentError("invalid onInfo callback");super("UNDICI_PIPELINE"),this.opaque=n||null,this.responseHeaders=i||null,this.handler=t,this.abort=null,this.context=null,this.onInfo=o||null,this.req=(new PipelineRequest).on("error",util.nop),this.ret=new Duplex({readableObjectMode:e.objectMode,autoDestroy:!0,read:()=>{const{body:e}=this;e?.resume&&e.resume()},write:(e,t,r)=>{const{req:s}=this;s.push(e,t)||s._readableState.destroyed?r():s[kResume]=r},destroy:(e,t)=>{const{body:r,req:s,res:n,ret:o,abort:i}=this;e||o._readableState.endEmitted||(e=new RequestAbortedError),i&&e&&i(),util.destroy(r,e),util.destroy(s,e),util.destroy(n,e),removeSignal(this),t(e)}}).on("prefinish",()=>{const{req:e}=this;e.push(null)}),this.res=null,addSignal(this,r)}onConnect(e,t){const{ret:r,res:s}=this;this.reason?e(this.reason):(assert(!s,"pipeline cannot be retried"),assert(!r.destroyed),this.abort=e,this.context=t)}onHeaders(e,t,r){const{opaque:s,handler:n,context:o}=this;if(e<200){if(this.onInfo){const r="raw"===this.responseHeaders?util.parseRawHeaders(t):util.parseHeaders(t);this.onInfo({statusCode:e,headers:r})}return}let i;this.res=new PipelineResponse(r);try{this.handler=null;const r="raw"===this.responseHeaders?util.parseRawHeaders(t):util.parseHeaders(t);i=this.runInAsyncScope(n,null,{statusCode:e,headers:r,opaque:s,body:this.res,context:o})}catch(e){throw this.res.on("error",util.nop),e}if(!i||"function"!=typeof i.on)throw new InvalidReturnValueError("expected Readable");i.on("data",e=>{const{ret:t,body:r}=this;!t.push(e)&&r.pause&&r.pause()}).on("error",e=>{const{ret:t}=this;util.destroy(t,e)}).on("end",()=>{const{ret:e}=this;e.push(null)}).on("close",()=>{const{ret:e}=this;e._readableState.ended||util.destroy(e,new RequestAbortedError)}),this.body=i}onData(e){const{res:t}=this;return t.push(e)}onComplete(e){const{res:t}=this;t.push(null)}onError(e){const{ret:t}=this;this.handler=null,util.destroy(t,e)}}function pipeline(e,t){try{const r=new PipelineHandler(e,t);return this.dispatch({...e,body:r.req},r),r.ret}catch(e){return(new PassThrough).destroy(e)}}module.exports=pipeline;