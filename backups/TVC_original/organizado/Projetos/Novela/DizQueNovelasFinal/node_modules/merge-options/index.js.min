"use strict";const isOptionObject=require("is-plain-obj"),{hasOwnProperty:hasOwnProperty}=Object.prototype,{propertyIsEnumerable:propertyIsEnumerable}=Object,defineProperty=(e,r,t)=>Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0}),globalThis=this,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=e=>{const r=[];for(const t in e)hasOwnProperty.call(e,t)&&r.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(e);for(const n of t)propertyIsEnumerable.call(e,n)&&r.push(n)}return r};function clone(e){return Array.isArray(e)?cloneArray(e):isOptionObject(e)?cloneOptionObject(e):e}function cloneArray(e){const r=e.slice(0,0);return getEnumerableOwnPropertyKeys(e).forEach(t=>{defineProperty(r,t,clone(e[t]))}),r}function cloneOptionObject(e){const r=null===Object.getPrototypeOf(e)?Object.create(null):{};return getEnumerableOwnPropertyKeys(e).forEach(t=>{defineProperty(r,t,clone(e[t]))}),r}const mergeKeys=(e,r,t,n)=>(t.forEach(t=>{void 0===r[t]&&n.ignoreUndefined||(t in e&&e[t]!==Object.getPrototypeOf(e)?defineProperty(e,t,merge(e[t],r[t],n)):defineProperty(e,t,clone(r[t])))}),e),concatArrays=(e,r,t)=>{let n=e.slice(0,0),o=0;return[e,r].forEach(r=>{const c=[];for(let t=0;t<r.length;t++)hasOwnProperty.call(r,t)&&(c.push(String(t)),defineProperty(n,o++,r===e?r[t]:clone(r[t])));n=mergeKeys(n,r,getEnumerableOwnPropertyKeys(r).filter(e=>!c.includes(e)),t)}),n};function merge(e,r,t){return t.concatArrays&&Array.isArray(e)&&Array.isArray(r)?concatArrays(e,r,t):isOptionObject(r)&&isOptionObject(e)?mergeKeys(e,r,getEnumerableOwnPropertyKeys(r),t):clone(r)}module.exports=function(...e){const r=merge(clone(defaultMergeOptions),this!==globalThis&&this||{},defaultMergeOptions);let t={_:{}};for(const n of e)if(void 0!==n){if(!isOptionObject(n))throw new TypeError("`"+n+"` is not an Option Object");t=merge(t,{_:n},r)}return t._};