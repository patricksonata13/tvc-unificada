const assert=require("assert"),path=require("path"),fs=require("fs");let glob;try{glob=require("glob")}catch(r){}const defaultGlobOpts={nosort:!0,silent:!0};let timeout=0;const isWindows="win32"===process.platform,defaults=r=>{if(["unlink","chmod","stat","lstat","rmdir","readdir"].forEach(t=>{r[t]=r[t]||fs[t],r[t+="Sync"]=r[t]||fs[t]}),r.maxBusyTries=r.maxBusyTries||3,r.emfileWait=r.emfileWait||1e3,!1===r.glob&&(r.disableGlob=!0),!0!==r.disableGlob&&void 0===glob)throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");r.disableGlob=r.disableGlob||!1,r.glob=r.glob||defaultGlobOpts},rimraf=(r,t,e)=>{"function"==typeof t&&(e=t,t={}),assert(r,"rimraf: missing path"),assert.equal(typeof r,"string","rimraf: path should be a string"),assert.equal(typeof e,"function","rimraf: callback function required"),assert(t,"rimraf: invalid options argument provided"),assert.equal(typeof t,"object","rimraf: options should be object"),defaults(t);let i=0,s=null,o=0;const n=(r,n)=>r?e(r):(o=n.length,0===o?e():void n.forEach(r=>{const n=a=>{if(a){if(("EBUSY"===a.code||"ENOTEMPTY"===a.code||"EPERM"===a.code)&&i<t.maxBusyTries)return i++,setTimeout(()=>rimraf_(r,t,n),100*i);if("EMFILE"===a.code&&timeout<t.emfileWait)return setTimeout(()=>rimraf_(r,t,n),timeout++);"ENOENT"===a.code&&(a=null)}timeout=0,(r=>{s=s||r,0===--o&&e(s)})(a)};rimraf_(r,t,n)}));if(t.disableGlob||!glob.hasMagic(r))return n(null,[r]);t.lstat(r,(e,i)=>{if(!e)return n(null,[r]);glob(r,t.glob,n)})},rimraf_=(r,t,e)=>{assert(r),assert(t),assert("function"==typeof e),t.lstat(r,(i,s)=>i&&"ENOENT"===i.code?e(null):(i&&"EPERM"===i.code&&isWindows&&fixWinEPERM(r,t,i,e),s&&s.isDirectory()?rmdir(r,t,i,e):void t.unlink(r,i=>{if(i){if("ENOENT"===i.code)return e(null);if("EPERM"===i.code)return isWindows?fixWinEPERM(r,t,i,e):rmdir(r,t,i,e);if("EISDIR"===i.code)return rmdir(r,t,i,e)}return e(i)})))},fixWinEPERM=(r,t,e,i)=>{assert(r),assert(t),assert("function"==typeof i),t.chmod(r,438,s=>{s?i("ENOENT"===s.code?null:e):t.stat(r,(s,o)=>{s?i("ENOENT"===s.code?null:e):o.isDirectory()?rmdir(r,t,e,i):t.unlink(r,i)})})},fixWinEPERMSync=(r,t,e)=>{assert(r),assert(t);try{t.chmodSync(r,438)}catch(r){if("ENOENT"===r.code)return;throw e}let i;try{i=t.statSync(r)}catch(r){if("ENOENT"===r.code)return;throw e}i.isDirectory()?rmdirSync(r,t,e):t.unlinkSync(r)},rmdir=(r,t,e,i)=>{assert(r),assert(t),assert("function"==typeof i),t.rmdir(r,s=>{!s||"ENOTEMPTY"!==s.code&&"EEXIST"!==s.code&&"EPERM"!==s.code?s&&"ENOTDIR"===s.code?i(e):i(s):rmkids(r,t,i)})},rmkids=(r,t,e)=>{assert(r),assert(t),assert("function"==typeof e),t.readdir(r,(i,s)=>{if(i)return e(i);let o,n=s.length;if(0===n)return t.rmdir(r,e);s.forEach(i=>{rimraf(path.join(r,i),t,i=>{if(!o)return i?e(o=i):void(0===--n&&t.rmdir(r,e))})})})},rimrafSync=(r,t)=>{let e;if(defaults(t=t||{}),assert(r,"rimraf: missing path"),assert.equal(typeof r,"string","rimraf: path should be a string"),assert(t,"rimraf: missing options"),assert.equal(typeof t,"object","rimraf: options should be object"),t.disableGlob||!glob.hasMagic(r))e=[r];else try{t.lstatSync(r),e=[r]}catch(i){e=glob.sync(r,t.glob)}if(e.length)for(let r=0;r<e.length;r++){const i=e[r];let s;try{s=t.lstatSync(i)}catch(r){if("ENOENT"===r.code)return;"EPERM"===r.code&&isWindows&&fixWinEPERMSync(i,t,r)}try{s&&s.isDirectory()?rmdirSync(i,t,null):t.unlinkSync(i)}catch(r){if("ENOENT"===r.code)return;if("EPERM"===r.code)return isWindows?fixWinEPERMSync(i,t,r):rmdirSync(i,t,r);if("EISDIR"!==r.code)throw r;rmdirSync(i,t,r)}}},rmdirSync=(r,t,e)=>{assert(r),assert(t);try{t.rmdirSync(r)}catch(i){if("ENOENT"===i.code)return;if("ENOTDIR"===i.code)throw e;"ENOTEMPTY"!==i.code&&"EEXIST"!==i.code&&"EPERM"!==i.code||rmkidsSync(r,t)}},rmkidsSync=(r,t)=>{assert(r),assert(t),t.readdirSync(r).forEach(e=>rimrafSync(path.join(r,e),t));const e=isWindows?100:1;let i=0;for(;;){let s=!0;try{const e=t.rmdirSync(r,t);return s=!1,e}finally{if(++i<e&&s)continue}}};module.exports=rimraf,rimraf.sync=rimrafSync;