"use strict";const TEMPLATE_REGEX=/(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,STYLE_REGEX=/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,STRING_REGEX=/^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,ESCAPE_REGEX=/\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,ESCAPES=new Map([["n","\n"],["r","\r"],["t","\t"],["b","\b"],["f","\f"],["v","\v"],["0","\0"],["\\","\\"],["e",""],["a",""]]);function unescape(e){return"u"===e[0]&&5===e.length||"x"===e[0]&&3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):ESCAPES.get(e)||e}function parseArguments(e,t){const n=[],s=t.trim().split(/\s*,\s*/g);let r;for(const t of s)if(isNaN(t)){if(!(r=t.match(STRING_REGEX)))throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e}')`);n.push(r[2].replace(ESCAPE_REGEX,(e,t,n)=>t?unescape(t):n))}else n.push(Number(t));return n}function parseStyle(e){STYLE_REGEX.lastIndex=0;const t=[];let n;for(;null!==(n=STYLE_REGEX.exec(e));){const e=n[1];if(n[2]){const s=parseArguments(e,n[2]);t.push([e].concat(s))}else t.push([e])}return t}function buildStyle(e,t){const n={};for(const e of t)for(const t of e.styles)n[t[0]]=e.inverse?null:t.slice(1);let s=e;for(const e of Object.keys(n))if(Array.isArray(n[e])){if(!(e in s))throw new Error(`Unknown Chalk style: ${e}`);s=n[e].length>0?s[e].apply(s,n[e]):s[e]}return s}module.exports=(e,t)=>{const n=[],s=[];let r=[];if(t.replace(TEMPLATE_REGEX,(t,l,o,i,u,a)=>{if(l)r.push(unescape(l));else if(i){const t=r.join("");r=[],s.push(0===n.length?t:buildStyle(e,n)(t)),n.push({inverse:o,styles:parseStyle(i)})}else if(u){if(0===n.length)throw new Error("Found extraneous } in Chalk template literal");s.push(buildStyle(e,n)(r.join(""))),r=[],n.pop()}else r.push(a)}),s.push(r.join("")),n.length>0){const e=`Chalk template literal is missing ${n.length} closing bracket${1===n.length?"":"s"} (\`}\`)`;throw new Error(e)}return s.join("")};