"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resolvePackageTargetFromExports=resolvePackageTargetFromExports;var _InvalidPackageConfigurationError=_interopRequireDefault(require("./errors/InvalidPackageConfigurationError")),_PackagePathNotExportedError=_interopRequireDefault(require("./errors/PackagePathNotExportedError")),_resolveAsset=_interopRequireDefault(require("./resolveAsset")),_isAssetFile=_interopRequireDefault(require("./utils/isAssetFile")),_isSubpathDefinedInExportsLike=require("./utils/isSubpathDefinedInExportsLike"),_matchSubpathFromExportsLike=require("./utils/matchSubpathFromExportsLike"),_toPosixPath=_interopRequireDefault(require("./utils/toPosixPath")),_path=_interopRequireDefault(require("path"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function resolvePackageTargetFromExports(e,t,r,o,i,a){const s=e=>new _InvalidPackageConfigurationError.default({reason:e,packagePath:t}),n=getExportsSubpath(o),l=normalizeExportsField(i,s);if(!(0,_isSubpathDefinedInExportsLike.isSubpathDefinedInExportsLike)(l,n))throw new _PackagePathNotExportedError.default(`Attempted to import the module "${r}" which is not listed in the "exports" of "${t}" under the requested subpath "${n}".`);const{target:u,patternMatch:p}=(0,_matchSubpathFromExportsLike.matchSubpathFromExportsLike)(e,n,l,a,s);if(null!=u){const o=findInvalidPathSegment(u.slice(2));if(null!=o)throw s(`The target for "${n}" defined in "exports" is "${u}", however this value is an invalid subpath or subpath pattern because it includes "${o}".`);const i=_path.default.join(t,null!=p?u.replaceAll("*",p):u);if((0,_isAssetFile.default)(i,e.assetExts)){const t=(0,_resolveAsset.default)(e,i);if(null!=t)return t}const a=e.fileSystemLookup(i);if(a.exists&&"f"===a.type)return{type:"sourceFile",filePath:a.realPath};throw s(`The resolution for "${r}" defined in "exports" is ${i}, however this file does not exist.`)}throw new _PackagePathNotExportedError.default(`Attempted to import the module "${r}" which is listed in the "exports" of "${t}", however no match was resolved for this request (platform = ${a??"null"}).`)}function getExportsSubpath(e){return""===e?".":"./"+(0,_toPosixPath.default)(e)}const _normalizedExportsFields=new WeakMap;function normalizeExportsField(e,t){let r;if("string"==typeof e)return new Map([[".",e]]);const o=_normalizedExportsFields.get(e);if(o)return o;if(r=Array.isArray(e)?e.every(e=>"string"==typeof e)?e.find(e=>e.startsWith("./")):e[0]:e,null==r||Array.isArray(r))throw t('Could not parse non-standard array value at root of "exports" field.');if("string"==typeof r){const t=new Map([[".",r]]);return _normalizedExportsFields.set(e,t),t}const i=Object.keys(r),a=i.filter(e=>e.startsWith("."));if(i.filter(e=>e.startsWith("#")).length+a.length===i.length){const o=new Map(Object.entries(flattenLegacySubpathValues(r,t)));return _normalizedExportsFields.set(e,o),o}if(0!==a.length)throw t('The "exports" field cannot have keys which are both subpaths and condition names at the same level.');const s=new Map([[".",flattenLegacySubpathValues(r,t)]]);return _normalizedExportsFields.set(e,s),s}function flattenLegacySubpathValues(e,t){return Object.entries(e).reduce((e,[r,o])=>{if(Array.isArray(o)){if(!o.length||Array.isArray(o[0]))throw t('Could not parse non-standard array value in "exports" field.');e[r]=o[0]}else e[r]=o;return e},{})}function findInvalidPathSegment(e){for(const t of e.split(/[\\/]/))if(""===t||"."===t||".."===t||"node_modules"===t)return t;return null}