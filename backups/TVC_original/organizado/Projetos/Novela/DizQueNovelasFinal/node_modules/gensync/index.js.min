"use strict";const GENSYNC_START=Symbol.for("gensync:v1:start"),GENSYNC_SUSPEND=Symbol.for("gensync:v1:suspend"),GENSYNC_EXPECTED_START="GENSYNC_EXPECTED_START",GENSYNC_EXPECTED_SUSPEND="GENSYNC_EXPECTED_SUSPEND",GENSYNC_OPTIONS_ERROR="GENSYNC_OPTIONS_ERROR",GENSYNC_RACE_NONEMPTY="GENSYNC_RACE_NONEMPTY",GENSYNC_ERRBACK_NO_CALLBACK="GENSYNC_ERRBACK_NO_CALLBACK";function makeFunctionAPI(e){return{sync:function(...t){return evaluateSync(e.apply(this,t))},async:function(...t){return new Promise((n,r)=>{evaluateAsync(e.apply(this,t),n,r)})},errback:function(...t){const n=t.pop();if("function"!=typeof n)throw makeError("Asynchronous function called without callback",GENSYNC_ERRBACK_NO_CALLBACK);let r;try{r=e.apply(this,t)}catch(e){return void n(e)}evaluateAsync(r,e=>n(void 0,e),e=>n(e))}}}function assertTypeof(e,t,n,r){if(typeof n===e||r&&void 0===n)return;let a;throw a=r?`Expected opts.${t} to be either a ${e}, or undefined.`:`Expected opts.${t} to be a ${e}.`,makeError(a,GENSYNC_OPTIONS_ERROR)}function makeError(e,t){return Object.assign(new Error(e),{code:t})}function newGenerator({name:e,arity:t,sync:n,async:r,errback:a}){if(assertTypeof("string","name",e,!0),assertTypeof("number","arity",t,!0),assertTypeof("function","sync",n),assertTypeof("function","async",r,!0),assertTypeof("function","errback",a,!0),r&&a)throw makeError("Expected one of either opts.async or opts.errback, but got _both_.",GENSYNC_OPTIONS_ERROR);if("string"!=typeof e){let t;a&&a.name&&"errback"!==a.name&&(t=a.name),r&&r.name&&"async"!==r.name&&(t=r.name.replace(/Async$/,"")),n&&n.name&&"sync"!==n.name&&(t=n.name.replace(/Sync$/,"")),"string"==typeof t&&(e=t)}return"number"!=typeof t&&(t=n.length),buildOperation({name:e,arity:t,sync:function(e){return n.apply(this,e)},async:function(e,t,o){r?r.apply(this,e).then(t,o):a?a.call(this,...e,(e,n)=>{null==e?t(n):o(e)}):t(n.apply(this,e))}})}function wrapGenerator(e){return setFunctionMetadata(e.name,e.length,function(...t){return e.apply(this,t)})}function buildOperation({name:e,arity:t,sync:n,async:r}){return setFunctionMetadata(e,t,function*(...e){const t=yield GENSYNC_START;if(!t){return n.call(this,e)}let a;try{r.call(this,e,e=>{a||(a={value:e},t())},e=>{a||(a={err:e},t())})}catch(e){a={err:e},t()}if(yield GENSYNC_SUSPEND,a.hasOwnProperty("err"))throw a.err;return a.value})}function evaluateSync(e){let t;for(;!({value:t}=e.next()).done;)assertStart(t,e);return t}function evaluateAsync(e,t,n){!function r(){try{let n;for(;!({value:n}=e.next()).done;){assertStart(n,e);let t=!0,a=!1;const o=e.next(()=>{t?a=!0:r()});if(t=!1,assertSuspend(o,e),!a)return}return t(n)}catch(e){return n(e)}}()}function assertStart(e,t){e!==GENSYNC_START&&throwError(t,makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,GENSYNC_EXPECTED_START))}function assertSuspend({value:e,done:t},n){(t||e!==GENSYNC_SUSPEND)&&throwError(n,makeError(t?"Unexpected generator completion. If you get this, it is probably a gensync bug.":`Expected GENSYNC_SUSPEND, got ${JSON.stringify(e)}. If you get this, it is probably a gensync bug.`,GENSYNC_EXPECTED_SUSPEND))}function throwError(e,t){throw e.throw&&e.throw(t),t}function isIterable(e){return!(!e||"object"!=typeof e&&"function"!=typeof e||e[Symbol.iterator])}function setFunctionMetadata(e,t,n){if("string"==typeof e){const t=Object.getOwnPropertyDescriptor(n,"name");t&&!t.configurable||Object.defineProperty(n,"name",Object.assign(t||{},{configurable:!0,value:e}))}if("number"==typeof t){const e=Object.getOwnPropertyDescriptor(n,"length");e&&!e.configurable||Object.defineProperty(n,"length",Object.assign(e||{},{configurable:!0,value:t}))}return n}module.exports=Object.assign(function(e){let t=e;return t="function"!=typeof e?newGenerator(e):wrapGenerator(e),Object.assign(t,makeFunctionAPI(t))},{all:buildOperation({name:"all",arity:1,sync:function(e){return Array.from(e[0]).map(e=>evaluateSync(e))},async:function(e,t,n){const r=Array.from(e[0]);if(0===r.length)return void Promise.resolve().then(()=>t([]));let a=0;const o=r.map(()=>{});r.forEach((e,r)=>{evaluateAsync(e,e=>{o[r]=e,a+=1,a===o.length&&t(o)},n)})}}),race:buildOperation({name:"race",arity:1,sync:function(e){const t=Array.from(e[0]);if(0===t.length)throw makeError("Must race at least 1 item",GENSYNC_RACE_NONEMPTY);return evaluateSync(t[0])},async:function(e,t,n){const r=Array.from(e[0]);if(0===r.length)throw makeError("Must race at least 1 item",GENSYNC_RACE_NONEMPTY);for(const e of r)evaluateAsync(e,t,n)}})});