"use strict";function _util(){const e=require("util");return _util=function(){return e},e}function _jestMessageUtil(){const e=require("jest-message-util");return _jestMessageUtil=function(){return e},e}function _jestUtil(){const e=require("jest-util");return _jestUtil=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;const MS_IN_A_YEAR=31536e6;class FakeTimers{_cancelledTicks;_config;_disposed;_fakeTimerAPIs;_fakingTime=!1;_global;_immediates;_maxLoops;_moduleMocker;_now;_ticks;_timerAPIs;_timers;_uuidCounter;_timerConfig;constructor({global:e,moduleMocker:t,timerConfig:i,config:s,maxLoops:a}){this._global=e,this._timerConfig=i,this._config=s,this._maxLoops=a||1e5,this._uuidCounter=1,this._moduleMocker=t,this._timerAPIs={cancelAnimationFrame:e.cancelAnimationFrame,clearImmediate:e.clearImmediate,clearInterval:e.clearInterval,clearTimeout:e.clearTimeout,nextTick:e.process&&e.process.nextTick,requestAnimationFrame:e.requestAnimationFrame,setImmediate:e.setImmediate,setInterval:e.setInterval,setTimeout:e.setTimeout},this._disposed=!1,this.reset()}clearAllTimers(){this._immediates=[],this._timers.clear()}dispose(){this._disposed=!0,this.clearAllTimers()}reset(){this._cancelledTicks={},this._now=0,this._ticks=[],this._immediates=[],this._timers=new Map}now(){return this._fakingTime?this._now:Date.now()}runAllTicks(){let e;for(this._checkFakeTimers(),e=0;e<this._maxLoops;e++){const e=this._ticks.shift();if(void 0===e)break;Object.prototype.hasOwnProperty.call(this._cancelledTicks,e.uuid)||(this._cancelledTicks[e.uuid]=!0,e.callback())}if(e===this._maxLoops)throw new Error(`Ran ${this._maxLoops} ticks, and there are still more! Assuming we've hit an infinite recursion and bailing out...`)}runAllImmediates(){let e;for(this._checkFakeTimers(),e=0;e<this._maxLoops;e++){const e=this._immediates.shift();if(void 0===e)break;this._runImmediate(e)}if(e===this._maxLoops)throw new Error(`Ran ${this._maxLoops} immediates, and there are still more! Assuming we've hit an infinite recursion and bailing out...`)}_runImmediate(e){try{e.callback()}finally{this._fakeClearImmediate(e.uuid)}}runAllTimers(){let e;for(this._checkFakeTimers(),this.runAllTicks(),this.runAllImmediates(),e=0;e<this._maxLoops;e++){const e=this._getNextTimerHandleAndExpiry();if(null===e)break;const[t,i]=e;this._now=i,this._runTimerHandle(t),this._immediates.length&&this.runAllImmediates(),this._ticks.length&&this.runAllTicks()}if(e===this._maxLoops)throw new Error(`Ran ${this._maxLoops} timers, and there are still more! Assuming we've hit an infinite recursion and bailing out...`)}runOnlyPendingTimers(){const e=Array.from(this._timers.entries());this._checkFakeTimers(),this._immediates.forEach(this._runImmediate,this),e.sort(([,e],[,t])=>e.expiry-t.expiry).forEach(([e,t])=>{this._now=t.expiry,this._runTimerHandle(e)})}advanceTimersToNextTimer(e=1){if(e<1)return;const t=Array.from(this._timers.values()).reduce((e,t)=>null===e||t.expiry<e?t.expiry:e,null);null!==t&&(this.advanceTimersByTime(t-this._now),this.advanceTimersToNextTimer(e-1))}advanceTimersByTime(e){let t;for(this._checkFakeTimers(),t=0;t<this._maxLoops;t++){const t=this._getNextTimerHandleAndExpiry();if(null===t)break;const[i,s]=t;if(this._now+e<s)break;e-=s-this._now,this._now=s,this._runTimerHandle(i)}if(this._now+=e,t===this._maxLoops)throw new Error(`Ran ${this._maxLoops} timers, and there are still more! Assuming we've hit an infinite recursion and bailing out...`)}runWithRealTimers(e){const t=this._global.clearImmediate,i=this._global.clearInterval,s=this._global.clearTimeout,a=this._global.process.nextTick,r=this._global.setImmediate,n=this._global.setInterval,l=this._global.setTimeout;this.useRealTimers();let m=null,o=!1;try{e()}catch(e){o=!0,m=e}if(this._global.clearImmediate=t,this._global.clearInterval=i,this._global.clearTimeout=s,this._global.process.nextTick=a,this._global.setImmediate=r,this._global.setInterval=n,this._global.setTimeout=l,o)throw m}useRealTimers(){const e=this._global;"function"==typeof e.cancelAnimationFrame&&(0,_jestUtil().setGlobal)(e,"cancelAnimationFrame",this._timerAPIs.cancelAnimationFrame),"function"==typeof e.clearImmediate&&(0,_jestUtil().setGlobal)(e,"clearImmediate",this._timerAPIs.clearImmediate),(0,_jestUtil().setGlobal)(e,"clearInterval",this._timerAPIs.clearInterval),(0,_jestUtil().setGlobal)(e,"clearTimeout",this._timerAPIs.clearTimeout),"function"==typeof e.requestAnimationFrame&&(0,_jestUtil().setGlobal)(e,"requestAnimationFrame",this._timerAPIs.requestAnimationFrame),"function"==typeof e.setImmediate&&(0,_jestUtil().setGlobal)(e,"setImmediate",this._timerAPIs.setImmediate),(0,_jestUtil().setGlobal)(e,"setInterval",this._timerAPIs.setInterval),(0,_jestUtil().setGlobal)(e,"setTimeout",this._timerAPIs.setTimeout),e.process.nextTick=this._timerAPIs.nextTick,this._fakingTime=!1}useFakeTimers(){this._createMocks();const e=this._global;"function"==typeof e.cancelAnimationFrame&&(0,_jestUtil().setGlobal)(e,"cancelAnimationFrame",this._fakeTimerAPIs.cancelAnimationFrame),"function"==typeof e.clearImmediate&&(0,_jestUtil().setGlobal)(e,"clearImmediate",this._fakeTimerAPIs.clearImmediate),(0,_jestUtil().setGlobal)(e,"clearInterval",this._fakeTimerAPIs.clearInterval),(0,_jestUtil().setGlobal)(e,"clearTimeout",this._fakeTimerAPIs.clearTimeout),"function"==typeof e.requestAnimationFrame&&(0,_jestUtil().setGlobal)(e,"requestAnimationFrame",this._fakeTimerAPIs.requestAnimationFrame),"function"==typeof e.setImmediate&&(0,_jestUtil().setGlobal)(e,"setImmediate",this._fakeTimerAPIs.setImmediate),(0,_jestUtil().setGlobal)(e,"setInterval",this._fakeTimerAPIs.setInterval),(0,_jestUtil().setGlobal)(e,"setTimeout",this._fakeTimerAPIs.setTimeout),e.process.nextTick=this._fakeTimerAPIs.nextTick,this._fakingTime=!0}getTimerCount(){return this._checkFakeTimers(),this._timers.size+this._immediates.length+this._ticks.length}_checkFakeTimers(){this._fakingTime||this._global.console.warn(`A function to advance timers was called but the timers APIs are not mocked with fake timers. Call \`jest.useFakeTimers({legacyFakeTimers: true})\` in this test file or enable fake timers for all tests by setting {'enableGlobally': true, 'legacyFakeTimers': true} in Jest configuration file.\nStack Trace:\n${(0,_jestMessageUtil().formatStackTrace)((new Error).stack,this._config,{noStackTrace:!1})}`)}_createMocks(){const e=e=>this._moduleMocker.fn(e),t=e(this._fakeSetTimeout.bind(this));t[_util().promisify.custom]=(e,i)=>new Promise(s=>t(s,e,i)),this._fakeTimerAPIs={cancelAnimationFrame:e(this._fakeClearTimer.bind(this)),clearImmediate:e(this._fakeClearImmediate.bind(this)),clearInterval:e(this._fakeClearTimer.bind(this)),clearTimeout:e(this._fakeClearTimer.bind(this)),nextTick:e(this._fakeNextTick.bind(this)),requestAnimationFrame:e(this._fakeRequestAnimationFrame.bind(this)),setImmediate:e(this._fakeSetImmediate.bind(this)),setInterval:e(this._fakeSetInterval.bind(this)),setTimeout:t}}_fakeClearTimer(e){const t=this._timerConfig.refToId(e);t&&this._timers.delete(String(t))}_fakeClearImmediate(e){this._immediates=this._immediates.filter(t=>t.uuid!==e)}_fakeNextTick(e,...t){if(this._disposed)return;const i=String(this._uuidCounter++);this._ticks.push({callback:()=>e.apply(null,t),uuid:i});const s=this._cancelledTicks;this._timerAPIs.nextTick(()=>{Object.prototype.hasOwnProperty.call(s,i)||(s[i]=!0,e.apply(null,t))})}_fakeRequestAnimationFrame(e){return this._fakeSetTimeout(()=>{e(this._now)},1e3/60)}_fakeSetImmediate(e,...t){if(this._disposed)return null;const i=String(this._uuidCounter++);return this._immediates.push({callback:()=>e.apply(null,t),uuid:i}),this._timerAPIs.setImmediate(()=>{if(!this._disposed&&this._immediates.find(e=>e.uuid===i))try{e.apply(null,t)}finally{this._fakeClearImmediate(i)}}),i}_fakeSetInterval(e,t,...i){if(this._disposed)return null;null==t&&(t=0);const s=this._uuidCounter++;return this._timers.set(String(s),{callback:()=>e.apply(null,i),expiry:this._now+t,interval:t,type:"interval"}),this._timerConfig.idToRef(s)}_fakeSetTimeout(e,t,...i){if(this._disposed)return null;t=0|Number(t);const s=this._uuidCounter++;return this._timers.set(String(s),{callback:()=>e.apply(null,i),expiry:this._now+t,interval:void 0,type:"timeout"}),this._timerConfig.idToRef(s)}_getNextTimerHandleAndExpiry(){let e=null,t=31536e6;return this._timers.forEach((i,s)=>{i.expiry<t&&(t=i.expiry,e=s)}),null===e?null:[e,t]}_runTimerHandle(e){const t=this._timers.get(e);if(t)switch(t.type){case"timeout":this._timers.delete(e),t.callback();break;case"interval":t.expiry=this._now+(t.interval||0),t.callback();break;default:throw new Error(`Unexpected timer type: ${t.type}`)}}}exports.default=FakeTimers;