"use strict";function _crypto(){const e=require("crypto");return _crypto=function(){return e},e}function path(){const e=_interopRequireWildcard(require("path"));return path=function(){return e},e}function _core(){const e=require("@babel/core");return _core=function(){return e},e}function _babelPluginIstanbul(){const e=_interopRequireDefault(require("babel-plugin-istanbul"));return _babelPluginIstanbul=function(){return e},e}function _convertSourceMap(){const e=require("convert-source-map");return _convertSourceMap=function(){return e},e}function _fastJsonStableStringify(){const e=_interopRequireDefault(require("fast-json-stable-stringify"));return _fastJsonStableStringify=function(){return e},e}function fs(){const e=_interopRequireWildcard(require("graceful-fs"));return fs=function(){return e},e}function _pirates(){const e=require("pirates");return _pirates=function(){return e},e}function _slash(){const e=_interopRequireDefault(require("slash"));return _slash=function(){return e},e}function _writeFileAtomic(){const e=require("write-file-atomic");return _writeFileAtomic=function(){return e},e}function _jestHasteMap(){const e=_interopRequireDefault(require("jest-haste-map"));return _jestHasteMap=function(){return e},e}function _jestUtil(){const e=require("jest-util");return _jestUtil=function(){return e},e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.createScriptTransformer=createScriptTransformer,exports.createTranspilingRequire=createTranspilingRequire;var _enhanceUnexpectedTokenMessage=_interopRequireDefault(require("./enhanceUnexpectedTokenMessage")),_runtimeErrorsAndWarnings=require("./runtimeErrorsAndWarnings"),_shouldInstrument=_interopRequireDefault(require("./shouldInstrument"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var o=s?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(n,a,o):n[a]=e[a]}return n.default=e,t&&t.set(e,n),n}const{version:VERSION}=require("../package.json"),projectCaches=new Map,CACHE_VERSION="1";async function waitForPromiseWithCleanup(e,r){try{await e}finally{r()}}function isTransformerFactory(e){return"function"==typeof e.createTransformer}class ScriptTransformer{_cache;_transformCache=new Map;_transformsAreLoaded=!1;constructor(e,r){this._config=e,this._cacheFS=r;const t=(0,_fastJsonStableStringify().default)(this._config);let n=projectCaches.get(t);n||(n={configString:t,ignorePatternsRegExp:calcIgnorePatternRegExp(this._config),transformRegExp:calcTransformRegExp(this._config),transformedFiles:new Map},projectCaches.set(t,n)),this._cache=n}_buildCacheKeyFromFileInfo(e,r,t,n){return null!=n?(0,_crypto().createHash)("sha1").update(n).update("1").digest("hex").substring(0,32):(0,_crypto().createHash)("sha1").update(e).update(t.configString).update(t.instrument?"instrument":"").update(r).update("1").digest("hex").substring(0,32)}_buildTransformCacheKey(e,r){return e+r}_getCacheKey(e,r,t){const n=this._cache.configString,{transformer:s,transformerConfig:a={}}=this._getTransformer(r)??{};let o;const i={...t,cacheFS:this._cacheFS,config:this._config,configString:n,transformerConfig:a};return"function"==typeof s?.getCacheKey&&(o=s.getCacheKey(e,r,i)),this._buildCacheKeyFromFileInfo(e,r,i,o)}async _getCacheKeyAsync(e,r,t){const n=this._cache.configString,{transformer:s,transformerConfig:a={}}=this._getTransformer(r)??{};let o;const i={...t,cacheFS:this._cacheFS,config:this._config,configString:n,transformerConfig:a};if(s){const t=s.getCacheKeyAsync??s.getCacheKey;"function"==typeof t&&(o=await t(e,r,i))}return this._buildCacheKeyFromFileInfo(e,r,i,o)}_createCachedFilename(e,r){const t=_jestHasteMap().default.getStatic(this._config).getCacheFilePath(this._config.cacheDirectory,`jest-transform-cache-${this._config.id}`,VERSION),n=path().join(t,r[0]+r[1]),s=path().basename(e,path().extname(e)).replace(/\W/g,"");return(0,_slash().default)(path().join(n,`${s}_${r}`))}_getFileCachePath(e,r,t){const n=this._getCacheKey(r,e,t);return this._createCachedFilename(e,n)}async _getFileCachePathAsync(e,r,t){const n=await this._getCacheKeyAsync(r,e,t);return this._createCachedFilename(e,n)}_getTransformPatternAndPath(e){const r=this._cache.transformRegExp;if(null!=r)for(let t=0;t<r.length;t++){const[n,s]=r[t];if(n.test(e))return[n.source,s]}}_getTransformPath(e){const r=this._getTransformPatternAndPath(e);if(Array.isArray(r))return r[1]}async loadTransformers(){await Promise.all(this._config.transform.map(async([e,r,t],n)=>{let s=await(0,_jestUtil().requireOrImportModule)(r);if(null==s)throw new Error((0,_runtimeErrorsAndWarnings.makeInvalidTransformerError)(r));if(isTransformerFactory(s)&&(s=await s.createTransformer(t)),"function"!=typeof s.process&&"function"!=typeof s.processAsync)throw new Error((0,_runtimeErrorsAndWarnings.makeInvalidTransformerError)(r));const a={transformer:s,transformerConfig:t},o=this._buildTransformCacheKey(this._cache.transformRegExp?.[n]?.[0].source??new RegExp(e).source,r);this._transformCache.set(o,a)})),this._transformsAreLoaded=!0}_getTransformer(e){if(!this._transformsAreLoaded)throw new Error("Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files");if(0===this._config.transform.length)return null;const r=this._getTransformPatternAndPath(e);if(!Array.isArray(r))return null;const[t,n]=r,s=this._buildTransformCacheKey(t,n),a=this._transformCache.get(s);if(void 0!==a)return a;throw new Error(`Jest was unable to load the transformer defined for ${e}. This is a bug in Jest, please open up an issue`)}_instrumentFile(e,r,t,n){const s="string"==typeof r?r:r.code,a="string"==typeof r?null:r.map,o=(0,_core().transformSync)(s,{auxiliaryCommentBefore:" istanbul ignore next ",babelrc:!1,caller:{name:"@jest/transform",supportsDynamicImport:n.supportsDynamicImport,supportsExportNamespaceFrom:n.supportsExportNamespaceFrom,supportsStaticESM:n.supportsStaticESM,supportsTopLevelAwait:n.supportsTopLevelAwait},configFile:!1,filename:e,plugins:[[_babelPluginIstanbul().default,{compact:!1,cwd:this._config.rootDir,exclude:[],extension:!1,inputSourceMap:a,useInlineSourceMaps:!1}]],sourceMaps:!!t&&"both"});return null!=o?.code?o:r}_buildTransformResult(e,r,t,n,s,a,o,i){let c={code:t,map:null};if(n&&s){if(null==o||"string"!=typeof o.code){const r=this._getTransformPath(e);throw(0,_jestUtil().invariant)(r),new Error((0,_runtimeErrorsAndWarnings.makeInvalidReturnValueError)(r))}c=o}if(null==c.map||""===c.map)try{const e=(0,_convertSourceMap().fromSource)(c.code);e&&(c.map=e.toObject())}catch{const r=this._getTransformPath(e);(0,_jestUtil().invariant)(r),console.warn((0,_runtimeErrorsAndWarnings.makeInvalidSourceMapWarning)(e,r))}const u=s&&n&&n.canInstrument;let f,l=c.map;if(!0!==u&&a.instrument){const r=null!=n&&null!=l||null==n,t=this._instrumentFile(e,c,r,a);f="string"==typeof t?t:t.code,l="string"==typeof t?null:t.map}else f=c.code;if(null!=l){const e="string"==typeof l?l:JSON.stringify(l);(0,_jestUtil().invariant)(i,"We should always have default sourceMapPath"),writeCacheFile(i,e)}else i=null;return writeCodeCacheFile(r,f),{code:f,originalCode:t,sourceMapPath:i}}transformSource(e,r,t){const n=(0,_jestUtil().tryRealpath)(e),{transformer:s,transformerConfig:a={}}=this._getTransformer(n)??{},o=this._getFileCachePath(n,r,t),i=`${o}.map`,c=this._config.cache?readCodeCacheFile(o):null;if(null!=c)return{code:c,originalCode:r,sourceMapPath:i};let u=null,f=!1;return s&&this.shouldTransform(n)&&(f=!0,assertSyncTransformer(s,this._getTransformPath(n)),u=s.process(r,n,{...t,cacheFS:this._cacheFS,config:this._config,configString:this._cache.configString,transformerConfig:a})),(0,_jestUtil().createDirectory)(path().dirname(o)),this._buildTransformResult(n,o,r,s,f,t,u,i)}async transformSourceAsync(e,r,t){const n=(0,_jestUtil().tryRealpath)(e),{transformer:s,transformerConfig:a={}}=this._getTransformer(n)??{},o=await this._getFileCachePathAsync(n,r,t),i=`${o}.map`,c=this._config.cache?readCodeCacheFile(o):null;if(null!=c)return{code:c,originalCode:r,sourceMapPath:i};let u=null,f=!1;if(s&&this.shouldTransform(n)){f=!0;const e=s.processAsync??s.process;(0,_jestUtil().invariant)("function"==typeof e,"A transformer must always export either a `process` or `processAsync`"),u=await e(r,n,{...t,cacheFS:this._cacheFS,config:this._config,configString:this._cache.configString,transformerConfig:a})}return(0,_jestUtil().createDirectory)(path().dirname(o)),this._buildTransformResult(n,o,r,s,f,t,u,i)}async _transformAndBuildScriptAsync(e,r,t,n){const{isInternalModule:s}=r;let a=n??this._cacheFS.get(e);null==a&&(a=fs().readFileSync(e,"utf8"),this._cacheFS.set(e,a));const o=stripShebang(a);let i=o,c=null;const u=!0!==s&&(t.instrument||this.shouldTransform(e));try{if(u){const r=await this.transformSourceAsync(e,o,t);i=r.code,c=r.sourceMapPath}return{code:i,originalCode:o,sourceMapPath:c}}catch(e){if(!(e instanceof Error))throw e;throw(0,_enhanceUnexpectedTokenMessage.default)(e)}}_transformAndBuildScript(e,r,t,n){const{isInternalModule:s}=r;let a=n??this._cacheFS.get(e);null==a&&(a=fs().readFileSync(e,"utf8"),this._cacheFS.set(e,a));const o=stripShebang(a);let i=o,c=null;const u=!0!==s&&(t.instrument||this.shouldTransform(e));try{if(u){const r=this.transformSource(e,o,t);i=r.code,c=r.sourceMapPath}return{code:i,originalCode:o,sourceMapPath:c}}catch(e){if(!(e instanceof Error))throw e;throw(0,_enhanceUnexpectedTokenMessage.default)(e)}}async transformAsync(e,r,t){const n="babel"===r.coverageProvider&&(0,_shouldInstrument.default)(e,r,this._config),s=getScriptCacheKey(e,n);let a=this._cache.transformedFiles.get(s);return a||(a=await this._transformAndBuildScriptAsync(e,r,{...r,instrument:n},t),s&&this._cache.transformedFiles.set(s,a),a)}transform(e,r,t){const n="babel"===r.coverageProvider&&(0,_shouldInstrument.default)(e,r,this._config),s=getScriptCacheKey(e,n);let a=this._cache.transformedFiles.get(s);return a||(a=this._transformAndBuildScript(e,r,{...r,instrument:n},t),s&&this._cache.transformedFiles.set(s,a),a)}transformJson(e,r,t){const{isInternalModule:n}=r;if(!0!==n&&this.shouldTransform(e)){const{code:n}=this.transformSource(e,t,{...r,instrument:!1});return n}return t}async requireAndTranspileModule(e,r,t={applyInteropRequireDefault:!0,instrument:!1,supportsDynamicImport:!1,supportsExportNamespaceFrom:!1,supportsStaticESM:!1,supportsTopLevelAwait:!1}){let n=!1;const{applyInteropRequireDefault:s,...a}=t,o=(0,_pirates().addHook)((e,r)=>{try{return n=!0,this.transformSource(r,e,a).code||e}finally{n=!1}},{exts:this._config.moduleFileExtensions.filter(e=>"mjs"!==e).map(e=>`.${e}`),ignoreNodeModules:!1,matcher:e=>!n&&this.shouldTransform(e)});try{const t=await(0,_jestUtil().requireOrImportModule)(e,s);if(!r)return o(),t;const n=r(t);return(0,_jestUtil().isPromise)(n)?await waitForPromiseWithCleanup(n,o).then(()=>t):t}finally{o()}}shouldTransform(e){const r=this._cache.ignorePatternsRegExp,t=!!r&&r.test(e);return 0!==this._config.transform.length&&!t}}async function createTranspilingRequire(e){const r=await createScriptTransformer(e);return async function(e,t=!1){return await r.requireAndTranspileModule(e,()=>{},{applyInteropRequireDefault:t,instrument:!1,supportsDynamicImport:!1,supportsExportNamespaceFrom:!1,supportsStaticESM:!1,supportsTopLevelAwait:!1})}}const removeFile=e=>{try{fs().unlinkSync(e)}catch{}},stripShebang=e=>e.startsWith("#!")?e.replace(/^#!.*/,""):e;function writeCodeCacheFile(e,r){const t=(0,_crypto().createHash)("sha1").update(r).digest("hex").substring(0,32);writeCacheFile(e,`${t}\n${r}`)}function readCodeCacheFile(e){const r=readCacheFile(e);if(null==r)return null;const t=r.substring(33);return(0,_crypto().createHash)("sha1").update(t).digest("hex").substring(0,32)===r.substring(0,32)?t:null}const writeCacheFile=(e,r)=>{try{(0,_writeFileAtomic().sync)(e,r,{encoding:"utf8",fsync:!1})}catch(r){if(!(r instanceof Error))throw r;if(cacheWriteErrorSafeToIgnore(r,e))return;throw r.message=`jest: failed to cache transform results in: ${e}\nFailure message: ${r.message}`,removeFile(e),r}},cacheWriteErrorSafeToIgnore=(e,r)=>"win32"===process.platform&&"EPERM"===e.code&&fs().existsSync(r),readCacheFile=e=>{if(!fs().existsSync(e))return null;let r;try{r=fs().readFileSync(e,"utf8")}catch(r){if(!(r instanceof Error))throw r;if("ENOENT"===r.code&&"win32"===process.platform)return null;throw r.message=`jest: failed to read cache file: ${e}\nFailure message: ${r.message}`,removeFile(e),r}return null==r&&removeFile(e),r},getScriptCacheKey=(e,r)=>`${e}_${fs().statSync(e).mtime.getTime()}${r?"_instrumented":""}`,calcIgnorePatternRegExp=e=>{if(null!=e.transformIgnorePatterns&&0!==e.transformIgnorePatterns.length)return new RegExp(e.transformIgnorePatterns.join("|"))},calcTransformRegExp=e=>{if(!e.transform.length)return;const r=[];for(let t=0;t<e.transform.length;t++)r.push([new RegExp(e.transform[t][0]),e.transform[t][1],e.transform[t][2]]);return r};function assertSyncTransformer(e,r){(0,_jestUtil().invariant)(r),(0,_jestUtil().invariant)("function"==typeof e.process,(0,_runtimeErrorsAndWarnings.makeInvalidSyncTransformerError)(r))}async function createScriptTransformer(e,r=new Map){const t=new ScriptTransformer(e,r);return await t.loadTransformers(),t}