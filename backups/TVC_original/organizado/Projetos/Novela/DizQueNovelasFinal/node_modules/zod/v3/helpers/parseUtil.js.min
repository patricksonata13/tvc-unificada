import{getErrorMap}from"../errors.js";import defaultErrorMap from"../locales/en.js";export const makeIssue=t=>{const{data:e,path:s,errorMaps:a,issueData:r}=t,o=[...s,...r.path||[]],u={...r,path:o};if(void 0!==r.message)return{...r,path:o,message:r.message};let i="";const n=a.filter(t=>!!t).slice().reverse();for(const t of n)i=t(u,{data:e,defaultError:i}).message;return{...r,path:o,message:i}};export const EMPTY_PATH=[];export function addIssueToContext(t,e){const s=getErrorMap(),a=makeIssue({issueData:e,data:t.data,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,s,s===defaultErrorMap?void 0:defaultErrorMap].filter(t=>!!t)});t.common.issues.push(a)}export class ParseStatus{constructor(){this.value="valid"}dirty(){"valid"===this.value&&(this.value="dirty")}abort(){"aborted"!==this.value&&(this.value="aborted")}static mergeArray(t,e){const s=[];for(const a of e){if("aborted"===a.status)return INVALID;"dirty"===a.status&&t.dirty(),s.push(a.value)}return{status:t.value,value:s}}static async mergeObjectAsync(t,e){const s=[];for(const t of e){const e=await t.key,a=await t.value;s.push({key:e,value:a})}return ParseStatus.mergeObjectSync(t,s)}static mergeObjectSync(t,e){const s={};for(const a of e){const{key:e,value:r}=a;if("aborted"===e.status)return INVALID;if("aborted"===r.status)return INVALID;"dirty"===e.status&&t.dirty(),"dirty"===r.status&&t.dirty(),"__proto__"===e.value||void 0===r.value&&!a.alwaysSet||(s[e.value]=r.value)}return{status:t.value,value:s}}}export const INVALID=Object.freeze({status:"aborted"});export const DIRTY=t=>({status:"dirty",value:t});export const OK=t=>({status:"valid",value:t});export const isAborted=t=>"aborted"===t.status;export const isDirty=t=>"dirty"===t.status;export const isValid=t=>"valid"===t.status;export const isAsync=t=>"undefined"!=typeof Promise&&t instanceof Promise;