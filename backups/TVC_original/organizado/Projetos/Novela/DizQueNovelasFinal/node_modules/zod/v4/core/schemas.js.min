import*as checks from"./checks.js";import*as core from"./core.js";import{Doc}from"./doc.js";import{safeParse,safeParseAsync}from"./parse.js";import*as regexes from"./regexes.js";import*as util from"./util.js";import{version}from"./versions.js";export const $ZodType=core.$constructor("$ZodType",(e,t)=>{var o;e??(e={}),e._zod.def=t,e._zod.bag=e._zod.bag||{},e._zod.version=version;const n=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&n.unshift(e);for(const t of n)for(const o of t._zod.onattach)o(e);if(0===n.length)(o=e._zod).deferred??(o.deferred=[]),e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse});else{const t=(e,t,o)=>{let n,s=util.aborted(e);for(const r of t){if(r._zod.def.when){if(!r._zod.def.when(e))continue}else if(s)continue;const t=e.issues.length,i=r._zod.check(e);if(i instanceof Promise&&!1===o?.async)throw new core.$ZodAsyncError;if(n||i instanceof Promise)n=(n??Promise.resolve()).then(async()=>{await i;e.issues.length!==t&&(s||(s=util.aborted(e,t)))});else{if(e.issues.length===t)continue;s||(s=util.aborted(e,t))}}return n?n.then(()=>e):e};e._zod.run=(o,s)=>{const r=e._zod.parse(o,s);if(r instanceof Promise){if(!1===s.async)throw new core.$ZodAsyncError;return r.then(e=>t(e,n,s))}return t(r,n,s)}}e["~standard"]={validate:t=>{try{const o=safeParse(e,t);return o.success?{value:o.data}:{issues:o.error?.issues}}catch(o){return safeParseAsync(e,t).then(e=>e.success?{value:e.data}:{issues:e.error?.issues})}},vendor:"zod",version:1}});export{clone}from"./util.js";export const $ZodString=core.$constructor("$ZodString",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=[...e?._zod.bag?.patterns??[]].pop()??regexes.string(e._zod.bag),e._zod.parse=(o,n)=>{if(t.coerce)try{o.value=String(o.value)}catch(n){}return"string"==typeof o.value||o.issues.push({expected:"string",code:"invalid_type",input:o.value,inst:e}),o}});export const $ZodStringFormat=core.$constructor("$ZodStringFormat",(e,t)=>{checks.$ZodCheckStringFormat.init(e,t),$ZodString.init(e,t)});export const $ZodGUID=core.$constructor("$ZodGUID",(e,t)=>{t.pattern??(t.pattern=regexes.guid),$ZodStringFormat.init(e,t)});export const $ZodUUID=core.$constructor("$ZodUUID",(e,t)=>{if(t.version){const e={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[t.version];if(void 0===e)throw new Error(`Invalid UUID version: "${t.version}"`);t.pattern??(t.pattern=regexes.uuid(e))}else t.pattern??(t.pattern=regexes.uuid());$ZodStringFormat.init(e,t)});export const $ZodEmail=core.$constructor("$ZodEmail",(e,t)=>{t.pattern??(t.pattern=regexes.email),$ZodStringFormat.init(e,t)});export const $ZodURL=core.$constructor("$ZodURL",(e,t)=>{$ZodStringFormat.init(e,t),e._zod.check=o=>{try{const n=o.value,s=new URL(n),r=s.href;return t.hostname&&(t.hostname.lastIndex=0,t.hostname.test(s.hostname)||o.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:regexes.hostname.source,input:o.value,inst:e,continue:!t.abort})),t.protocol&&(t.protocol.lastIndex=0,t.protocol.test(s.protocol.endsWith(":")?s.protocol.slice(0,-1):s.protocol)||o.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:t.protocol.source,input:o.value,inst:e,continue:!t.abort})),void(!n.endsWith("/")&&r.endsWith("/")?o.value=r.slice(0,-1):o.value=r)}catch(n){o.issues.push({code:"invalid_format",format:"url",input:o.value,inst:e,continue:!t.abort})}}});export const $ZodEmoji=core.$constructor("$ZodEmoji",(e,t)=>{t.pattern??(t.pattern=regexes.emoji()),$ZodStringFormat.init(e,t)});export const $ZodNanoID=core.$constructor("$ZodNanoID",(e,t)=>{t.pattern??(t.pattern=regexes.nanoid),$ZodStringFormat.init(e,t)});export const $ZodCUID=core.$constructor("$ZodCUID",(e,t)=>{t.pattern??(t.pattern=regexes.cuid),$ZodStringFormat.init(e,t)});export const $ZodCUID2=core.$constructor("$ZodCUID2",(e,t)=>{t.pattern??(t.pattern=regexes.cuid2),$ZodStringFormat.init(e,t)});export const $ZodULID=core.$constructor("$ZodULID",(e,t)=>{t.pattern??(t.pattern=regexes.ulid),$ZodStringFormat.init(e,t)});export const $ZodXID=core.$constructor("$ZodXID",(e,t)=>{t.pattern??(t.pattern=regexes.xid),$ZodStringFormat.init(e,t)});export const $ZodKSUID=core.$constructor("$ZodKSUID",(e,t)=>{t.pattern??(t.pattern=regexes.ksuid),$ZodStringFormat.init(e,t)});export const $ZodISODateTime=core.$constructor("$ZodISODateTime",(e,t)=>{t.pattern??(t.pattern=regexes.datetime(t)),$ZodStringFormat.init(e,t)});export const $ZodISODate=core.$constructor("$ZodISODate",(e,t)=>{t.pattern??(t.pattern=regexes.date),$ZodStringFormat.init(e,t)});export const $ZodISOTime=core.$constructor("$ZodISOTime",(e,t)=>{t.pattern??(t.pattern=regexes.time(t)),$ZodStringFormat.init(e,t)});export const $ZodISODuration=core.$constructor("$ZodISODuration",(e,t)=>{t.pattern??(t.pattern=regexes.duration),$ZodStringFormat.init(e,t)});export const $ZodIPv4=core.$constructor("$ZodIPv4",(e,t)=>{t.pattern??(t.pattern=regexes.ipv4),$ZodStringFormat.init(e,t),e._zod.onattach.push(e=>{e._zod.bag.format="ipv4"})});export const $ZodIPv6=core.$constructor("$ZodIPv6",(e,t)=>{t.pattern??(t.pattern=regexes.ipv6),$ZodStringFormat.init(e,t),e._zod.onattach.push(e=>{e._zod.bag.format="ipv6"}),e._zod.check=o=>{try{new URL(`http://[${o.value}]`)}catch{o.issues.push({code:"invalid_format",format:"ipv6",input:o.value,inst:e,continue:!t.abort})}}});export const $ZodCIDRv4=core.$constructor("$ZodCIDRv4",(e,t)=>{t.pattern??(t.pattern=regexes.cidrv4),$ZodStringFormat.init(e,t)});export const $ZodCIDRv6=core.$constructor("$ZodCIDRv6",(e,t)=>{t.pattern??(t.pattern=regexes.cidrv6),$ZodStringFormat.init(e,t),e._zod.check=o=>{const[n,s]=o.value.split("/");try{if(!s)throw new Error;const e=Number(s);if(`${e}`!==s)throw new Error;if(e<0||e>128)throw new Error;new URL(`http://[${n}]`)}catch{o.issues.push({code:"invalid_format",format:"cidrv6",input:o.value,inst:e,continue:!t.abort})}}});export function isValidBase64(e){if(""===e)return!0;if(e.length%4!=0)return!1;try{return atob(e),!0}catch{return!1}}export const $ZodBase64=core.$constructor("$ZodBase64",(e,t)=>{t.pattern??(t.pattern=regexes.base64),$ZodStringFormat.init(e,t),e._zod.onattach.push(e=>{e._zod.bag.contentEncoding="base64"}),e._zod.check=o=>{isValidBase64(o.value)||o.issues.push({code:"invalid_format",format:"base64",input:o.value,inst:e,continue:!t.abort})}});export function isValidBase64URL(e){if(!regexes.base64url.test(e))return!1;const t=e.replace(/[-_]/g,e=>"-"===e?"+":"/");return isValidBase64(t.padEnd(4*Math.ceil(t.length/4),"="))}export const $ZodBase64URL=core.$constructor("$ZodBase64URL",(e,t)=>{t.pattern??(t.pattern=regexes.base64url),$ZodStringFormat.init(e,t),e._zod.onattach.push(e=>{e._zod.bag.contentEncoding="base64url"}),e._zod.check=o=>{isValidBase64URL(o.value)||o.issues.push({code:"invalid_format",format:"base64url",input:o.value,inst:e,continue:!t.abort})}});export const $ZodE164=core.$constructor("$ZodE164",(e,t)=>{t.pattern??(t.pattern=regexes.e164),$ZodStringFormat.init(e,t)});export function isValidJWT(e,t=null){try{const o=e.split(".");if(3!==o.length)return!1;const[n]=o;if(!n)return!1;const s=JSON.parse(atob(n));return(!("typ"in s)||"JWT"===s?.typ)&&(!!s.alg&&(!t||"alg"in s&&s.alg===t))}catch{return!1}}export const $ZodJWT=core.$constructor("$ZodJWT",(e,t)=>{$ZodStringFormat.init(e,t),e._zod.check=o=>{isValidJWT(o.value,t.alg)||o.issues.push({code:"invalid_format",format:"jwt",input:o.value,inst:e,continue:!t.abort})}});export const $ZodCustomStringFormat=core.$constructor("$ZodCustomStringFormat",(e,t)=>{$ZodStringFormat.init(e,t),e._zod.check=o=>{t.fn(o.value)||o.issues.push({code:"invalid_format",format:t.format,input:o.value,inst:e,continue:!t.abort})}});export const $ZodNumber=core.$constructor("$ZodNumber",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=e._zod.bag.pattern??regexes.number,e._zod.parse=(o,n)=>{if(t.coerce)try{o.value=Number(o.value)}catch(e){}const s=o.value;if("number"==typeof s&&!Number.isNaN(s)&&Number.isFinite(s))return o;const r="number"==typeof s?Number.isNaN(s)?"NaN":Number.isFinite(s)?void 0:"Infinity":void 0;return o.issues.push({expected:"number",code:"invalid_type",input:s,inst:e,...r?{received:r}:{}}),o}});export const $ZodNumberFormat=core.$constructor("$ZodNumber",(e,t)=>{checks.$ZodCheckNumberFormat.init(e,t),$ZodNumber.init(e,t)});export const $ZodBoolean=core.$constructor("$ZodBoolean",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=regexes.boolean,e._zod.parse=(o,n)=>{if(t.coerce)try{o.value=Boolean(o.value)}catch(e){}const s=o.value;return"boolean"==typeof s||o.issues.push({expected:"boolean",code:"invalid_type",input:s,inst:e}),o}});export const $ZodBigInt=core.$constructor("$ZodBigInt",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=regexes.bigint,e._zod.parse=(o,n)=>{if(t.coerce)try{o.value=BigInt(o.value)}catch(e){}return"bigint"==typeof o.value||o.issues.push({expected:"bigint",code:"invalid_type",input:o.value,inst:e}),o}});export const $ZodBigIntFormat=core.$constructor("$ZodBigInt",(e,t)=>{checks.$ZodCheckBigIntFormat.init(e,t),$ZodBigInt.init(e,t)});export const $ZodSymbol=core.$constructor("$ZodSymbol",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(t,o)=>{const n=t.value;return"symbol"==typeof n||t.issues.push({expected:"symbol",code:"invalid_type",input:n,inst:e}),t}});export const $ZodUndefined=core.$constructor("$ZodUndefined",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=regexes.undefined,e._zod.values=new Set([void 0]),e._zod.optin="optional",e._zod.optout="optional",e._zod.parse=(t,o)=>{const n=t.value;return void 0===n||t.issues.push({expected:"undefined",code:"invalid_type",input:n,inst:e}),t}});export const $ZodNull=core.$constructor("$ZodNull",(e,t)=>{$ZodType.init(e,t),e._zod.pattern=regexes.null,e._zod.values=new Set([null]),e._zod.parse=(t,o)=>{const n=t.value;return null===n||t.issues.push({expected:"null",code:"invalid_type",input:n,inst:e}),t}});export const $ZodAny=core.$constructor("$ZodAny",(e,t)=>{$ZodType.init(e,t),e._zod.parse=e=>e});export const $ZodUnknown=core.$constructor("$ZodUnknown",(e,t)=>{$ZodType.init(e,t),e._zod.parse=e=>e});export const $ZodNever=core.$constructor("$ZodNever",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(t,o)=>(t.issues.push({expected:"never",code:"invalid_type",input:t.value,inst:e}),t)});export const $ZodVoid=core.$constructor("$ZodVoid",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(t,o)=>{const n=t.value;return void 0===n||t.issues.push({expected:"void",code:"invalid_type",input:n,inst:e}),t}});export const $ZodDate=core.$constructor("$ZodDate",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(o,n)=>{if(t.coerce)try{o.value=new Date(o.value)}catch(e){}const s=o.value,r=s instanceof Date;return r&&!Number.isNaN(s.getTime())||o.issues.push({expected:"date",code:"invalid_type",input:s,...r?{received:"Invalid Date"}:{},inst:e}),o}});function handleArrayResult(e,t,o){e.issues.length&&t.issues.push(...util.prefixIssues(o,e.issues)),t.value[o]=e.value}export const $ZodArray=core.$constructor("$ZodArray",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(o,n)=>{const s=o.value;if(!Array.isArray(s))return o.issues.push({expected:"array",code:"invalid_type",input:s,inst:e}),o;o.value=Array(s.length);const r=[];for(let e=0;e<s.length;e++){const i=s[e],u=t.element._zod.run({value:i,issues:[]},n);u instanceof Promise?r.push(u.then(t=>handleArrayResult(t,o,e))):handleArrayResult(u,o,e)}return r.length?Promise.all(r).then(()=>o):o}});function handleObjectResult(e,t,o){e.issues.length&&t.issues.push(...util.prefixIssues(o,e.issues)),t.value[o]=e.value}function handleOptionalObjectResult(e,t,o,n){e.issues.length?void 0===n[o]?t.value[o]=o in n?void 0:e.value:t.issues.push(...util.prefixIssues(o,e.issues)):void 0===e.value?o in n&&(t.value[o]=void 0):t.value[o]=e.value}export const $ZodObject=core.$constructor("$ZodObject",(e,t)=>{$ZodType.init(e,t);const o=util.cached(()=>{const e=Object.keys(t.shape);for(const o of e)if(!(t.shape[o]instanceof $ZodType))throw new Error(`Invalid element at key "${o}": expected a Zod schema`);const o=util.optionalKeys(t.shape);return{shape:t.shape,keys:e,keySet:new Set(e),numKeys:e.length,optionalKeys:new Set(o)}});util.defineLazy(e._zod,"propValues",()=>{const e=t.shape,o={};for(const t in e){const n=e[t]._zod;if(n.values){o[t]??(o[t]=new Set);for(const e of n.values)o[t].add(e)}}return o});let n;const s=util.isObject,r=!core.globalConfig.jitless,i=util.allowsEval,u=r&&i.value,a=t.catchall;let d;e._zod.parse=(i,c)=>{d??(d=o.value);const l=i.value;if(!s(l))return i.issues.push({expected:"object",code:"invalid_type",input:l,inst:e}),i;const p=[];if(r&&u&&!1===c?.async&&!0!==c.jitless)n||(n=(e=>{const t=new Doc(["shape","payload","ctx"]),n=o.value,s=e=>{const t=util.esc(e);return`shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)`};t.write("const input = payload.value;");const r=Object.create(null);let i=0;for(const e of n.keys)r[e]="key_"+i++;t.write("const newResult = {}");for(const e of n.keys)if(n.optionalKeys.has(e)){const o=r[e];t.write(`const ${o} = ${s(e)};`);const n=util.esc(e);t.write(`\n        if (${o}.issues.length) {\n          if (input[${n}] === undefined) {\n            if (${n} in input) {\n              newResult[${n}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${o}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${n}, ...iss.path] : [${n}],\n              }))\n            );\n          }\n        } else if (${o}.value === undefined) {\n          if (${n} in input) newResult[${n}] = undefined;\n        } else {\n          newResult[${n}] = ${o}.value;\n        }\n        `)}else{const o=r[e];t.write(`const ${o} = ${s(e)};`),t.write(`\n          if (${o}.issues.length) payload.issues = payload.issues.concat(${o}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${util.esc(e)}, ...iss.path] : [${util.esc(e)}]\n          })));`),t.write(`newResult[${util.esc(e)}] = ${o}.value`)}t.write("payload.value = newResult;"),t.write("return payload;");const u=t.compile();return(t,o)=>u(e,t,o)})(t.shape)),i=n(i,c);else{i.value={};const e=d.shape;for(const t of d.keys){const o=e[t],n=o._zod.run({value:l[t],issues:[]},c),s="optional"===o._zod.optin&&"optional"===o._zod.optout;n instanceof Promise?p.push(n.then(e=>s?handleOptionalObjectResult(e,i,t,l):handleObjectResult(e,i,t))):s?handleOptionalObjectResult(n,i,t,l):handleObjectResult(n,i,t)}}if(!a)return p.length?Promise.all(p).then(()=>i):i;const f=[],v=d.keySet,h=a._zod,$=h.def.type;for(const e of Object.keys(l)){if(v.has(e))continue;if("never"===$){f.push(e);continue}const t=h.run({value:l[e],issues:[]},c);t instanceof Promise?p.push(t.then(t=>handleObjectResult(t,i,e))):handleObjectResult(t,i,e)}return f.length&&i.issues.push({code:"unrecognized_keys",keys:f,input:l,inst:e}),p.length?Promise.all(p).then(()=>i):i}});function handleUnionResults(e,t,o,n){for(const o of e)if(0===o.issues.length)return t.value=o.value,t;return t.issues.push({code:"invalid_union",input:t.value,inst:o,errors:e.map(e=>e.issues.map(e=>util.finalizeIssue(e,n,core.config())))}),t}export const $ZodUnion=core.$constructor("$ZodUnion",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"optin",()=>t.options.some(e=>"optional"===e._zod.optin)?"optional":void 0),util.defineLazy(e._zod,"optout",()=>t.options.some(e=>"optional"===e._zod.optout)?"optional":void 0),util.defineLazy(e._zod,"values",()=>{if(t.options.every(e=>e._zod.values))return new Set(t.options.flatMap(e=>Array.from(e._zod.values)))}),util.defineLazy(e._zod,"pattern",()=>{if(t.options.every(e=>e._zod.pattern)){const e=t.options.map(e=>e._zod.pattern);return new RegExp(`^(${e.map(e=>util.cleanRegex(e.source)).join("|")})$`)}}),e._zod.parse=(o,n)=>{let s=!1;const r=[];for(const e of t.options){const t=e._zod.run({value:o.value,issues:[]},n);if(t instanceof Promise)r.push(t),s=!0;else{if(0===t.issues.length)return t;r.push(t)}}return s?Promise.all(r).then(t=>handleUnionResults(t,o,e,n)):handleUnionResults(r,o,e,n)}});export const $ZodDiscriminatedUnion=core.$constructor("$ZodDiscriminatedUnion",(e,t)=>{$ZodUnion.init(e,t);const o=e._zod.parse;util.defineLazy(e._zod,"propValues",()=>{const e={};for(const o of t.options){const n=o._zod.propValues;if(!n||0===Object.keys(n).length)throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);for(const[t,o]of Object.entries(n)){e[t]||(e[t]=new Set);for(const n of o)e[t].add(n)}}return e});const n=util.cached(()=>{const e=t.options,o=new Map;for(const n of e){const e=n._zod.propValues[t.discriminator];if(!e||0===e.size)throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(n)}"`);for(const t of e){if(o.has(t))throw new Error(`Duplicate discriminator value "${String(t)}"`);o.set(t,n)}}return o});e._zod.parse=(s,r)=>{const i=s.value;if(!util.isObject(i))return s.issues.push({code:"invalid_type",expected:"object",input:i,inst:e}),s;const u=n.value.get(i?.[t.discriminator]);return u?u._zod.run(s,r):t.unionFallback?o(s,r):(s.issues.push({code:"invalid_union",errors:[],note:"No matching discriminator",input:i,path:[t.discriminator],inst:e}),s)}});export const $ZodIntersection=core.$constructor("$ZodIntersection",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(e,o)=>{const n=e.value,s=t.left._zod.run({value:n,issues:[]},o),r=t.right._zod.run({value:n,issues:[]},o);return s instanceof Promise||r instanceof Promise?Promise.all([s,r]).then(([t,o])=>handleIntersectionResults(e,t,o)):handleIntersectionResults(e,s,r)}});function mergeValues(e,t){if(e===t)return{valid:!0,data:e};if(e instanceof Date&&t instanceof Date&&+e===+t)return{valid:!0,data:e};if(util.isPlainObject(e)&&util.isPlainObject(t)){const o=Object.keys(t),n=Object.keys(e).filter(e=>-1!==o.indexOf(e)),s={...e,...t};for(const o of n){const n=mergeValues(e[o],t[o]);if(!n.valid)return{valid:!1,mergeErrorPath:[o,...n.mergeErrorPath]};s[o]=n.data}return{valid:!0,data:s}}if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return{valid:!1,mergeErrorPath:[]};const o=[];for(let n=0;n<e.length;n++){const s=mergeValues(e[n],t[n]);if(!s.valid)return{valid:!1,mergeErrorPath:[n,...s.mergeErrorPath]};o.push(s.data)}return{valid:!0,data:o}}return{valid:!1,mergeErrorPath:[]}}function handleIntersectionResults(e,t,o){if(t.issues.length&&e.issues.push(...t.issues),o.issues.length&&e.issues.push(...o.issues),util.aborted(e))return e;const n=mergeValues(t.value,o.value);if(!n.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(n.mergeErrorPath)}`);return e.value=n.data,e}export const $ZodTuple=core.$constructor("$ZodTuple",(e,t)=>{$ZodType.init(e,t);const o=t.items,n=o.length-[...o].reverse().findIndex(e=>"optional"!==e._zod.optin);e._zod.parse=(s,r)=>{const i=s.value;if(!Array.isArray(i))return s.issues.push({input:i,inst:e,expected:"tuple",code:"invalid_type"}),s;s.value=[];const u=[];if(!t.rest){const t=i.length>o.length,r=i.length<n-1;if(t||r)return s.issues.push({input:i,inst:e,origin:"array",...t?{code:"too_big",maximum:o.length}:{code:"too_small",minimum:o.length}}),s}let a=-1;for(const e of o){if(a++,a>=i.length&&a>=n)continue;const t=e._zod.run({value:i[a],issues:[]},r);t instanceof Promise?u.push(t.then(e=>handleTupleResult(e,s,a))):handleTupleResult(t,s,a)}if(t.rest){const e=i.slice(o.length);for(const o of e){a++;const e=t.rest._zod.run({value:o,issues:[]},r);e instanceof Promise?u.push(e.then(e=>handleTupleResult(e,s,a))):handleTupleResult(e,s,a)}}return u.length?Promise.all(u).then(()=>s):s}});function handleTupleResult(e,t,o){e.issues.length&&t.issues.push(...util.prefixIssues(o,e.issues)),t.value[o]=e.value}export const $ZodRecord=core.$constructor("$ZodRecord",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(o,n)=>{const s=o.value;if(!util.isPlainObject(s))return o.issues.push({expected:"record",code:"invalid_type",input:s,inst:e}),o;const r=[];if(t.keyType._zod.values){const i=t.keyType._zod.values;o.value={};for(const e of i)if("string"==typeof e||"number"==typeof e||"symbol"==typeof e){const i=t.valueType._zod.run({value:s[e],issues:[]},n);i instanceof Promise?r.push(i.then(t=>{t.issues.length&&o.issues.push(...util.prefixIssues(e,t.issues)),o.value[e]=t.value})):(i.issues.length&&o.issues.push(...util.prefixIssues(e,i.issues)),o.value[e]=i.value)}let u;for(const e in s)i.has(e)||(u=u??[],u.push(e));u&&u.length>0&&o.issues.push({code:"unrecognized_keys",input:s,inst:e,keys:u})}else{o.value={};for(const i of Reflect.ownKeys(s)){if("__proto__"===i)continue;const u=t.keyType._zod.run({value:i,issues:[]},n);if(u instanceof Promise)throw new Error("Async schemas not supported in object keys currently");if(u.issues.length){o.issues.push({origin:"record",code:"invalid_key",issues:u.issues.map(e=>util.finalizeIssue(e,n,core.config())),input:i,path:[i],inst:e}),o.value[u.value]=u.value;continue}const a=t.valueType._zod.run({value:s[i],issues:[]},n);a instanceof Promise?r.push(a.then(e=>{e.issues.length&&o.issues.push(...util.prefixIssues(i,e.issues)),o.value[u.value]=e.value})):(a.issues.length&&o.issues.push(...util.prefixIssues(i,a.issues)),o.value[u.value]=a.value)}}return r.length?Promise.all(r).then(()=>o):o}});export const $ZodMap=core.$constructor("$ZodMap",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(o,n)=>{const s=o.value;if(!(s instanceof Map))return o.issues.push({expected:"map",code:"invalid_type",input:s,inst:e}),o;const r=[];o.value=new Map;for(const[i,u]of s){const a=t.keyType._zod.run({value:i,issues:[]},n),d=t.valueType._zod.run({value:u,issues:[]},n);a instanceof Promise||d instanceof Promise?r.push(Promise.all([a,d]).then(([t,r])=>{handleMapResult(t,r,o,i,s,e,n)})):handleMapResult(a,d,o,i,s,e,n)}return r.length?Promise.all(r).then(()=>o):o}});function handleMapResult(e,t,o,n,s,r,i){e.issues.length&&(util.propertyKeyTypes.has(typeof n)?o.issues.push(...util.prefixIssues(n,e.issues)):o.issues.push({origin:"map",code:"invalid_key",input:s,inst:r,issues:e.issues.map(e=>util.finalizeIssue(e,i,core.config()))})),t.issues.length&&(util.propertyKeyTypes.has(typeof n)?o.issues.push(...util.prefixIssues(n,t.issues)):o.issues.push({origin:"map",code:"invalid_element",input:s,inst:r,key:n,issues:t.issues.map(e=>util.finalizeIssue(e,i,core.config()))})),o.value.set(e.value,t.value)}export const $ZodSet=core.$constructor("$ZodSet",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(o,n)=>{const s=o.value;if(!(s instanceof Set))return o.issues.push({input:s,inst:e,expected:"set",code:"invalid_type"}),o;const r=[];o.value=new Set;for(const e of s){const s=t.valueType._zod.run({value:e,issues:[]},n);s instanceof Promise?r.push(s.then(e=>handleSetResult(e,o))):handleSetResult(s,o)}return r.length?Promise.all(r).then(()=>o):o}});function handleSetResult(e,t){e.issues.length&&t.issues.push(...e.issues),t.value.add(e.value)}export const $ZodEnum=core.$constructor("$ZodEnum",(e,t)=>{$ZodType.init(e,t);const o=util.getEnumValues(t.entries);e._zod.values=new Set(o),e._zod.pattern=new RegExp(`^(${o.filter(e=>util.propertyKeyTypes.has(typeof e)).map(e=>"string"==typeof e?util.escapeRegex(e):e.toString()).join("|")})$`),e._zod.parse=(t,n)=>{const s=t.value;return e._zod.values.has(s)||t.issues.push({code:"invalid_value",values:o,input:s,inst:e}),t}});export const $ZodLiteral=core.$constructor("$ZodLiteral",(e,t)=>{$ZodType.init(e,t),e._zod.values=new Set(t.values),e._zod.pattern=new RegExp(`^(${t.values.map(e=>"string"==typeof e?util.escapeRegex(e):e?e.toString():String(e)).join("|")})$`),e._zod.parse=(o,n)=>{const s=o.value;return e._zod.values.has(s)||o.issues.push({code:"invalid_value",values:t.values,input:s,inst:e}),o}});export const $ZodFile=core.$constructor("$ZodFile",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(t,o)=>{const n=t.value;return n instanceof File||t.issues.push({expected:"file",code:"invalid_type",input:n,inst:e}),t}});export const $ZodTransform=core.$constructor("$ZodTransform",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(e,o)=>{const n=t.transform(e.value,e);if(o.async){return(n instanceof Promise?n:Promise.resolve(n)).then(t=>(e.value=t,e))}if(n instanceof Promise)throw new core.$ZodAsyncError;return e.value=n,e}});export const $ZodOptional=core.$constructor("$ZodOptional",(e,t)=>{$ZodType.init(e,t),e._zod.optin="optional",e._zod.optout="optional",util.defineLazy(e._zod,"values",()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,void 0]):void 0),util.defineLazy(e._zod,"pattern",()=>{const e=t.innerType._zod.pattern;return e?new RegExp(`^(${util.cleanRegex(e.source)})?$`):void 0}),e._zod.parse=(e,o)=>"optional"===t.innerType._zod.optin?t.innerType._zod.run(e,o):void 0===e.value?e:t.innerType._zod.run(e,o)});export const $ZodNullable=core.$constructor("$ZodNullable",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"optin",()=>t.innerType._zod.optin),util.defineLazy(e._zod,"optout",()=>t.innerType._zod.optout),util.defineLazy(e._zod,"pattern",()=>{const e=t.innerType._zod.pattern;return e?new RegExp(`^(${util.cleanRegex(e.source)}|null)$`):void 0}),util.defineLazy(e._zod,"values",()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,null]):void 0),e._zod.parse=(e,o)=>null===e.value?e:t.innerType._zod.run(e,o)});export const $ZodDefault=core.$constructor("$ZodDefault",(e,t)=>{$ZodType.init(e,t),e._zod.optin="optional",util.defineLazy(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(e,o)=>{if(void 0===e.value)return e.value=t.defaultValue,e;const n=t.innerType._zod.run(e,o);return n instanceof Promise?n.then(e=>handleDefaultResult(e,t)):handleDefaultResult(n,t)}});function handleDefaultResult(e,t){return void 0===e.value&&(e.value=t.defaultValue),e}export const $ZodPrefault=core.$constructor("$ZodPrefault",(e,t)=>{$ZodType.init(e,t),e._zod.optin="optional",util.defineLazy(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(e,o)=>(void 0===e.value&&(e.value=t.defaultValue),t.innerType._zod.run(e,o))});export const $ZodNonOptional=core.$constructor("$ZodNonOptional",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"values",()=>{const e=t.innerType._zod.values;return e?new Set([...e].filter(e=>void 0!==e)):void 0}),e._zod.parse=(o,n)=>{const s=t.innerType._zod.run(o,n);return s instanceof Promise?s.then(t=>handleNonOptionalResult(t,e)):handleNonOptionalResult(s,e)}});function handleNonOptionalResult(e,t){return e.issues.length||void 0!==e.value||e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:t}),e}export const $ZodSuccess=core.$constructor("$ZodSuccess",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(e,o)=>{const n=t.innerType._zod.run(e,o);return n instanceof Promise?n.then(t=>(e.value=0===t.issues.length,e)):(e.value=0===n.issues.length,e)}});export const $ZodCatch=core.$constructor("$ZodCatch",(e,t)=>{$ZodType.init(e,t),e._zod.optin="optional",util.defineLazy(e._zod,"optout",()=>t.innerType._zod.optout),util.defineLazy(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(e,o)=>{const n=t.innerType._zod.run(e,o);return n instanceof Promise?n.then(n=>(e.value=n.value,n.issues.length&&(e.value=t.catchValue({...e,error:{issues:n.issues.map(e=>util.finalizeIssue(e,o,core.config()))},input:e.value}),e.issues=[]),e)):(e.value=n.value,n.issues.length&&(e.value=t.catchValue({...e,error:{issues:n.issues.map(e=>util.finalizeIssue(e,o,core.config()))},input:e.value}),e.issues=[]),e)}});export const $ZodNaN=core.$constructor("$ZodNaN",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(t,o)=>("number"==typeof t.value&&Number.isNaN(t.value)||t.issues.push({input:t.value,inst:e,expected:"nan",code:"invalid_type"}),t)});export const $ZodPipe=core.$constructor("$ZodPipe",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"values",()=>t.in._zod.values),util.defineLazy(e._zod,"optin",()=>t.in._zod.optin),util.defineLazy(e._zod,"optout",()=>t.out._zod.optout),e._zod.parse=(e,o)=>{const n=t.in._zod.run(e,o);return n instanceof Promise?n.then(e=>handlePipeResult(e,t,o)):handlePipeResult(n,t,o)}});function handlePipeResult(e,t,o){return util.aborted(e)?e:t.out._zod.run({value:e.value,issues:e.issues},o)}export const $ZodReadonly=core.$constructor("$ZodReadonly",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"propValues",()=>t.innerType._zod.propValues),util.defineLazy(e._zod,"values",()=>t.innerType._zod.values),util.defineLazy(e._zod,"optin",()=>t.innerType._zod.optin),util.defineLazy(e._zod,"optout",()=>t.innerType._zod.optout),e._zod.parse=(e,o)=>{const n=t.innerType._zod.run(e,o);return n instanceof Promise?n.then(handleReadonlyResult):handleReadonlyResult(n)}});function handleReadonlyResult(e){return e.value=Object.freeze(e.value),e}export const $ZodTemplateLiteral=core.$constructor("$ZodTemplateLiteral",(e,t)=>{$ZodType.init(e,t);const o=[];for(const e of t.parts)if(e instanceof $ZodType){if(!e._zod.pattern)throw new Error(`Invalid template literal part, no pattern found: ${[...e._zod.traits].shift()}`);const t=e._zod.pattern instanceof RegExp?e._zod.pattern.source:e._zod.pattern;if(!t)throw new Error(`Invalid template literal part: ${e._zod.traits}`);const n=t.startsWith("^")?1:0,s=t.endsWith("$")?t.length-1:t.length;o.push(t.slice(n,s))}else{if(null!==e&&!util.primitiveTypes.has(typeof e))throw new Error(`Invalid template literal part: ${e}`);o.push(util.escapeRegex(`${e}`))}e._zod.pattern=new RegExp(`^${o.join("")}$`),e._zod.parse=(t,o)=>"string"!=typeof t.value?(t.issues.push({input:t.value,inst:e,expected:"template_literal",code:"invalid_type"}),t):(e._zod.pattern.lastIndex=0,e._zod.pattern.test(t.value)||t.issues.push({input:t.value,inst:e,code:"invalid_format",format:"template_literal",pattern:e._zod.pattern.source}),t)});export const $ZodPromise=core.$constructor("$ZodPromise",(e,t)=>{$ZodType.init(e,t),e._zod.parse=(e,o)=>Promise.resolve(e.value).then(e=>t.innerType._zod.run({value:e,issues:[]},o))});export const $ZodLazy=core.$constructor("$ZodLazy",(e,t)=>{$ZodType.init(e,t),util.defineLazy(e._zod,"innerType",()=>t.getter()),util.defineLazy(e._zod,"pattern",()=>e._zod.innerType._zod.pattern),util.defineLazy(e._zod,"propValues",()=>e._zod.innerType._zod.propValues),util.defineLazy(e._zod,"optin",()=>e._zod.innerType._zod.optin),util.defineLazy(e._zod,"optout",()=>e._zod.innerType._zod.optout),e._zod.parse=(t,o)=>e._zod.innerType._zod.run(t,o)});export const $ZodCustom=core.$constructor("$ZodCustom",(e,t)=>{checks.$ZodCheck.init(e,t),$ZodType.init(e,t),e._zod.parse=(e,t)=>e,e._zod.check=o=>{const n=o.value,s=t.fn(n);if(s instanceof Promise)return s.then(t=>handleRefineResult(t,o,n,e));handleRefineResult(s,o,n,e)}});function handleRefineResult(e,t,o,n){if(!e){const e={code:"custom",input:o,inst:n,path:[...n._zod.def.path??[]],continue:!n._zod.def.abort};n._zod.def.params&&(e.params=n._zod.def.params),t.issues.push(util.issue(e))}}