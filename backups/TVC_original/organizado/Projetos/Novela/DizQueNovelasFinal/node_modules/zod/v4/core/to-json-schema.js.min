import{$ZodRegistry,globalRegistry}from"./registries.js";import{getEnumValues}from"./util.js";export class JSONSchemaGenerator{constructor(e){this.counter=0,this.metadataRegistry=e?.metadata??globalRegistry,this.target=e?.target??"draft-2020-12",this.unrepresentable=e?.unrepresentable??"throw",this.override=e?.override??(()=>{}),this.io=e?.io??"output",this.seen=new Map}process(e,t={path:[],schemaPath:[]}){var r;const s=e._zod.def,n={guid:"uuid",url:"uri",datetime:"date-time",json_string:"json-string",regex:""},a=this.seen.get(e);if(a){a.count++;return t.schemaPath.includes(e)&&(a.cycle=t.path),a.schema}const i={schema:{},count:1,cycle:void 0,path:t.path};this.seen.set(e,i);const o=e._zod.toJSONSchema?.();if(o)i.schema=o;else{const r={...t,schemaPath:[...t.schemaPath,e],path:t.path},a=e._zod.parent;if(a)i.ref=a,this.process(a,r),this.seen.get(a).isParent=!0;else{const t=i.schema;switch(s.type){case"string":{const r=t;r.type="string";const{minimum:s,maximum:a,format:o,patterns:c,contentEncoding:p}=e._zod.bag;if("number"==typeof s&&(r.minLength=s),"number"==typeof a&&(r.maxLength=a),o&&(r.format=n[o]??o,""===r.format&&delete r.format),p&&(r.contentEncoding=p),c&&c.size>0){const e=[...c];1===e.length?r.pattern=e[0].source:e.length>1&&(i.schema.allOf=[...e.map(e=>({..."draft-7"===this.target?{type:"string"}:{},pattern:e.source}))])}break}case"number":{const r=t,{minimum:s,maximum:n,format:a,multipleOf:i,exclusiveMaximum:o,exclusiveMinimum:c}=e._zod.bag;"string"==typeof a&&a.includes("int")?r.type="integer":r.type="number","number"==typeof c&&(r.exclusiveMinimum=c),"number"==typeof s&&(r.minimum=s,"number"==typeof c&&(c>=s?delete r.minimum:delete r.exclusiveMinimum)),"number"==typeof o&&(r.exclusiveMaximum=o),"number"==typeof n&&(r.maximum=n,"number"==typeof o&&(o<=n?delete r.maximum:delete r.exclusiveMaximum)),"number"==typeof i&&(r.multipleOf=i);break}case"boolean":t.type="boolean";break;case"bigint":if("throw"===this.unrepresentable)throw new Error("BigInt cannot be represented in JSON Schema");break;case"symbol":if("throw"===this.unrepresentable)throw new Error("Symbols cannot be represented in JSON Schema");break;case"null":t.type="null";break;case"any":case"unknown":break;case"undefined":if("throw"===this.unrepresentable)throw new Error("Undefined cannot be represented in JSON Schema");break;case"void":if("throw"===this.unrepresentable)throw new Error("Void cannot be represented in JSON Schema");break;case"never":t.not={};break;case"date":if("throw"===this.unrepresentable)throw new Error("Date cannot be represented in JSON Schema");break;case"array":{const n=t,{minimum:a,maximum:i}=e._zod.bag;"number"==typeof a&&(n.minItems=a),"number"==typeof i&&(n.maxItems=i),n.type="array",n.items=this.process(s.element,{...r,path:[...r.path,"items"]});break}case"object":{const e=t;e.type="object",e.properties={};const n=s.shape;for(const t in n)e.properties[t]=this.process(n[t],{...r,path:[...r.path,"properties",t]});const a=new Set(Object.keys(n)),i=new Set([...a].filter(e=>{const t=s.shape[e]._zod;return"input"===this.io?void 0===t.optin:void 0===t.optout}));i.size>0&&(e.required=Array.from(i)),"never"===s.catchall?._zod.def.type?e.additionalProperties=!1:s.catchall?s.catchall&&(e.additionalProperties=this.process(s.catchall,{...r,path:[...r.path,"additionalProperties"]})):"output"===this.io&&(e.additionalProperties=!1);break}case"union":t.anyOf=s.options.map((e,t)=>this.process(e,{...r,path:[...r.path,"anyOf",t]}));break;case"intersection":{const e=t,n=this.process(s.left,{...r,path:[...r.path,"allOf",0]}),a=this.process(s.right,{...r,path:[...r.path,"allOf",1]}),i=e=>"allOf"in e&&1===Object.keys(e).length,o=[...i(n)?n.allOf:[n],...i(a)?a.allOf:[a]];e.allOf=o;break}case"tuple":{const n=t;n.type="array";const a=s.items.map((e,t)=>this.process(e,{...r,path:[...r.path,"prefixItems",t]}));if("draft-2020-12"===this.target?n.prefixItems=a:n.items=a,s.rest){const e=this.process(s.rest,{...r,path:[...r.path,"items"]});"draft-2020-12"===this.target?n.items=e:n.additionalItems=e}s.rest&&(n.items=this.process(s.rest,{...r,path:[...r.path,"items"]}));const{minimum:i,maximum:o}=e._zod.bag;"number"==typeof i&&(n.minItems=i),"number"==typeof o&&(n.maxItems=o);break}case"record":{const e=t;e.type="object",e.propertyNames=this.process(s.keyType,{...r,path:[...r.path,"propertyNames"]}),e.additionalProperties=this.process(s.valueType,{...r,path:[...r.path,"additionalProperties"]});break}case"map":if("throw"===this.unrepresentable)throw new Error("Map cannot be represented in JSON Schema");break;case"set":if("throw"===this.unrepresentable)throw new Error("Set cannot be represented in JSON Schema");break;case"enum":{const e=t,r=getEnumValues(s.entries);r.every(e=>"number"==typeof e)&&(e.type="number"),r.every(e=>"string"==typeof e)&&(e.type="string"),e.enum=r;break}case"literal":{const e=t,r=[];for(const e of s.values)if(void 0===e){if("throw"===this.unrepresentable)throw new Error("Literal `undefined` cannot be represented in JSON Schema")}else if("bigint"==typeof e){if("throw"===this.unrepresentable)throw new Error("BigInt literals cannot be represented in JSON Schema");r.push(Number(e))}else r.push(e);if(0===r.length);else if(1===r.length){const t=r[0];e.type=null===t?"null":typeof t,e.const=t}else r.every(e=>"number"==typeof e)&&(e.type="number"),r.every(e=>"string"==typeof e)&&(e.type="string"),r.every(e=>"boolean"==typeof e)&&(e.type="string"),r.every(e=>null===e)&&(e.type="null"),e.enum=r;break}case"file":{const r=t,s={type:"string",format:"binary",contentEncoding:"binary"},{minimum:n,maximum:a,mime:i}=e._zod.bag;void 0!==n&&(s.minLength=n),void 0!==a&&(s.maxLength=a),i?1===i.length?(s.contentMediaType=i[0],Object.assign(r,s)):r.anyOf=i.map(e=>({...s,contentMediaType:e})):Object.assign(r,s);break}case"transform":if("throw"===this.unrepresentable)throw new Error("Transforms cannot be represented in JSON Schema");break;case"nullable":{const e=this.process(s.innerType,r);t.anyOf=[e,{type:"null"}];break}case"nonoptional":case"promise":case"optional":this.process(s.innerType,r),i.ref=s.innerType;break;case"success":t.type="boolean";break;case"default":this.process(s.innerType,r),i.ref=s.innerType,t.default=JSON.parse(JSON.stringify(s.defaultValue));break;case"prefault":this.process(s.innerType,r),i.ref=s.innerType,"input"===this.io&&(t._prefault=JSON.parse(JSON.stringify(s.defaultValue)));break;case"catch":{let e;this.process(s.innerType,r),i.ref=s.innerType;try{e=s.catchValue(void 0)}catch{throw new Error("Dynamic catch values are not supported in JSON Schema")}t.default=e;break}case"nan":if("throw"===this.unrepresentable)throw new Error("NaN cannot be represented in JSON Schema");break;case"template_literal":{const r=t,s=e._zod.pattern;if(!s)throw new Error("Pattern not found in template literal");r.type="string",r.pattern=s.source;break}case"pipe":{const e="input"===this.io?"transform"===s.in._zod.def.type?s.out:s.in:s.out;this.process(e,r),i.ref=e;break}case"readonly":this.process(s.innerType,r),i.ref=s.innerType,t.readOnly=!0;break;case"lazy":{const t=e._zod.innerType;this.process(t,r),i.ref=t;break}case"custom":if("throw"===this.unrepresentable)throw new Error("Custom types cannot be represented in JSON Schema")}}}const c=this.metadataRegistry.get(e);c&&Object.assign(i.schema,c),"input"===this.io&&isTransforming(e)&&(delete i.schema.examples,delete i.schema.default),"input"===this.io&&i.schema._prefault&&((r=i.schema).default??(r.default=i.schema._prefault)),delete i.schema._prefault;return this.seen.get(e).schema}emit(e,t){const r={cycles:t?.cycles??"ref",reused:t?.reused??"inline",external:t?.external??void 0},s=this.seen.get(e);if(!s)throw new Error("Unprocessed schema. This is a bug in Zod.");const n=e=>{const t="draft-2020-12"===this.target?"$defs":"definitions";if(r.external){const s=r.external.registry.get(e[0])?.id,n=r.external.uri??(e=>e);if(s)return{ref:n(s)};const a=e[1].defId??e[1].schema.id??"schema"+this.counter++;return e[1].defId=a,{defId:a,ref:`${n("__shared")}#/${t}/${a}`}}if(e[1]===s)return{ref:"#"};const n=`#/${t}/`,a=e[1].schema.id??"__schema"+this.counter++;return{defId:a,ref:n+a}},a=e=>{if(e[1].schema.$ref)return;const t=e[1],{ref:r,defId:s}=n(e);t.def={...t.schema},s&&(t.defId=s);const a=t.schema;for(const e in a)delete a[e];a.$ref=r};if("throw"===r.cycles)for(const e of this.seen.entries()){const t=e[1];if(t.cycle)throw new Error(`Cycle detected: #/${t.cycle?.join("/")}/<root>\n\nSet the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`)}for(const t of this.seen.entries()){const s=t[1];if(e===t[0]){a(t);continue}if(r.external){const s=r.external.registry.get(t[0])?.id;if(e!==t[0]&&s){a(t);continue}}const n=this.metadataRegistry.get(t[0])?.id;n?a(t):(s.cycle||s.count>1&&"ref"===r.reused)&&a(t)}const i=(e,t)=>{const r=this.seen.get(e),s=r.def??r.schema,n={...s};if(null===r.ref)return;const a=r.ref;if(r.ref=null,a){i(a,t);const e=this.seen.get(a).schema;e.$ref&&"draft-7"===t.target?(s.allOf=s.allOf??[],s.allOf.push(e)):(Object.assign(s,e),Object.assign(s,n))}r.isParent||this.override({zodSchema:e,jsonSchema:s,path:r.path??[]})};for(const e of[...this.seen.entries()].reverse())i(e[0],{target:this.target});const o={};if("draft-2020-12"===this.target?o.$schema="https://json-schema.org/draft/2020-12/schema":"draft-7"===this.target?o.$schema="http://json-schema.org/draft-07/schema#":console.warn(`Invalid target: ${this.target}`),r.external?.uri){const t=r.external.registry.get(e)?.id;if(!t)throw new Error("Schema is missing an `id` property");o.$id=r.external.uri(t)}Object.assign(o,s.def);const c=r.external?.defs??{};for(const e of this.seen.entries()){const t=e[1];t.def&&t.defId&&(c[t.defId]=t.def)}r.external||Object.keys(c).length>0&&("draft-2020-12"===this.target?o.$defs=c:o.definitions=c);try{return JSON.parse(JSON.stringify(o))}catch(e){throw new Error("Error converting schema to JSON.")}}}export function toJSONSchema(e,t){if(e instanceof $ZodRegistry){const r=new JSONSchemaGenerator(t),s={};for(const t of e._idmap.entries()){const[e,s]=t;r.process(s)}const n={},a={registry:e,uri:t?.uri,defs:s};for(const s of e._idmap.entries()){const[e,i]=s;n[e]=r.emit(i,{...t,external:a})}if(Object.keys(s).length>0){const e="draft-2020-12"===r.target?"$defs":"definitions";n.__shared={[e]:s}}return{schemas:n}}const r=new JSONSchemaGenerator(t);return r.process(e),r.emit(e,t)}function isTransforming(e,t){const r=t??{seen:new Set};if(r.seen.has(e))return!1;r.seen.add(e);const s=e._zod.def;switch(s.type){case"string":case"number":case"bigint":case"boolean":case"date":case"symbol":case"undefined":case"null":case"any":case"unknown":case"never":case"void":case"literal":case"enum":case"nan":case"file":case"template_literal":case"custom":case"success":case"catch":return!1;case"array":return isTransforming(s.element,r);case"object":for(const e in s.shape)if(isTransforming(s.shape[e],r))return!0;return!1;case"union":for(const e of s.options)if(isTransforming(e,r))return!0;return!1;case"intersection":return isTransforming(s.left,r)||isTransforming(s.right,r);case"tuple":for(const e of s.items)if(isTransforming(e,r))return!0;return!(!s.rest||!isTransforming(s.rest,r));case"record":case"map":return isTransforming(s.keyType,r)||isTransforming(s.valueType,r);case"set":return isTransforming(s.valueType,r);case"promise":case"optional":case"nonoptional":case"nullable":case"readonly":case"default":case"prefault":return isTransforming(s.innerType,r);case"lazy":return isTransforming(s.getter(),r);case"transform":return!0;case"pipe":return isTransforming(s.in,r)||isTransforming(s.out,r)}throw new Error(`Unknown schema type: ${s.type}`)}