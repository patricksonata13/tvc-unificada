import{util}from"./helpers/util.js";export const ZodIssueCode=util.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);export const quotelessJson=s=>JSON.stringify(s,null,2).replace(/"([^"]+)":/g,"$1:");export class ZodError extends Error{get errors(){return this.issues}constructor(s){super(),this.issues=[],this.addIssue=s=>{this.issues=[...this.issues,s]},this.addIssues=(s=[])=>{this.issues=[...this.issues,...s]};const r=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,r):this.__proto__=r,this.name="ZodError",this.issues=s}format(s){const r=s||function(s){return s.message},t={_errors:[]},e=s=>{for(const i of s.issues)if("invalid_union"===i.code)i.unionErrors.map(e);else if("invalid_return_type"===i.code)e(i.returnTypeError);else if("invalid_arguments"===i.code)e(i.argumentsError);else if(0===i.path.length)t._errors.push(r(i));else{let s=t,e=0;for(;e<i.path.length;){const t=i.path[e];e===i.path.length-1?(s[t]=s[t]||{_errors:[]},s[t]._errors.push(r(i))):s[t]=s[t]||{_errors:[]},s=s[t],e++}}};return e(this),t}static assert(s){if(!(s instanceof ZodError))throw new Error(`Not a ZodError: ${s}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,util.jsonStringifyReplacer,2)}get isEmpty(){return 0===this.issues.length}flatten(s=s=>s.message){const r={},t=[];for(const e of this.issues)if(e.path.length>0){const t=e.path[0];r[t]=r[t]||[],r[t].push(s(e))}else t.push(s(e));return{formErrors:t,fieldErrors:r}}get formErrors(){return this.flatten()}}ZodError.create=s=>new ZodError(s);