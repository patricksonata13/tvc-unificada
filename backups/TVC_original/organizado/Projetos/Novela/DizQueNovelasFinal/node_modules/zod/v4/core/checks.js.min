import*as core from"./core.js";import*as regexes from"./regexes.js";import*as util from"./util.js";export const $ZodCheck=core.$constructor("$ZodCheck",(e,t)=>{var o;e._zod??(e._zod={}),e._zod.def=t,(o=e._zod).onattach??(o.onattach=[])});const numericOriginMap={number:"number",bigint:"bigint",object:"date"};export const $ZodCheckLessThan=core.$constructor("$ZodCheckLessThan",(e,t)=>{$ZodCheck.init(e,t);const o=numericOriginMap[typeof t.value];e._zod.onattach.push(e=>{const o=e._zod.bag,i=(t.inclusive?o.maximum:o.exclusiveMaximum)??Number.POSITIVE_INFINITY;t.value<i&&(t.inclusive?o.maximum=t.value:o.exclusiveMaximum=t.value)}),e._zod.check=i=>{(t.inclusive?i.value<=t.value:i.value<t.value)||i.issues.push({origin:o,code:"too_big",maximum:t.value,input:i.value,inclusive:t.inclusive,inst:e,continue:!t.abort})}});export const $ZodCheckGreaterThan=core.$constructor("$ZodCheckGreaterThan",(e,t)=>{$ZodCheck.init(e,t);const o=numericOriginMap[typeof t.value];e._zod.onattach.push(e=>{const o=e._zod.bag,i=(t.inclusive?o.minimum:o.exclusiveMinimum)??Number.NEGATIVE_INFINITY;t.value>i&&(t.inclusive?o.minimum=t.value:o.exclusiveMinimum=t.value)}),e._zod.check=i=>{(t.inclusive?i.value>=t.value:i.value>t.value)||i.issues.push({origin:o,code:"too_small",minimum:t.value,input:i.value,inclusive:t.inclusive,inst:e,continue:!t.abort})}});export const $ZodCheckMultipleOf=core.$constructor("$ZodCheckMultipleOf",(e,t)=>{$ZodCheck.init(e,t),e._zod.onattach.push(e=>{var o;(o=e._zod.bag).multipleOf??(o.multipleOf=t.value)}),e._zod.check=o=>{if(typeof o.value!=typeof t.value)throw new Error("Cannot mix number and bigint in multiple_of check.");("bigint"==typeof o.value?o.value%t.value===BigInt(0):0===util.floatSafeRemainder(o.value,t.value))||o.issues.push({origin:typeof o.value,code:"not_multiple_of",divisor:t.value,input:o.value,inst:e,continue:!t.abort})}});export const $ZodCheckNumberFormat=core.$constructor("$ZodCheckNumberFormat",(e,t)=>{$ZodCheck.init(e,t),t.format=t.format||"float64";const o=t.format?.includes("int"),i=o?"int":"number",[n,s]=util.NUMBER_FORMAT_RANGES[t.format];e._zod.onattach.push(e=>{const i=e._zod.bag;i.format=t.format,i.minimum=n,i.maximum=s,o&&(i.pattern=regexes.integer)}),e._zod.check=u=>{const c=u.value;if(o){if(!Number.isInteger(c))return void u.issues.push({expected:i,format:t.format,code:"invalid_type",input:c,inst:e});if(!Number.isSafeInteger(c))return void(c>0?u.issues.push({input:c,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:i,continue:!t.abort}):u.issues.push({input:c,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:i,continue:!t.abort}))}c<n&&u.issues.push({origin:"number",input:c,code:"too_small",minimum:n,inclusive:!0,inst:e,continue:!t.abort}),c>s&&u.issues.push({origin:"number",input:c,code:"too_big",maximum:s,inst:e})}});export const $ZodCheckBigIntFormat=core.$constructor("$ZodCheckBigIntFormat",(e,t)=>{$ZodCheck.init(e,t);const[o,i]=util.BIGINT_FORMAT_RANGES[t.format];e._zod.onattach.push(e=>{const n=e._zod.bag;n.format=t.format,n.minimum=o,n.maximum=i}),e._zod.check=n=>{const s=n.value;s<o&&n.issues.push({origin:"bigint",input:s,code:"too_small",minimum:o,inclusive:!0,inst:e,continue:!t.abort}),s>i&&n.issues.push({origin:"bigint",input:s,code:"too_big",maximum:i,inst:e})}});export const $ZodCheckMaxSize=core.$constructor("$ZodCheckMaxSize",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.size}),e._zod.onattach.push(e=>{const o=e._zod.bag.maximum??Number.POSITIVE_INFINITY;t.maximum<o&&(e._zod.bag.maximum=t.maximum)}),e._zod.check=o=>{const i=o.value;i.size<=t.maximum||o.issues.push({origin:util.getSizableOrigin(i),code:"too_big",maximum:t.maximum,input:i,inst:e,continue:!t.abort})}});export const $ZodCheckMinSize=core.$constructor("$ZodCheckMinSize",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.size}),e._zod.onattach.push(e=>{const o=e._zod.bag.minimum??Number.NEGATIVE_INFINITY;t.minimum>o&&(e._zod.bag.minimum=t.minimum)}),e._zod.check=o=>{const i=o.value;i.size>=t.minimum||o.issues.push({origin:util.getSizableOrigin(i),code:"too_small",minimum:t.minimum,input:i,inst:e,continue:!t.abort})}});export const $ZodCheckSizeEquals=core.$constructor("$ZodCheckSizeEquals",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.size}),e._zod.onattach.push(e=>{const o=e._zod.bag;o.minimum=t.size,o.maximum=t.size,o.size=t.size}),e._zod.check=o=>{const i=o.value,n=i.size;if(n===t.size)return;const s=n>t.size;o.issues.push({origin:util.getSizableOrigin(i),...s?{code:"too_big",maximum:t.size}:{code:"too_small",minimum:t.size},inclusive:!0,exact:!0,input:o.value,inst:e,continue:!t.abort})}});export const $ZodCheckMaxLength=core.$constructor("$ZodCheckMaxLength",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.length}),e._zod.onattach.push(e=>{const o=e._zod.bag.maximum??Number.POSITIVE_INFINITY;t.maximum<o&&(e._zod.bag.maximum=t.maximum)}),e._zod.check=o=>{const i=o.value;if(i.length<=t.maximum)return;const n=util.getLengthableOrigin(i);o.issues.push({origin:n,code:"too_big",maximum:t.maximum,inclusive:!0,input:i,inst:e,continue:!t.abort})}});export const $ZodCheckMinLength=core.$constructor("$ZodCheckMinLength",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.length}),e._zod.onattach.push(e=>{const o=e._zod.bag.minimum??Number.NEGATIVE_INFINITY;t.minimum>o&&(e._zod.bag.minimum=t.minimum)}),e._zod.check=o=>{const i=o.value;if(i.length>=t.minimum)return;const n=util.getLengthableOrigin(i);o.issues.push({origin:n,code:"too_small",minimum:t.minimum,inclusive:!0,input:i,inst:e,continue:!t.abort})}});export const $ZodCheckLengthEquals=core.$constructor("$ZodCheckLengthEquals",(e,t)=>{var o;$ZodCheck.init(e,t),(o=e._zod.def).when??(o.when=e=>{const t=e.value;return!util.nullish(t)&&void 0!==t.length}),e._zod.onattach.push(e=>{const o=e._zod.bag;o.minimum=t.length,o.maximum=t.length,o.length=t.length}),e._zod.check=o=>{const i=o.value,n=i.length;if(n===t.length)return;const s=util.getLengthableOrigin(i),u=n>t.length;o.issues.push({origin:s,...u?{code:"too_big",maximum:t.length}:{code:"too_small",minimum:t.length},inclusive:!0,exact:!0,input:o.value,inst:e,continue:!t.abort})}});export const $ZodCheckStringFormat=core.$constructor("$ZodCheckStringFormat",(e,t)=>{var o,i;$ZodCheck.init(e,t),e._zod.onattach.push(e=>{const o=e._zod.bag;o.format=t.format,t.pattern&&(o.patterns??(o.patterns=new Set),o.patterns.add(t.pattern))}),t.pattern?(o=e._zod).check??(o.check=o=>{t.pattern.lastIndex=0,t.pattern.test(o.value)||o.issues.push({origin:"string",code:"invalid_format",format:t.format,input:o.value,...t.pattern?{pattern:t.pattern.toString()}:{},inst:e,continue:!t.abort})}):(i=e._zod).check??(i.check=()=>{})});export const $ZodCheckRegex=core.$constructor("$ZodCheckRegex",(e,t)=>{$ZodCheckStringFormat.init(e,t),e._zod.check=o=>{t.pattern.lastIndex=0,t.pattern.test(o.value)||o.issues.push({origin:"string",code:"invalid_format",format:"regex",input:o.value,pattern:t.pattern.toString(),inst:e,continue:!t.abort})}});export const $ZodCheckLowerCase=core.$constructor("$ZodCheckLowerCase",(e,t)=>{t.pattern??(t.pattern=regexes.lowercase),$ZodCheckStringFormat.init(e,t)});export const $ZodCheckUpperCase=core.$constructor("$ZodCheckUpperCase",(e,t)=>{t.pattern??(t.pattern=regexes.uppercase),$ZodCheckStringFormat.init(e,t)});export const $ZodCheckIncludes=core.$constructor("$ZodCheckIncludes",(e,t)=>{$ZodCheck.init(e,t);const o=util.escapeRegex(t.includes),i=new RegExp("number"==typeof t.position?`^.{${t.position}}${o}`:o);t.pattern=i,e._zod.onattach.push(e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set),t.patterns.add(i)}),e._zod.check=o=>{o.value.includes(t.includes,t.position)||o.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:t.includes,input:o.value,inst:e,continue:!t.abort})}});export const $ZodCheckStartsWith=core.$constructor("$ZodCheckStartsWith",(e,t)=>{$ZodCheck.init(e,t);const o=new RegExp(`^${util.escapeRegex(t.prefix)}.*`);t.pattern??(t.pattern=o),e._zod.onattach.push(e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set),t.patterns.add(o)}),e._zod.check=o=>{o.value.startsWith(t.prefix)||o.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:t.prefix,input:o.value,inst:e,continue:!t.abort})}});export const $ZodCheckEndsWith=core.$constructor("$ZodCheckEndsWith",(e,t)=>{$ZodCheck.init(e,t);const o=new RegExp(`.*${util.escapeRegex(t.suffix)}$`);t.pattern??(t.pattern=o),e._zod.onattach.push(e=>{const t=e._zod.bag;t.patterns??(t.patterns=new Set),t.patterns.add(o)}),e._zod.check=o=>{o.value.endsWith(t.suffix)||o.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:t.suffix,input:o.value,inst:e,continue:!t.abort})}});function handleCheckPropertyResult(e,t,o){e.issues.length&&t.issues.push(...util.prefixIssues(o,e.issues))}export const $ZodCheckProperty=core.$constructor("$ZodCheckProperty",(e,t)=>{$ZodCheck.init(e,t),e._zod.check=e=>{const o=t.schema._zod.run({value:e.value[t.property],issues:[]},{});if(o instanceof Promise)return o.then(o=>handleCheckPropertyResult(o,e,t.property));handleCheckPropertyResult(o,e,t.property)}});export const $ZodCheckMimeType=core.$constructor("$ZodCheckMimeType",(e,t)=>{$ZodCheck.init(e,t);const o=new Set(t.mime);e._zod.onattach.push(e=>{e._zod.bag.mime=t.mime}),e._zod.check=i=>{o.has(i.value.type)||i.issues.push({code:"invalid_value",values:t.mime,input:i.value.type,inst:e})}});export const $ZodCheckOverwrite=core.$constructor("$ZodCheckOverwrite",(e,t)=>{$ZodCheck.init(e,t),e._zod.check=e=>{e.value=t.tx(e.value)}});